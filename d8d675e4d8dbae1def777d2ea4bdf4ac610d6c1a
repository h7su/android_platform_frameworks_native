{
  "comments": [
    {
      "key": {
        "uuid": "3620a159_90aa1e8c",
        "filename": "libs/binder/rust/benches/Android.bp",
        "patchSetId": 6
      },
      "lineNbr": 23,
      "author": {
        "id": 1416371
      },
      "writtenOn": "2020-05-10T19:19:46Z",
      "side": 1,
      "message": "Why are you using this over std::time? Using bindgen + C++ just to do timing measurement seems like overkill.",
      "revId": "d8d675e4d8dbae1def777d2ea4bdf4ac610d6c1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a81aab5e_8de21fa5",
        "filename": "libs/binder/rust/benches/Android.bp",
        "patchSetId": 6
      },
      "lineNbr": 23,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-05-11T17:29:27Z",
      "side": 1,
      "message": "I discovered using std::time itself added about a 5-7% slowdown to average transaction time compared to the C++ version. From profiling it looked like there was extra computation happening inside the timing loop, so I wanted to try measuring time exactly the same way as the C++ benchmark so that I had comparable results. I didn\u0027t investigate further after trying the C++ shims and seeing that the overhead was gone, so I can\u0027t say exactly what the issue was.\n\nThis is a temporary measure; I don\u0027t think this should be merged in, but I did want to post the patch in case you or someone else wanted to benchmark on other hardware. I\u0027m hoping that criterion measurements will be comparable to C++ chrono. If criterion is still a ways off, I will investigate this further and find a simpler solution.",
      "parentUuid": "3620a159_90aa1e8c",
      "revId": "d8d675e4d8dbae1def777d2ea4bdf4ac610d6c1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4695097c_e389f123",
        "filename": "libs/binder/rust/benches/Android.bp",
        "patchSetId": 6
      },
      "lineNbr": 23,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-05-14T19:32:18Z",
      "side": 1,
      "message": "Dug into this, and I can now explain why Instant::now is so slow in this case. Instant does extra work to provide a monotonically increasing clock, which includes taking a lock on a mutex (https://doc.rust-lang.org/src/std/time.rs.html#202-242). The chrono::high_resolution_clock does not provide this guarantee. I think we should call clock_gettime directly from Rust and do the interval computation manually.\n\nIncidentally, the default measurement in Criterion uses Instant::now as well. They don\u0027t measure individual loop iterations though, instead measuring N iterations of the tight loop and dividing. We could do that which would lower the impact of Instant::now, but I\u0027m still hesitant to compare this directly against the C++ version.",
      "parentUuid": "a81aab5e_8de21fa5",
      "revId": "d8d675e4d8dbae1def777d2ea4bdf4ac610d6c1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de9837e9_baa1abed",
        "filename": "libs/binder/rust/benches/Android.bp",
        "patchSetId": 6
      },
      "lineNbr": 23,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-05-18T20:28:01Z",
      "side": 1,
      "message": "Replaced this with libc::clock_gettime.",
      "parentUuid": "4695097c_e389f123",
      "revId": "d8d675e4d8dbae1def777d2ea4bdf4ac610d6c1a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}