{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7f847111_9d9c443d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002669
      },
      "writtenOn": "2022-07-20T13:16:29Z",
      "side": 1,
      "message": "Hello I found a few issues in EventHub when using some USB touchpanels in a multi-display automotive setup where we were using the same display/touchpanel for multiple screens. The fixes for these looked fairly straight forward so I thought I would share this back upstream in case it will help others that run into the same issue. Let me know if there are any questions or clarifications needed. I tried to put some examples of the issue in the commit message to help clarify the problem I was running into. Thanks in advance for the help reviewing this.",
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6146f95_9b0d6831",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2022-07-21T03:39:06Z",
      "side": 1,
      "message": "This generally lgtm. Could you add a test to EventHub_test.cpp?\n\nframeworks/native/services/inputflinger/tests/EventHub_test.cpp\n\nSomething like:\n\n    TEST_F(EventHubTest, DevicesWithMatchingUniqueIdsAreUnique) {\n      std::unique_ptr\u003cUinputHomeKey\u003e keyboard2 \u003d createUinputDevice\u003cUinputHomeKey\u003e();\n      int32_t deviceId2;\n      ASSERT_NO_FATAL_FAILURE(deviceId2 \u003d waitForDeviceCreation());\n      \n      ASSERT_EQ(mEventHub-\u003egetDeviceIdentifier(mDeviceId).descriptor, mEventHub-\u003egetDeviceIdentifier(deviceId2).descriptor);\n      \n      keyboard2.reset();\n      waitForDeviceClose(deviceId2);\n    }",
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8cf92214_97e39f2e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2022-07-21T03:40:24Z",
      "side": 1,
      "message": "The dumps are super helpful, thanks for adding those!",
      "parentUuid": "7f847111_9d9c443d",
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "157d159b_528a9ffb",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1006497
      },
      "writtenOn": "2022-07-21T21:58:32Z",
      "side": 1,
      "message": "Can we add tests for this case as well?",
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "278b4970_6050e866",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002669
      },
      "writtenOn": "2022-07-21T22:55:31Z",
      "side": 1,
      "message": "Sure I can get a test added as well. Thanks for pointing out where to put the test and an implementation.",
      "parentUuid": "e6146f95_9b0d6831",
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2da858c5_bf63fd80",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1002669
      },
      "writtenOn": "2022-07-21T22:55:31Z",
      "side": 1,
      "message": "Thanks for the feedback everyone. I am out of the office until Monday. I will get a new patch up to address the review comments and add a test for this then. If there is any other feedback on the replies I added about keeping the descriptor stable let me know. If that is not a requirement we need to worry about I can also change the implementation to just use the location for file path to ensure the descriptor is unique and remove the checks for conflicting descriptors and falling back to the nonce to ensure uniqueness.",
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bfd9d988_c14edd98",
        "filename": "services/inputflinger/reader/EventHub.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1265,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2022-07-21T03:39:06Z",
      "side": 1,
      "message": "rather than using a \"nonce\", wdyt about simply appending the file path of the device to the \"rawDescriptor\" string? Like:\n\n    rawDescriptor +\u003d \"/dev/input/event3\";\n    \nwould that allow us to generate a unique descriptor without having to look at \u0027mOpeningDevices\u0027 or using a nonce at all?",
      "range": {
        "startLine": 1264,
        "startChar": 5,
        "endLine": 1265,
        "endChar": 32
      },
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4f8f2516_16bb73bf",
        "filename": "services/inputflinger/reader/EventHub.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1265,
      "author": {
        "id": 1002669
      },
      "writtenOn": "2022-07-21T22:55:31Z",
      "side": 1,
      "message": "Thanks for the feedback. I had considered using either location or file path, but I saw this comment at the beginning of the assignDescriptor method:\n\n    // Compute a device descriptor that uniquely identifies the device.\n    // The descriptor is assumed to be a stable identifier.  Its value should not\n    // change between reboots, reconnections, firmware updates or new releases\n    // of Android. In practice we sometimes get devices that cannot be uniquely\n    // identified. In this case we enforce uniqueness between connected devices.\n    // Ideally, we also want the descriptor to be short and relatively opaque.\n\nThis made me think that the reason it was currently implemented this way was that there was requirement to keep the descriptor the same whenever possible. It looked like using the nonce here was a fallback in the case that a unique descriptor could not be created using other information. I was not sure of the reasoning behind this requirement other than what I saw in the comment. Adding the file path to the raw descriptor would cause the descriptor to change whenever the kernel assigned a different file path to the device.\n\nIf keeping the descriptor stable in most cases is not actually needed I can change this to just always add the file path to the raw descriptor.",
      "parentUuid": "bfd9d988_c14edd98",
      "range": {
        "startLine": 1264,
        "startChar": 5,
        "endLine": 1265,
        "endChar": 32
      },
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ef0b83be_d5e4995d",
        "filename": "services/inputflinger/reader/EventHub.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1265,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2022-07-22T16:05:10Z",
      "side": 1,
      "message": "Thanks. I thought about this some more, and I\u0027m now thinking that nonce is the right approach.\n\nI think the goal of this code is like this: generate a unique way to identify a device that does not depend on how it\u0027s connected. So if we take a certain device, and connect it to USB1, and later disconnect, and connect it to USB2, it should still have the same descriptor.\n\nIf we use a nonce, then 2 identical devices will become \"device0\" and \"device1\". \n\nIf we connect these 2 devices in a different manner, they would still be \"device0\" and \"device1\", which is what we want here. If the devices are identical, then either one can be considered as \"device0\".\n\nIf we were to consider things like file path or location, then these 2 devices could become \"device0usb1\" and \"device0usb3\", or for example \"device0/dev/input/event1\" and \"device0/dev/input/event6\". On reconnection, they could become \"device0usb2\" and \"device0usb0\", and so on. These identifiers would now be different depending on whether other input devices are connected to the system. That\u0027s not desirable according to the comment.\n\nTherefore, let\u0027s go with the nonce approach.",
      "parentUuid": "4f8f2516_16bb73bf",
      "range": {
        "startLine": 1264,
        "startChar": 5,
        "endLine": 1265,
        "endChar": 32
      },
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d40bf4f6_d7a516d7",
        "filename": "services/inputflinger/reader/EventHub.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1281,
      "author": {
        "id": 1407716
      },
      "writtenOn": "2022-07-21T19:46:49Z",
      "side": 1,
      "message": "Siarhei, do you know why we\u0027re only conditionally including these values in the descriptor? Why don\u0027t we just always use all the values (vid, pid, uniqueId, name, location, nonce), and only then fall back to changing the nonce?\n\nThis way, the touchscreens don\u0027t have to rely on nonce, since the location is different. If they also had the same location, then it would depend on the nonce, which depends on order in which the devices are opened relative to each other. The touchscreen that\u0027s processed first will always have the same descriptor. We can\u0027t guarantee that if we use the path (e.g. /dev/input/event4) in the descriptor.",
      "range": {
        "startLine": 1269,
        "startChar": 0,
        "endLine": 1281,
        "endChar": 5
      },
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "12b0587e_de881238",
        "filename": "services/inputflinger/reader/EventHub.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1281,
      "author": {
        "id": 1002669
      },
      "writtenOn": "2022-07-21T22:55:31Z",
      "side": 1,
      "message": "Prabir,\n\nI saw this comment in assignDescriptor method which says that they descriptor should be stable whenever possible:\n\n    // Compute a device descriptor that uniquely identifies the device.\n    // The descriptor is assumed to be a stable identifier.  Its value should not\n    // change between reboots, reconnections, firmware updates or new releases\n    // of Android. In practice we sometimes get devices that cannot be uniquely\n    // identified. In this case we enforce uniqueness between connected devices.\n    // Ideally, we also want the descriptor to be short and relatively opaque.\n\nI am not sure why that is a requirement, but my assumption was that it was implemented this way for a reason and the the fallback to using a nonce was a workaround for cases where a stable descriptor could not be generated.\n\nAny chance the descriptor is persisted somewhere? That might drive the requirement of it being stable across reboots, reconnections and firmware updates.",
      "parentUuid": "d40bf4f6_d7a516d7",
      "range": {
        "startLine": 1269,
        "startChar": 0,
        "endLine": 1281,
        "endChar": 5
      },
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7e1284f_dd4bbe28",
        "filename": "services/inputflinger/reader/EventHub.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1281,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2022-07-22T16:05:10Z",
      "side": 1,
      "message": "I think if we combine the comments in \"assignDescriptorLocked\" L1286 and L1270, and my comment above, then this makes sense. It\u0027s true that typically touchscreens that are built-in don\u0027t set vendor and product id\u0027s, so their \u0027location\u0027 is probably not going to change.\n\nThis doesn\u0027t work for cases like the Sony DualShock bug on Samsung devices where the vendor/product ids are reported as 0, but we can\u0027t possibly be resilient to such bugs.\n\nIt would be awesome to add a comment to the code that explains why we *don\u0027t* use things like file path or location in the \"regular\" case. Joshua, could you add a comment like that?",
      "parentUuid": "12b0587e_de881238",
      "range": {
        "startLine": 1269,
        "startChar": 0,
        "endLine": 1281,
        "endChar": 5
      },
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68765b17_68828393",
        "filename": "services/inputflinger/reader/EventHub.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1298,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2022-07-21T03:39:06Z",
      "side": 1,
      "message": "hasDeviceWithDescriptorLocked(identifier.descriptor) ||\n           hasOpeningDeviceWithDescriptorLocked(identifier.descriptor)",
      "range": {
        "startLine": 1297,
        "startChar": 11,
        "endLine": 1298,
        "endChar": 79
      },
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9a4f24e4_f847b4c6",
        "filename": "services/inputflinger/reader/EventHub.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1298,
      "author": {
        "id": 1002669
      },
      "writtenOn": "2022-07-21T22:55:31Z",
      "side": 1,
      "message": "I agree that would be better. I can get that changed.",
      "parentUuid": "68765b17_68828393",
      "range": {
        "startLine": 1297,
        "startChar": 11,
        "endLine": 1298,
        "endChar": 79
      },
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1bffdd5c_d58a1e14",
        "filename": "services/inputflinger/reader/EventHub.cpp",
        "patchSetId": 1
      },
      "lineNbr": 1375,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2022-07-22T16:05:10Z",
      "side": 1,
      "message": "plz fix line length. did you get any preupload warnings here?",
      "revId": "9b35d2487158262359c7c6c19cb3146876ebb389",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}