{
  "comments": [
    {
      "key": {
        "uuid": "d3cd99a5_fd6d9795",
        "filename": "libs/binder/ndk/include_cpp/android/binder_auto_utils.h",
        "patchSetId": 1
      },
      "lineNbr": 205,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-22T22:30:12Z",
      "side": 1,
      "message": "when we were talking in the bug, I thought that I could insert the \u0027if status \u003d\u003d nullptr and api level \u003c 31, status \u003d AStatus_newOk\u0027 on top of libbinder_ndk. However, there is no existing ::ndk::writeStatusHeader which old versions of the AIDL compiler can reference, and there are many other AStatus APIs that would need similar wrappers. So, I\u0027m not sure of a better solution.\n\nOne thing that we could do to prevent crashes on old devices for incorrect usage (and also prevent the crash ilya originally filed the bug for) is to have L207 initialize AStatus with AStatus_newOk. However, this will add additional heap allocations in other cases, namely:\n\n    ScopedAStatus _aidl_status;  // extra allocation\n    ... \u003d AParcel_readStatusHeader(..., _aidl_status.getR());\n\nSo, I can only think of supporting nullptr now, but I cannot think of a way to allow methods to successfully have \"return ScopedAStatus();\" or error in that case which still compiles against old versions of the AIDL compiler.",
      "revId": "a544f8fe7ad93035bc3dd5349fac6ccabb3a865f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ef19b5f_7e75e8ca",
        "filename": "libs/binder/ndk/include_cpp/android/binder_auto_utils.h",
        "patchSetId": 1
      },
      "lineNbr": 205,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2020-09-23T07:01:08Z",
      "side": 1,
      "message": "I don\u0027t think we have a way to allow \u0027return ScopeAStatus()\u0027 to apps running on older platforms, without causing the extra heap alloc at all.\n\nThe incorrect use doesn\u0027t happen always - only when someone makes a mistake, but the extra heap alloc will happen always - if we modify the default constructor. So, to me, not making the extra heap alloc seems to be much more important than allowing the mistake.\n\nFurthermore, if we allocate AStatus inside the constructor, then we will have a memory leak because the pointer *getR() will be overwritten by AParcel_readStatusHeader. One more reason for not taking this.\n\n-------\nTo be better, how about this? \n\nIf we can amend the AIDL compiler...\n\nScopedAStatus _aidl_status(nullptr); // explicit use of nullptr\n... \u003d AParcel_readStatusHeader(..., _aidl_status.getR());\n\nclass ScopedAStatus : ... {\npublic:\n  explicit ScopedAStatus(AStatus* a) : ScopedAResource(a) {} // drop \"\u003d nullptr\"\n#if __ANDROID_API__ \u003c 31\n  ScopedAStatus() : ScopedAResource(AStatus_newOk()) {}\n#else\n  ScopedAStatus() : ScopedAResource(nullptr) {}\n#endif\n};\n\nThen, we will have the extra heap alloc only when someone mistakenly (?) use \u0027return ScopedAStatus();\u0027 when targeting pre-31. I think \u0027return ScopedAStatus(nullptr);\u0027 should however be punished :)",
      "parentUuid": "d3cd99a5_fd6d9795",
      "revId": "a544f8fe7ad93035bc3dd5349fac6ccabb3a865f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ea364bc3_9cbc6dc5",
        "filename": "libs/binder/ndk/include_cpp/android/binder_auto_utils.h",
        "patchSetId": 1
      },
      "lineNbr": 205,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-23T17:17:20Z",
      "side": 1,
      "message": "This will also leak/have an extra allocation when compiled with old versions of the AIDL compiler.\n\n\u003e The incorrect use doesn\u0027t happen always - only when someone makes a mistake\n\nAnd after this change, the mistake will be easier to make. I\u0027m curious jreck\u0027s decision here. We could just take the documentation change instead and only make a performance change when/if it is needed.",
      "parentUuid": "1ef19b5f_7e75e8ca",
      "revId": "a544f8fe7ad93035bc3dd5349fac6ccabb3a865f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4925fee3_ca5d66d7",
        "filename": "libs/binder/ndk/include_cpp/android/binder_auto_utils.h",
        "patchSetId": 1
      },
      "lineNbr": 205,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2020-09-23T18:24:48Z",
      "side": 1,
      "message": "I\u0027m not really a fan of the use of null as a proxy here. It\u0027s a fragile change that becomes easy to make mistakes (and it becomes more challenging to recognize \"null\" meant OK vs. \"null\" meant my error path failed), and I think it can be avoided anyway.\n\nSince AStatus is immutable, you can have AStatus_newOk() just return the same static instance, and AStatus_delete can compare against that static instance to decide if it should actually delete or not. Then all existing binaries get the speedup without even needing a recompile.\n\nFor backporting that change, I think ScopedAStatus could functionally do the same thing as well? Or just don\u0027t backport it, that\u0027s fine, too.",
      "parentUuid": "ea364bc3_9cbc6dc5",
      "revId": "a544f8fe7ad93035bc3dd5349fac6ccabb3a865f",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}