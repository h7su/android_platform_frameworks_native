{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ef661f3d_17effdc7",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 469,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-06-08T20:18:16Z",
      "side": 1,
      "message": "If there are multiple people trying to setup a server, it seems this might shutdown one that is being used by something else.\n\nWDYT about a function like RpcServer::onSessionShutdown (extending the event listener maybe or similar) so that we can tell it to shutdown the server when there are no sessions remaining? Or we could add an option like \u0027RpcServer::setShutdownOnAllSessionsExit\u0027 (name?)?",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 469,
        "endChar": 25
      },
      "revId": "3c2d78c086c0ee66dc4f3dcb6271eb4e7d0177b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6a734619_fe1e078b",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 469,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-06-08T21:12:00Z",
      "side": 1,
      "message": "Your suggestion is good, except that in this case, the system property set by servicedispatcher aren\u0027t properly cleaned up. Having the service to clean up that system property will be very messy IMO.\n\nThis can be fixed by having the service itself remember which port it is setting the RpcServer on instead of relying on a system property, and erase that when RpcServer ends. Then we can have RpcServer::setShutdownOnAllSessionsExit.\n\nWDYT?",
      "parentUuid": "ef661f3d_17effdc7",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 469,
        "endChar": 25
      },
      "revId": "3c2d78c086c0ee66dc4f3dcb6271eb4e7d0177b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6cf09851_48e7069e",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 469,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-06-08T21:41:31Z",
      "side": 1,
      "message": "What if the service returns the port if it is already setup, rather than using the system property? That might also help this work on systems w/o properties (maybe some VMs, host).\n\n\u003e the service itself remember which port it is setting the RpcServer on instead of relying on a system property\n\nWe can keep the entire SocketAddress around, yeah. This is a prerequisite for b/189955605 too.",
      "parentUuid": "6a734619_fe1e078b",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 469,
        "endChar": 25
      },
      "revId": "3c2d78c086c0ee66dc4f3dcb6271eb4e7d0177b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a259b5f_bc51734f",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 469,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-06-08T22:04:16Z",
      "side": 1,
      "message": "As of now, the service does not know anything about the port.\n\n1. servicedispatcher sets up the socket and knows the port.\n2. servicedispatcher sends the socket fd to the service.\n\nThat\u0027s why I kept the system properties in servicedispatcher. The service knows nothing about ports. It just uses the fd directly. For the service to know about the port, I have to let servicedispatcher send the port number to the service during the first set up. WDYT about this?\n\n```\nsetRpcClientDebug(unique_fd socketFd, uint32_t portForFd)\n```",
      "parentUuid": "6cf09851_48e7069e",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 469,
        "endChar": 25
      },
      "revId": "3c2d78c086c0ee66dc4f3dcb6271eb4e7d0177b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "79aee310_a370cf12",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 469,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-06-09T21:02:45Z",
      "side": 1,
      "message": "I can also have a long-running servicedispatcher. When servicedispatcher dies (due to manually killing it, adb shutting down, etc.), the port is shut down. In this case, we\u0027ll need one port per host application, meaning that I\u0027ll need to keep a list of RpcServer\u0027s in the binder object to support multiple clients.\n\nWDYT about that?",
      "parentUuid": "1a259b5f_bc51734f",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 469,
        "endChar": 25
      },
      "revId": "3c2d78c086c0ee66dc4f3dcb6271eb4e7d0177b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce9720c8_903e5ff4",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 469,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-06-09T21:25:05Z",
      "side": 1,
      "message": "If there is a long-running process on the phone, it needs to only be alive for the duration that binder RPC is in use.\n\nDo you mean as a daemon OR kept alive by the adb session (I like this last option quite a bit actually)?",
      "parentUuid": "79aee310_a370cf12",
      "range": {
        "startLine": 469,
        "startChar": 0,
        "endLine": 469,
        "endChar": 25
      },
      "revId": "3c2d78c086c0ee66dc4f3dcb6271eb4e7d0177b6",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}