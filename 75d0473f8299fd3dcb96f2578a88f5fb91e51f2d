{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "5b23a43e_0e63bcb8",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 123,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-08-23T05:07:43Z",
      "side": 1,
      "message": "It will be nicer if you could wait for the processes to exit with a timeout rather than unconditionally waiting.",
      "range": {
        "startLine": 123,
        "startChar": 12,
        "endLine": 123,
        "endChar": 39
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7e145dc9_0336d795",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 123,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-23T16:03:01Z",
      "side": 1,
      "message": "waiting for multiple child processes is problematic (hard to do it in single thread) and cost is 100ms. So I will keep the current shape as saving may not be that big.",
      "parentUuid": "5b23a43e_0e63bcb8",
      "range": {
        "startLine": 123,
        "startChar": 12,
        "endLine": 123,
        "endChar": 39
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b4a334e_c67a1529",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 123,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-08-23T17:06:14Z",
      "side": 1,
      "message": "The 100ms figure looks very arbitrary. Waiting for child processes with a timeout allows increasing the timeout to a longer time without adding extra costs in normal cases. If you feel that this is hard to implement, I\u0027d suggest removing the SIGTERM and the 100ms sleep. AFAIK, it\u0027s fine to just sending dex2oat a SIGKILL.",
      "parentUuid": "7e145dc9_0336d795",
      "range": {
        "startLine": 123,
        "startChar": 12,
        "endLine": 123,
        "endChar": 39
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bcfc78c5_7119e557",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 123,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-23T17:58:49Z",
      "side": 1,
      "message": "ok, then I will send SIGKILL only.",
      "parentUuid": "2b4a334e_c67a1529",
      "range": {
        "startLine": 123,
        "startChar": 12,
        "endLine": 123,
        "endChar": 39
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d662033e_915798ff",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1725,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-08-23T06:57:38Z",
      "side": 1,
      "message": "If the client calls controlDexOptBlocking(true) immediately followed by a controlDexOptBlocking(false), there can be a race condition where `cancelled` may be `false` even though the child process is actually killed.\n\nCould you try some more reliable way to determine if a child is killed (such as WTERMSIG) rather than relying on check_if_killed_and_remove_dexopt_pid?",
      "range": {
        "startLine": 1725,
        "startChar": 4,
        "endLine": 1725,
        "endChar": 80
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dc5e53f3_94d24362",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1725,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-23T16:03:01Z",
      "side": 1,
      "message": "In that case, the session will be returned as error. Regardless of that, the client cancelling in system server side waits until the pending cancellation is completed before calling controlDexOptBlocking(false), so it should not be a concern as the situation will not happen from the client side.",
      "parentUuid": "d662033e_915798ff",
      "range": {
        "startLine": 1725,
        "startChar": 4,
        "endLine": 1725,
        "endChar": 80
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "dc53868e_c2c705ce",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1725,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-23T16:24:32Z",
      "side": 1,
      "message": "We will have system server side change in internal gerrit. When that CL is reviewed, you can see how system server will handle this.",
      "parentUuid": "dc5e53f3_94d24362",
      "range": {
        "startLine": 1725,
        "startChar": 4,
        "endLine": 1725,
        "endChar": 80
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e592032_1c189ce6",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1725,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-08-23T17:06:14Z",
      "side": 1,
      "message": "It\u0027s probably not a good idea to assume how the client will use an API, even though the API has only one usage for now. At the very least, it should be documented in the AIDL that using the API in a particular way may lead to an unexpected behavior. However, in this particular case, I still think a more elegant solution is to determine if a child is killed using WTERMSIG or something like that.",
      "parentUuid": "dc53868e_c2c705ce",
      "range": {
        "startLine": 1725,
        "startChar": 4,
        "endLine": 1725,
        "endChar": 80
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7629b833_70058487",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1725,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-23T17:58:49Z",
      "side": 1,
      "message": "WTERMSIG alone is not necessarily bulletproof as we do not know if it was killed by this or something else. Returning cancelled while it was killed due to other reason is more problematic. Client getting error for the run is fine if we cannot sort out the cause properly and if the process has died. Whole stack is robust against such case: Failed one will be retries later.\nI will change it to check SIGKILL + cancelled while cancelled dropped early will be returned as regular error.",
      "parentUuid": "7e592032_1c189ce6",
      "range": {
        "startLine": 1725,
        "startChar": 4,
        "endLine": 1725,
        "endChar": 80
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3bbb366c_0b4510c3",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1725,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-08-24T03:27:15Z",
      "side": 1,
      "message": "I see. Thank you for the explanation. I got the point that treating \"Cancelled\" as \"Error\" is better than treating \"Error\" as \"Cancelled\". However, I believe there are still other ways to reliability check if the process is cancelled by the API call and avoid race condition. I can see a need in solving the problem: A client may want to call controlDexOptBlocking(false) right after controlDexOptBlocking(true) just for cancelling the current dexopt runs without blocking any future runs.\n\nOne of the ways to avoid race condition is not to clear dexopt_killed_pids_ when control_dexopt_blocking(false) is called. I don\u0027t see many benefits in clearing the set in such case as pids in the set will be removed by check_if_killed_and_remove_dexopt_pid() anyway.\n\nPS: If you think pids may not guarantee uniqueness as they can be reused by the OS, you may provide a unique identifier when you call add_dexopt_pid() and use that unique identifier for calling check_if_killed_and_remove_dexopt_pid().",
      "parentUuid": "7629b833_70058487",
      "range": {
        "startLine": 1725,
        "startChar": 4,
        "endLine": 1725,
        "endChar": 80
      },
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "024108e9_4340ea53",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1777,
      "author": {
        "id": 1884045
      },
      "writtenOn": "2021-08-23T05:07:43Z",
      "side": 1,
      "message": "Nit: Extraneous new line.",
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4ebfa9cc_544f3c42",
        "filename": "cmds/installd/dexopt.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1777,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-23T16:02:36Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "024108e9_4340ea53",
      "revId": "75d0473f8299fd3dcb96f2578a88f5fb91e51f2d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}