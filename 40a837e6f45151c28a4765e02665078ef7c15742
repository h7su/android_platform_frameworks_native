{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d5b07b81_fdea0bd4",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-06-13T19:45:55Z",
      "side": 1,
      "message": "Should we copy the underlying data (Parcel or Arc\u003cParcelable\u003e), like NDK/C++ backends do? Since this is behind a mutex, it seems difficult to prove code doesn\u0027t mutate ParcelableHolderData in a way that would break other ParcelableHolder objects pointing to the same data.\n\nIf we don\u0027t need a real copy of ParcelableHolder, could other code use Arc\u003cParcelableHolder\u003e?",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd8032ad_c53a0bce",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1611820
      },
      "writtenOn": "2023-06-13T19:58:23Z",
      "side": 1,
      "message": "I\u0027d prefer copying the underlying data; but I\u0027ll defer to Andrei who understands the Rust ParcelableHolder better.",
      "parentUuid": "d5b07b81_fdea0bd4",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55144df5_d49fba8a",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1611820
      },
      "writtenOn": "2023-06-13T20:01:22Z",
      "side": 1,
      "message": "Looks like the C++ backend use a std::shared_ptr(). \n\nhttps://source.corp.google.com/h/googleplex-android/platform/superproject/+/master:frameworks/native/libs/binder/include/binder/ParcelableHolder.h;l\u003d139",
      "parentUuid": "dd8032ad_c53a0bce",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e07337fd_d58ccb73",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-06-13T20:42:43Z",
      "side": 1,
      "message": "The NDK backend copies the parcelable (AParcelableHolder). Java doesn\u0027t. Thoughts Jiyong/Jeongik?",
      "parentUuid": "55144df5_d49fba8a",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a6c642a_2a5b258c",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-06-13T23:16:29Z",
      "side": 1,
      "message": "`ParcelableHolderData` implements `Clone` and `ParcelableHolder` used to derive it too. It got removed when we switched from `RefCell` to `Mutex` for thread-safety.\n\nAdding `Arc` is one approach, another would be to manually implement `Clone` and create a new `Mutex`:\n```\nimpl Clone for ParcelableHolder {\n  fn clone(\u0026self) -\u003e ParcelableHolder {\n    ParcelableHolder {\n      data: Mutex::new(self.data.lock().unwrap().clone()),\n      stability: self.stability,\n  }\n}\n```\n\nI\u0027m not sure which one is preferable, the `Arc` approach adds an extra level of indirection but shares the data between copies, which is mainly relevant for the `ParcelableHolderData::Parcel` case. `Parcel::clone` is a deep copy, so this circles back to the original question: do we want `ParcelableHolder::clone` to do that or not? I don\u0027t have a strong opinion here.",
      "parentUuid": "e07337fd_d58ccb73",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b86302b9_00dd1377",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2023-06-13T23:58:10Z",
      "side": 1,
      "message": "I\u0027d prefer cloning the enclosed Parcelable. When cloning ParcelableHolder, cloning the enclosed one must be the usual expectation.",
      "parentUuid": "3a6c642a_2a5b258c",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51c54e63_a7f99674",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1611820
      },
      "writtenOn": "2023-06-14T00:04:23Z",
      "side": 1,
      "message": "Alternatively we can use `Arc\u003cParcelableHolderData\u003e` instead of `Mutex\u003cParcelableHolderData\u003e` or `Arc\u003cMutex\u003cParcelableHolderData\u003e\u003e` to bring this on par with the C++ impl.\n\nArc\u003cT\u003e is immutable by default; it\u0027s both thread-safe and fast to clone. \n\nTo mutate the ParcelableHolderData, we can use Arc::make_mut() which creates a new clone, i.e., copy-on-write.",
      "parentUuid": "55144df5_d49fba8a",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "02a850a7_ad43f8aa",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-06-14T00:21:17Z",
      "side": 1,
      "message": "`Parcel` is `Send + !Sync`, which means that `Arc\u003cParcelableHolderData\u003e` would be `!Send + !Sync` (since per https://doc.rust-lang.org/std/sync/struct.Arc.html#impl-Sync-for-Arc%3CT%3E `Arc` implements both traits if the inner type also has both).\n\n`Mutex` \"adds\" thread-safety in a way that `Arc` doesn\u0027t: the inner type is only required to be `Send`, so `ParcelableHolder: Send \u003d\u003e Mutex\u003cParcelableHolderData\u003e: Send + Sync`.",
      "parentUuid": "51c54e63_a7f99674",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a1a3afe3_3b8d5fcd",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1611820
      },
      "writtenOn": "2023-06-14T16:34:37Z",
      "side": 1,
      "message": "Circling back the the requirements. If we have \n\n\u0027\u0027\u0027\nlet mut a: SomeParcelable \u003d SomeParcelable::new();\nlet b \u003d a.clone();\n```\n\nIf I mutate the ParcelableHolder in `a`; should `b` see the same change?",
      "parentUuid": "02a850a7_ad43f8aa",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a3ea97ef_24c42933",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2023-06-15T00:36:38Z",
      "side": 1,
      "message": "I don\u0027t think so. clone is a deep copy.",
      "parentUuid": "a1a3afe3_3b8d5fcd",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "22bdcf74_8fb2f920",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1611820
      },
      "writtenOn": "2023-06-15T18:24:45Z",
      "side": 1,
      "message": "Then `data: Arc\u003cMutex\u003cParcelableHolderData\u003e\u003e` could change to just `data: ParcelableHolderData` because ParcelableHolderData has the Clone trait, too.\n \nIf this looks good to everyone I can update this CL.",
      "parentUuid": "a3ea97ef_24c42933",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a028d11_9abfdf36",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-06-15T18:34:23Z",
      "side": 1,
      "message": "You need the `Mutex` to provide thread-safe interior mutability for the `data` field, otherwise `get_parcelable` will need to be switched to `\u0026mut self` since it internally changes `data`.\n\nI think it would be preferable we didn\u0027t change the API like that, especially since the C++ `getParcelable` counterpart is also `const`.\n\nIMHO if the goal is to implement a deep copy, the best way would be to implement `Clone` manually.",
      "parentUuid": "22bdcf74_8fb2f920",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa244996_a77dd493",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1611820
      },
      "writtenOn": "2023-06-15T19:45:59Z",
      "side": 1,
      "message": "I\u0027m still trying to understand the difference between the Rust and C++ implementations. The need of thread-safe interior mutability is not super clear to me. But I trust your decision since apparently you have more contexts. \n\nAndrei would you mind creating a separate CL that manually implements the Clone trait? Not in a hurry and it\u0027d be great if we can have it before the end of this month. Then we\u0027ll cherry-pick your change to our `udc-swcar-dev` branch.",
      "parentUuid": "3a028d11_9abfdf36",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ec760ba_89e7de2b",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-06-15T20:34:10Z",
      "side": 1,
      "message": "The two implementations are actually not that different. The C++ version does:\n```\n    mutable std::shared_ptr\u003cParcelable\u003e mParcelable;\n    mutable std::optional\u003cString16\u003e mParcelableName;\n    mutable std::unique_ptr\u003cParcel\u003e mParcelPtr;\n    status_t getParcelable(std::shared_ptr\u003cT\u003e* ret) const {\n        // Modify the mutable fields here\n    }\n```\n\nThe issue here is writing to the `mutable` fields from a `const` method. Rust doesn\u0027t support this directly, but you can always do it with \"interior mutability\" (`RefCell` and `Mutex`). The Rust code initially used `RefCell`, then changed to `Mutex` later (see https://r.android.com/1855900).",
      "parentUuid": "aa244996_a77dd493",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "396ec9f7_25e00e72",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1611820
      },
      "writtenOn": "2023-06-15T21:51:30Z",
      "side": 1,
      "message": "Thanks for clarifying! I just uploaded the update and ptal.",
      "parentUuid": "2ec760ba_89e7de2b",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}