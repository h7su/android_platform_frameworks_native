{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d5b07b81_fdea0bd4",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-06-13T19:45:55Z",
      "side": 1,
      "message": "Should we copy the underlying data (Parcel or Arc\u003cParcelable\u003e), like NDK/C++ backends do? Since this is behind a mutex, it seems difficult to prove code doesn\u0027t mutate ParcelableHolderData in a way that would break other ParcelableHolder objects pointing to the same data.\n\nIf we don\u0027t need a real copy of ParcelableHolder, could other code use Arc\u003cParcelableHolder\u003e?",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dd8032ad_c53a0bce",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1611820
      },
      "writtenOn": "2023-06-13T19:58:23Z",
      "side": 1,
      "message": "I\u0027d prefer copying the underlying data; but I\u0027ll defer to Andrei who understands the Rust ParcelableHolder better.",
      "parentUuid": "d5b07b81_fdea0bd4",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55144df5_d49fba8a",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1611820
      },
      "writtenOn": "2023-06-13T20:01:22Z",
      "side": 1,
      "message": "Looks like the C++ backend use a std::shared_ptr(). \n\nhttps://source.corp.google.com/h/googleplex-android/platform/superproject/+/master:frameworks/native/libs/binder/include/binder/ParcelableHolder.h;l\u003d139",
      "parentUuid": "dd8032ad_c53a0bce",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e07337fd_d58ccb73",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-06-13T20:42:43Z",
      "side": 1,
      "message": "The NDK backend copies the parcelable (AParcelableHolder). Java doesn\u0027t. Thoughts Jiyong/Jeongik?",
      "parentUuid": "55144df5_d49fba8a",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a6c642a_2a5b258c",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-06-13T23:16:29Z",
      "side": 1,
      "message": "`ParcelableHolderData` implements `Clone` and `ParcelableHolder` used to derive it too. It got removed when we switched from `RefCell` to `Mutex` for thread-safety.\n\nAdding `Arc` is one approach, another would be to manually implement `Clone` and create a new `Mutex`:\n```\nimpl Clone for ParcelableHolder {\n  fn clone(\u0026self) -\u003e ParcelableHolder {\n    ParcelableHolder {\n      data: Mutex::new(self.data.lock().unwrap().clone()),\n      stability: self.stability,\n  }\n}\n```\n\nI\u0027m not sure which one is preferable, the `Arc` approach adds an extra level of indirection but shares the data between copies, which is mainly relevant for the `ParcelableHolderData::Parcel` case. `Parcel::clone` is a deep copy, so this circles back to the original question: do we want `ParcelableHolder::clone` to do that or not? I don\u0027t have a strong opinion here.",
      "parentUuid": "e07337fd_d58ccb73",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b86302b9_00dd1377",
        "filename": "libs/binder/rust/src/parcel/parcelable_holder.rs",
        "patchSetId": 2
      },
      "lineNbr": 70,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2023-06-13T23:58:10Z",
      "side": 1,
      "message": "I\u0027d prefer cloning the enclosed Parcelable. When cloning ParcelableHolder, cloning the enclosed one must be the usual expectation.",
      "parentUuid": "3a6c642a_2a5b258c",
      "range": {
        "startLine": 70,
        "startChar": 20,
        "endLine": 70,
        "endChar": 40
      },
      "revId": "40a837e6f45151c28a4765e02665078ef7c15742",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}