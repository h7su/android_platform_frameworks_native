{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "90909c44_02872f20",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1211,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-13T17:43:30Z",
      "side": 1,
      "message": "I think this is what it should be but it\u0027s not what it currently is. As in, shouldn\u0027t parcel being rejecting attempts to grow beyond this size? But right now it\u0027s just an otherwise ignored constant.",
      "range": {
        "startLine": 1211,
        "startChar": 15,
        "endLine": 1211,
        "endChar": 48
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85038d19_ee26ab1d",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1211,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-07-13T18:44:32Z",
      "side": 1,
      "message": "\"An upper bound for the maximum amount of data that could be safely parceled in a response Parcel.\n\nThis is intended to be used to cap allocation sizes for structures returned in Parcels in conjunction with this one.\"",
      "parentUuid": "90909c44_02872f20",
      "range": {
        "startLine": 1211,
        "startChar": 15,
        "endLine": 1211,
        "endChar": 48
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5d545f9a_dcb2529d",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1211,
      "author": {
        "id": 1944405
      },
      "writtenOn": "2022-07-13T18:57:49Z",
      "side": 1,
      "message": "For getAllocationLimit, I\u0027d think it would return the allocation limit for the parcel, but not evaluate the parcel size against the allocation limit.\n\nWhat you\u0027re describing from what I understand falls more in line with the function that was previously written, however best described as AParcel_readParcelAllocationSizeWithCheck?\n\nThis current API would return the parcel\u0027s defined getAllocationLimit.\n\n----\nSteven - `with this one.` I\u0027m not sure I get this part.",
      "parentUuid": "90909c44_02872f20",
      "range": {
        "startLine": 1211,
        "startChar": 15,
        "endLine": 1211,
        "endChar": 48
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "278a4116_c472c213",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-13T17:43:30Z",
      "side": 1,
      "message": "should there be a setter for this so clients can set an appropriate limit?",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e6dabd61_48f78b19",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-13T17:43:30Z",
      "side": 1,
      "message": "size_t maybe?",
      "range": {
        "startLine": 1217,
        "startChar": 0,
        "endLine": 1217,
        "endChar": 7
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0f36b276_aa2baef4",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-07-13T18:44:32Z",
      "side": 1,
      "message": "No - the semantics are related to how the Parcel is used internally. I think it should be more clear after an updated comment.",
      "parentUuid": "278a4116_c472c213",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5a0bbab7_9f0b917c",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-13T18:50:12Z",
      "side": 1,
      "message": "Parcel has marshall/unmarshall APIs, though, a client could conceivably want their own limit for their own IPC purposes. It\u0027d also make testing easier, but if the API doesn\u0027t actually _do_ anything then I guess there\u0027s not much to test. I was imagining that Parcel would actually restrict itself to the specified size, though, which seems like a more broadly useful ability to limit.",
      "parentUuid": "0f36b276_aa2baef4",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a2a7d6a1_eda8ea96",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1944405
      },
      "writtenOn": "2022-07-13T18:57:49Z",
      "side": 1,
      "message": "pushing in PS8. Will mark is done then.",
      "parentUuid": "e6dabd61_48f78b19",
      "range": {
        "startLine": 1217,
        "startChar": 0,
        "endLine": 1217,
        "endChar": 7
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "38db759e_afc7de3a",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1944405
      },
      "writtenOn": "2022-07-13T18:57:49Z",
      "side": 1,
      "message": "Modifying getAllocationLimit in Parcel.h to only be a function declaration. \n\nParcel.cpp will implement getAllocationLimit to return 1M.\nI think this change would solve the issue you are describing. Implementing getAllocationLimit would then allow to set different sizes. \nWe can discuss this once I push the PS?",
      "parentUuid": "278a4116_c472c213",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "ee475007_c0977c82",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1944405
      },
      "writtenOn": "2022-07-13T21:30:21Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "a2a7d6a1_eda8ea96",
      "range": {
        "startLine": 1217,
        "startChar": 0,
        "endLine": 1217,
        "endChar": 7
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f39de7e8_d59aaaa3",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-07-13T23:39:03Z",
      "side": 1,
      "message": "No setter! :)\n\nThere is a specific behavior here needed (to prevent code from making allocations which are too big). We need an API to tell code how big of allocations are definitely a problem. Allocations at least of this size need to be let through because they might not result in a transaction failure. This value is determined approximately by the binder buffer size. However, there is some margin of error there because large allocations fail anyway with a high probability. Right now this value is specified inside and outside the NDK API surface. We would like to specify it one time inside the API surface so that is adjacent (and therefore updatable with, as necessary, but not now) to the value it is coupled to (the binder VM size).\n\nWe originally suggested doing this beneath the specific semantics of resizing a vector. Now, it is suggested to export the exact value. Honestly, I do not care which way it is done between these two. Though, we are comfortable exposing the value, it has a specific semantic, and it may be useful in the future. So, it\u0027s okay.\n\n\u003e I was imagining that Parcel would actually restrict itself to the specified size\n\nThis is unrelated to the behavior that is needed or the requirement here, and it reflects a miscommunication between the name I suggested (\"allocation limit\") and other possible interpretations of it. Any time spent further down this line is unrelated to this issue. If such a feature was needed for another reason, we could implement it (not unreasonable, only irrelevant).\n\nI now suggest distinguishing the name to approach the relevant semantic:\n\n    /** The absolute maximum size a Parcel could be and succeed when sent in a transaction, even if it is unreasonable to send Parcels of this size. This can be used to limit writes to the Parcel. Rather than allocating or making a write of this size, it is always safe to consider a transaction containing this amount of data to fail without trying to send it. */\n    size_t AParcel_getTransactionSizeHardLimit(...)",
      "parentUuid": "38db759e_afc7de3a",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0eb760b8_6c2790a4",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-07-14T00:21:04Z",
      "side": 1,
      "message": "\u003e Allocations at least of this size need to be let through because they might not result in a transaction failure.\n\n**Allocations below this size need to be let through because they might not result in a transaction failure.",
      "parentUuid": "f39de7e8_d59aaaa3",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d0b7fea2_d9052fd7",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-14T14:40:44Z",
      "side": 1,
      "message": "Well if this is going to be narrowly restricted to specifically the binder limit \u0026 only that limit with no actual AParcel behaviors whatsoever, then it should go on AIBinder.\n\nIf it\u0027s going on AParcel it should be usable in non-binder contexts, since AParcel is also usable in non-binder contexts (thanks to marshall/unmarshall in particular). That would mean setters for non-binder users to also benefit, and (ideally) actual growth restrictions on the parcel. Yes that\u0027s a broader scope than the narrow context of the bug, but AParcel is a broader API than the narrow scope of the bug.\n\nSo if you want narrow, put it on the narrow thing (so AIBinder_getTransactionSizeHardLimit). If you want broad in more-than-one-context, then it needs to support doing that. Which means doing more than the bare minimum of the bug.",
      "parentUuid": "0eb760b8_6c2790a4",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d8322e29_317838ff",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-07-14T16:46:34Z",
      "side": 1,
      "message": "The issue between AIBinder and AParcel was discussed over chat but lost in history. The reason we focused on an AParcel API is that there is no guarantee of having an AIBinder in the context (the C++ API AParcel_resize(Out)Vector) where this is needed. Parcels may or may not have an AIBinder associated with them. In some cases, if markForRpc is called, we only have the RpcSession, no longer the specific binder.\n\nThis limit makes sense for any user of Parcel. Having a limit is definitely needed for any unparceling to avoid OOM conditions, and 1MB (or 2MB or 10MB - it really is quite arbitrary since it\u0027s only catching an extreme condition) is a perfectly fine limit. If a higher limit is needed elsewhere, we can add it. However, this C++ API (resizeOutVector) is used in unparceling C++ out vectors, and context-independent (though any other user is unexpected) this needs a limit, and 1MB is reasonable for that (if you don\u0027t think so, please provide a counterexample).",
      "parentUuid": "d0b7fea2_d9052fd7",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ea77df75_ab56ec29",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-14T17:40:05Z",
      "side": 1,
      "message": "\u003e The reason we focused on an AParcel API is that there is no guarantee of having an AIBinder in the context\n\nI think maybe there\u0027s some more communication breakdown going on here. I was suggesting:\n\n`size_t AIBinder_getTransactionSizeHardLimit()`\n\nThere\u0027s no need to have an actual AIBinder instance of anything. Since part of the stated goal here is for AIDL to always work as if it has binder\u0027s IPC limits, this being a global \u0026 not a per-instance seems like it still achieves the goal?\n\n\u003e This limit makes sense for any user of Parcel.\n\nNo it doesn\u0027t. If my transport isn\u0027t binder, I can have a different limit. That\u0027s perfectly reasonable. Things bigger than 1MB are sent over IPC/sockets all the time, after all. It\u0027s definitely not an inherently reasonable reply length for all backends of all types. Parcel is documented to be limited to IPC, but it\u0027s not limited to Binder. People have used, and will continue to use, marshall/unmarshall specifically to get around the 1MB limit (see last years discussion on the matter about exposing AParcel_marshal at all in the first place)",
      "parentUuid": "d8322e29_317838ff",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d8deeac4_a58ec93a",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-07-14T21:54:33Z",
      "side": 1,
      "message": "\u003e There\u0027s no need to have an actual AIBinder instance of anything.\n\nIf we wanted a separate limit for RpcSession vs kernel binder, we could make it contingent on the specific context.\n\n\u003e People have used, and will continue to use, marshall/unmarshall specifically to get around the 1MB limit\n\nThis wouldn\u0027t be with the resizeOutVector API. This is really specific to usage of a Parcel with IPC, and it is the only place we would want to use this.",
      "parentUuid": "ea77df75_ab56ec29",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "56b9db48_71bca0cd",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-14T22:04:28Z",
      "side": 1,
      "message": "\u003e If we wanted a separate limit for RpcSession vs kernel binder, we could make it contingent on the specific context.\n\nBut you just said there shouldn\u0027t be a setter, so it can\u0027t be context-specific?",
      "parentUuid": "d8deeac4_a58ec93a",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8937ea82_6ff2b08d",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-07-15T17:50:34Z",
      "side": 1,
      "message": "Take for instance the memory available on a machine. You can get the amount of RAM available, and it is context specific, but you can\u0027t set it. You can construct a new virtual machine that has a specific amount of memory, but this is somewhat separate (and unrelated to getting the memory in a given context).\n\nIn libbinder_ndk, the context (ABinderProcess - actually ProcessState) is setup at process start and is global. The alternative context, RpcSession/RpcState, is not exposed currently, though AIBinder/AParcel may be backed with this.",
      "parentUuid": "56b9db48_71bca0cd",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "85656410_b2898f94",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2022-07-15T19:07:25Z",
      "side": 1,
      "message": "But, again, (A)Parcel can be used with arbitrary IPC backends with arbitrary limits thanks to the existence of marshall/unmarshall. This limit is really specific to Binder semantics. So what\u0027s the issue with an `size_t AIBinder_getTransactionLimit()` ?\n\nA limit on Parcel would be like an rlimit on RAM - it should default to max, with setters to lower it, and lowering it should do something :)",
      "parentUuid": "8937ea82_6ff2b08d",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fbe01cbf_8099ea96",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 7
      },
      "lineNbr": 1217,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-07-15T19:26:23Z",
      "side": 1,
      "message": "John - please unblock, otherwise I suggest Elie abandon this issue. This is a simple issue, and it is not worth this amount of discussion. It\u0027s a duplicated value from a security fix, and the goal is to clean it up in a future-proof way so that we don\u0027t have all these compiled applications copying the value. If we need to live with that until there is a problem, it\u0027s not a great design, but I\u0027m tired of arguing with you here.\n\n\u003e A)Parcel can be used with arbitrary IPC backends with arbitrary limits thanks to the existence of marshall/unmarshall\n\nThose users don\u0027t need to use this limit or the \u0027resizeOutArray\u0027 API. This is another reason to go back to PS1, because that API is specific to the context of doing a transaction, and it wouldn\u0027t make sense to mix in with marshall.\n\n\u003e This limit is really specific to Binder semantics.\n\nSo is AParcel_writeStrongBinder. It doesn\u0027t matter. This is binder Parcel.\n\n\u003e So what\u0027s the issue with an `size_t AIBinder_getTransactionLimit()`?\n\nif static - because this isn\u0027t a static limit\n\nif not-static - because it wouldn\u0027t solve the bug without exposing/tracking more information (we would need to factor out a TransactionLimitContext - we really don\u0027t want to expose more here)\n\n\u003e A limit on Parcel would be like an rlimit on RAM - it should default to max, with setters to lower it, and lowering it should do something :)\n\nI thought you might mention rlimit. :) My example was to show that the retrieval of a value does not imply the need to set it only. rlimit is inherited when forking so that it doesn\u0027t affect total memory usage. It\u0027s close to what you are asking, but it\u0027s fundamentally different than the total machine limit. Don\u0027t worry, I get what you\u0027re asking with the setter. It could make sense to have a limit for Parcel sizes that is configurable. However, that\u0027s not what this bug is, and generally we don\u0027t want people messing with this.",
      "parentUuid": "85656410_b2898f94",
      "range": {
        "startLine": 1217,
        "startChar": 8,
        "endLine": 1217,
        "endChar": 34
      },
      "revId": "f40f3340ea7ed02ea997494ee83788baa609a3e7",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}