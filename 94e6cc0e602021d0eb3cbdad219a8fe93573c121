{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "84031d6c_4b076de0",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-12-09T23:32:28Z",
      "side": 1,
      "message": "Do we need to do this? This would be a backwards compatible change for libbinder_ndk, right?\n\nAlso - I\u0027m surprised, it did not break any tests? Are we missing tests for this case?",
      "revId": "94e6cc0e602021d0eb3cbdad219a8fe93573c121",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f689815a_88150878",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-12-09T23:44:52Z",
      "side": 1,
      "message": "Hmm, I think this makes NDK backend work like CPP backend regarding null handling.\nhttps://android-review.googlesource.com/c/platform/cts/+/1900957 is the missing test.",
      "parentUuid": "84031d6c_4b076de0",
      "revId": "94e6cc0e602021d0eb3cbdad219a8fe93573c121",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0ced028_dd6787a1",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-12-09T23:55:06Z",
      "side": 1,
      "message": "Instead of changing AParcel_readParcelable, which is used by other things, we should switch the compiler to uing AParcelable_readNullableParcelable for IBinder/interfaces, right?\n\n(and maybe add a test that MyFooParcelable[] without @nullable returns the expected error when a null parcelable is sent from Java)",
      "parentUuid": "f689815a_88150878",
      "revId": "94e6cc0e602021d0eb3cbdad219a8fe93573c121",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "019cee65_65bffae6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-12-10T07:30:15Z",
      "side": 1,
      "message": "\u003e Instead of changing AParcel_readParcelable, which is used by other things, we should switch the compiler to uing AParcelable_readNullableParcelable for IBinder/interfaces, right?\n\nI thought that way, but figured out it makes things more complicated when handling vectors of interfaces. And since there\u0027s a guard to check if it\u0027s \"interface\" using AParcel_readParcelable seems to be okay.",
      "parentUuid": "c0ced028_dd6787a1",
      "revId": "94e6cc0e602021d0eb3cbdad219a8fe93573c121",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4efc59f5_7ea2a515",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-12-10T23:11:01Z",
      "side": 1,
      "message": "Sure, it may be more complicated, but this is backwards incompatible, no?",
      "parentUuid": "019cee65_65bffae6",
      "revId": "94e6cc0e602021d0eb3cbdad219a8fe93573c121",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "298702ef_c1564372",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-12-11T01:04:33Z",
      "side": 1,
      "message": "No, this is backward compatible. In fact, the problem was introduced when interface[] support was added. It should have been fixed then.\n\nI just found this was missing when working with the follow-up change (aosp/1900580). \n\nThe problem is.\n* When sending an interface, interface::writeToParcel is used and null is okay regardless of nullability.\n* When sending an interface[], AParcel_writeVector() is used, which calls AParcel_writeParcelable for each interface. Now, AParcel_writeParcelable should just call interface::writeToParcel. But when I implemented it, I did a mistake by adding a nullcheck there.",
      "parentUuid": "4efc59f5_7ea2a515",
      "revId": "94e6cc0e602021d0eb3cbdad219a8fe93573c121",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "23f48611_df98b995",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1415877
      },
      "writtenOn": "2021-12-13T00:50:48Z",
      "side": 1,
      "message": "Oh, btw, given that we\u0027ll have new entry functions(readData/writeData) in the following CL, we can make writeParcelable() work with only parcelables and move interface-related code(interface::writeToParcel) to writeData()\u0027s interface-type branch. writeVector\u003cP\u003e() should be modified together (element_writer(AParcel_writeStdVectorParcelableElement) should call writeData() instead of writeParcelable() so that writeVector\u003cP\u003e() can work with writeData()-able types.)\n\nThis fixes the mistake of aosp/1878148 and refactoring(described above) might be a separate change on top of aosp/1900580.",
      "parentUuid": "298702ef_c1564372",
      "revId": "94e6cc0e602021d0eb3cbdad219a8fe93573c121",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "97a5f61b_e12892c2",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-12-13T19:14:23Z",
      "side": 1,
      "message": "Jooyung, sorry for the delay, you are right!\n\nI missed this was in the \u0027if constexpr (is_interface_v\u003cP\u003e)\u0027 branch.",
      "parentUuid": "23f48611_df98b995",
      "revId": "94e6cc0e602021d0eb3cbdad219a8fe93573c121",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}