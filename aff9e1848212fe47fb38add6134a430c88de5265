{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "8d19b712_17a87fb5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-04-18T19:42:56Z",
      "side": 1,
      "message": "where is this test? Do we have a way to test this in upstream Android? Can binderLibTest be modified or can the tests there be reused?",
      "range": {
        "startLine": 12,
        "startChar": 6,
        "endLine": 12,
        "endChar": 24
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8fbc3e46_30828741",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 12,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-18T22:15:30Z",
      "side": 1,
      "message": "The test lives under system/core/trusty in the CL at https://android-review.googlesource.com/c/platform/system/core/+/2045930. I could move it to the binder directory if that would be useful.\n\nThere are a few complications: one is that the test is a client that requires a service on the Trusty side (CL at https://android-review.googlesource.com/c/trusty/app/sample/+/1932245).\n\nThe second is that Trusty doesn\u0027t run under Cuttlefish, but on an arm64 qemu built for Trusty which runs a specific AOSP build (lunch qemu_trusty_arm64-userdebug). I\u0027ve been running the test manually, still have to figure it out how to automate that since atest doesn\u0027t run on the Trusty build.",
      "parentUuid": "8d19b712_17a87fb5",
      "range": {
        "startLine": 12,
        "startChar": 6,
        "endLine": 12,
        "endChar": 24
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76e84bec_0339e9fb",
        "filename": "libs/binder/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 272,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-04-18T19:42:56Z",
      "side": 1,
      "message": "nit: do we need this if it\u0027s only used once?",
      "range": {
        "startLine": 272,
        "startChar": 0,
        "endLine": 272,
        "endChar": 38
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0e2edc5a_5dd798c4",
        "filename": "libs/binder/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 272,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-18T22:37:03Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "76e84bec_0339e9fb",
      "range": {
        "startLine": 272,
        "startChar": 0,
        "endLine": 272,
        "endChar": 38
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fe04403c_b43b60b3",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-04-18T19:42:56Z",
      "side": 1,
      "message": "nit: should we use this same logic in RpcTransportRaw? Seems we use a different way of handling it there",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d8ade1c_c6e8b56c",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-18T22:26:18Z",
      "side": 1,
      "message": "There are a few significant differences in this code, mainly because tipc works like a message-oriented transport (the closest thing in Linux sockets would be SOCK_SEQPACKET, but the tipc file is not a socket):\n* tipc doesn\u0027t support reading a message with multiple reads, every message needs to be read with a single call. For this reason, I split messages at the sender and transmit each iovec as a separate message (assuming that the receiver won\u0027t attempt to read a message partially).\n* The receiver can read multiple messages with one interruptableReadFully call, but assumes that an iovec doesn\u0027t end in the middle of a message (or vice versa).\n\nThe simplest way to handle this is here in the RPC transport, but there are other alternatives that we can discuss.",
      "parentUuid": "fe04403c_b43b60b3",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f99a6088_7398c3e9",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-18T22:55:55Z",
      "side": 1,
      "message": "\u003e assumes that an iovec doesn\u0027t end in the middle of a message (or vice versa)\n\nCorrection: this only goes in one direction. An iovec can receive multiple messages, but a message can\u0027t be split across multiple iovecs because the latter would require multiple read() calls per message.",
      "parentUuid": "2d8ade1c_c6e8b56c",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0e985c6e_f505ceff",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-20T00:06:46Z",
      "side": 1,
      "message": "Would it make more sense to merge this with the other implementation but with an additional `bool splitIovecs` argument that controls whether it does one send per iov?",
      "parentUuid": "f99a6088_7398c3e9",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2ce6e47c_e7bc3d69",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-20T01:29:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "0e985c6e_f505ceff",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a44f3fee_c5989c16",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-04-21T01:55:41Z",
      "side": 1,
      "message": "Ah, I missed this detail. If we are doing one send per-iovec b/c this isn\u0027t a stream socket, it means that this adds the constraint on the existing clients that we can\u0027t split existing calls into multiple io_vecs right? It still adds a constraint on the io_vecs themselves? Is there a way we can add this without this requirement?",
      "parentUuid": "2ce6e47c_e7bc3d69",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f7fd1d86_563acbb5",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-21T20:00:50Z",
      "side": 1,
      "message": "\u003e we can\u0027t split existing calls into multiple io_vecs right? It still adds a constraint on the io_vecs themselves?\n\nThat\u0027s right, the iovecs have to be symmetric between senders and receivers, which is true right now.\n\n\u003e Is there a way we can add this without this requirement?\n\nOne thing we could do is try to emulate streams by buffering messages at the receiver, but that would increase memory usage. If e.g. we sent all 2-3 iovecs as one message, we could save that data on the other end until libbinder makes enough calls to read all of it. I think that would increase the complexity of the RPC transport code though (at least both instances of RpcTransportTrusty), but it\u0027s doable.",
      "parentUuid": "a44f3fee_c5989c16",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b0aad192_46253181",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-04-21T20:58:19Z",
      "side": 1,
      "message": "IIUC, the iovecs don\u0027t need to be symmetric atm. In one of the common cases with the current code, you are going to have a send with {header, command, data} and then, on the other side, a recv for {header} followed by a recv for {command, data}.\n\nMy instinct is that you either need to buffer in the transport so that the messages look like a stream or change the contract of the transport class to be message oriented so that callers are forced to make the same # of send and recv calls.",
      "parentUuid": "f7fd1d86_563acbb5",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78e7359a_8bbf2882",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-04-21T21:07:47Z",
      "side": 1,
      "message": "Oh, I see what you mean about the iovecs. If we force them to stay symmetric, then it is effectively making the interface message oriented. I\u0027m just using different words for the same ideas.",
      "parentUuid": "b0aad192_46253181",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ceeed41f_0ac3effd",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-05-24T00:14:13Z",
      "side": 1,
      "message": "So, as part of adding FD support, I need to add an equivalent of mObjects to the wire protocol. The likely implementation for that (WIP in https://r.android.com/2082679) is going to make the iovecs asymmetric. The write side will have the parcel data and object offsets in separate buffers, but the receive side will pull them both into one buffer. I\u0027m not sure if there is an alternative solution that is performant (at least without completely rethinking how we manage read buffers).\n\nHow bad do you think buffered reads would be? Alternatively, is within the realm of possibility to support multiple iovecs for Trusty IPC reads?",
      "parentUuid": "78e7359a_8bbf2882",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6d0509f0_0f8209da",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-05-24T00:34:22Z",
      "side": 1,
      "message": "\u003e How bad do you think buffered reads would be? Alternatively, is within the realm of possibility to support multiple iovecs for Trusty IPC reads?\n\nAfter giving it some more thought, I think that could work. The Trusty side is actually easier, because the read API is split across 3 calls: `get_msg`, `put_msg`, and `read_msg`. The way it works is you \"accept\" a message with `get_msg` which also gives you the message length, then you can do an arbitrary number of reads at any offset with `read_msg` (until you \"close\" the message with `put_msg`). Trusty libbinder could basically keep a message active across multiple `interruptibleReadFully` calls. I used to do that in an earlier PS, got rid of it because the code was more complex but I can bring it back.\n\nThe other problem is on Android when receiving a message from Trusty. There the only API is `read()`, and that requires a buffer to store the message into. If the buffer is too small for the message, the syscall returns `EMSGSIZE` (without discarding the message). I guess we could always handle that code by increasing the buffer size until the read goes through, Android has a lot more memory than Trusty.",
      "parentUuid": "ceeed41f_0ac3effd",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "392c2df5_b2a4370b",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-06-07T20:50:37Z",
      "side": 1,
      "message": "This is probably irrelevant now, but in case it sheds weird light on behavior you might have seen: I noticed the iovecs are actually already asymmetric\n\n* sending a reply uses 1 iovec for the RpcWireReply and 1 iovec for the parcel data ([code](http://cs/android-internal/frameworks/native/libs/binder/RpcState.cpp;l\u003d522-523;rcl\u003dc3899122de2fd854fc553a770c878259c125a2ef))\n* recving a reply uses 1 iovec for both ([code](http://cs/android-internal/frameworks/native/libs/binder/RpcState.cpp;l\u003d591;rcl\u003dc3899122de2fd854fc553a770c878259c125a2ef))\n\n(noticed in https://r.android.com/2118587 where we are about to make this more symmetric, but only temporarily, before the main FD CL lands)",
      "parentUuid": "6d0509f0_0f8209da",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4874b573_d7924d01",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-06-07T20:52:19Z",
      "side": 1,
      "message": "(whoops, first code link should have been [code](http://cs/android-internal/frameworks/native/libs/binder/RpcState.cpp;l\u003d952-953;rcl\u003dc3899122de2fd854fc553a770c878259c125a2ef))",
      "parentUuid": "392c2df5_b2a4370b",
      "range": {
        "startLine": 87,
        "startChar": 0,
        "endLine": 89,
        "endChar": 13
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "adfe0502_bf75efa4",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 133,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-04-18T19:42:56Z",
      "side": 1,
      "message": "is this the only thing forked from the raw transport? I\u0027m wondering if you can move the interruptableReadOrWrite function into maybe a common header so that we can reuse the logic? (a lot seems duplicated - maybe I\u0027m missing another reason)",
      "range": {
        "startLine": 133,
        "startChar": 64,
        "endLine": 133,
        "endChar": 84
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "39fa4bba_3b37238c",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 133,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-18T22:26:18Z",
      "side": 1,
      "message": "There are a few differences, some discussed in the other comment. Another one is pollRead(). Sockets support MSG_PEEK but the TIPC device doesn\u0027t (it\u0027s basically a device file with some extra ioctl\u0027s).",
      "parentUuid": "adfe0502_bf75efa4",
      "range": {
        "startLine": 133,
        "startChar": 64,
        "endLine": 133,
        "endChar": 84
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "eb56b003_4754f044",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 133,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-20T00:22:00Z",
      "side": 1,
      "message": "Would we want to switch RpcTransportRaw::pollRead from MSG_PEEK to poll as well? I tried it a while ago and it worked, but there might be some subtle differences between the two approaches that I\u0027m not aware of and that the tests might not catch.",
      "parentUuid": "39fa4bba_3b37238c",
      "range": {
        "startLine": 133,
        "startChar": 64,
        "endLine": 133,
        "endChar": 84
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "90bd6169_1f268ec2",
        "filename": "libs/binder/RpcTransportTrusty.cpp",
        "patchSetId": 2
      },
      "lineNbr": 133,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-04-20T01:29:35Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "eb56b003_4754f044",
      "range": {
        "startLine": 133,
        "startChar": 64,
        "endLine": 133,
        "endChar": 84
      },
      "revId": "aff9e1848212fe47fb38add6134a430c88de5265",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}