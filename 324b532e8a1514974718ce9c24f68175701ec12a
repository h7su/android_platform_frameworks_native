{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "62e115e7_9261e79d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 14
      },
      "lineNbr": 14,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-10-31T21:42:17Z",
      "side": 1,
      "message": "Nit: the function is now called `downcast_binder`.",
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f645b04_d38f0728",
        "filename": "/COMMIT_MSG",
        "patchSetId": 14
      },
      "lineNbr": 14,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2023-11-01T01:18:44Z",
      "side": 1,
      "message": "don\u0027t use `unwrap` in the commit message, someone will probably copy-paste it",
      "range": {
        "startLine": 14,
        "startChar": 45,
        "endLine": 14,
        "endChar": 54
      },
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2e33bb6d_78d6f698",
        "filename": "/COMMIT_MSG",
        "patchSetId": 14
      },
      "lineNbr": 14,
      "author": {
        "id": 1942645
      },
      "writtenOn": "2023-11-01T16:26:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "2f645b04_d38f0728",
      "range": {
        "startLine": 14,
        "startChar": 45,
        "endLine": 14,
        "endChar": 54
      },
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "40dff195_abc6282a",
        "filename": "/COMMIT_MSG",
        "patchSetId": 14
      },
      "lineNbr": 14,
      "author": {
        "id": 1942645
      },
      "writtenOn": "2023-11-01T16:26:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "62e115e7_9261e79d",
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c885456f_f5efd369",
        "filename": "libs/binder/rust/src/binder.rs",
        "patchSetId": 14
      },
      "lineNbr": 900,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2023-11-01T01:18:00Z",
      "side": 1,
      "message": "maybe we should add a note here about when it is appropriate to use this (i.e. when the binder comes from the kernel as mentioned in https://android-review.git.corp.google.com/c/platform/system/tools/aidl/+/2813799/comments/1bac12ba_1f0618c1)\n\nalso should warn people to never use `unwrap`/`expect`/etc on this if the object comes from a binder call (it would be an easy DOS attack)",
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "84af3b32_2607b4fb",
        "filename": "libs/binder/rust/src/binder.rs",
        "patchSetId": 14
      },
      "lineNbr": 900,
      "author": {
        "id": 1942645
      },
      "writtenOn": "2023-11-01T16:26:00Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "c885456f_f5efd369",
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "89ffa47e_055be0e5",
        "filename": "libs/binder/rust/src/binder.rs",
        "patchSetId": 14
      },
      "lineNbr": 902,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-01T00:34:13Z",
      "side": 1,
      "message": "so, I\u0027m not very familiar with this or the above macro. This is using state at the Rust layer to make sure it\u0027s the same object type?\n\nWe could theoretically do it without any additional state, by checking AIBinder_Class equality, and then checking AIBinder_getUserData equality, which would determine if it\u0027s the same object. However, I\u0027m not sure how messy that would be to implement.",
      "range": {
        "startLine": 902,
        "startChar": 32,
        "endLine": 902,
        "endChar": 44
      },
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "55ad6bb9_e468c04d",
        "filename": "libs/binder/rust/src/binder.rs",
        "patchSetId": 14
      },
      "lineNbr": 902,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-11-01T00:51:40Z",
      "side": 1,
      "message": "\u003e checking AIBinder_getUserData equality, which would determine if it\u0027s the same object.\n\nJust to clarify: what we store in `userData` for Rust is a `*mut Box\u003cT\u003e` here, i.e., a double indirection returned by a `Box\u003cBox\u003cT\u003e\u003e::into_raw()`. I think comparing the pointers should still work because we never move that inner `Box` out.\n\n\u003e how messy that would be to implement\n\nWe\u0027re trying to avoid using `unsafe`, but that\u0027s not a hard requirement.",
      "parentUuid": "89ffa47e_055be0e5",
      "range": {
        "startLine": 902,
        "startChar": 32,
        "endLine": 902,
        "endChar": 44
      },
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ff5e540d_808d0b6e",
        "filename": "libs/binder/rust/src/binder.rs",
        "patchSetId": 14
      },
      "lineNbr": 902,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-01T01:08:27Z",
      "side": 1,
      "message": "I think you might as well assert the classes are the same, even if you go this route, but I\u0027m okay with it, yeah.\n\n\u003e we never move that inner Box out.\n\nIt\u0027s important that you don\u0027t, since the kernel driver keeps a pointer to this structure, and it\u0027s expected to identify this structure. If it was possible to move out, then the kernel would fail to be able to identify a binder.\n\nBtw - Box\u003cBox\u003c..\u003e\u003e is a lot of boxes. Do we need so many heap allocations?",
      "parentUuid": "55ad6bb9_e468c04d",
      "range": {
        "startLine": 902,
        "startChar": 32,
        "endLine": 902,
        "endChar": 44
      },
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fc7ec79a_091c61d2",
        "filename": "libs/binder/rust/src/binder.rs",
        "patchSetId": 14
      },
      "lineNbr": 902,
      "author": {
        "id": 1942645
      },
      "writtenOn": "2023-11-01T16:26:00Z",
      "side": 1,
      "message": "smoreland@: Thanks! If the way I am intending this function to be used already needs to go through the `TryFrom\u003cSpIBinder\u003e` code which does this class check, do we need to also do the check again on this function? I added a comment with the sequence of calls, which is basically:\n\n```\nlet binder \u003d received_object.as_binder();\nif !binder.is_remote() {\n    let binder_native: Binder\u003cBnFoo\u003e \u003d binder.try_into()?;\n    let original_object \u003d binder_native.downcast_binder::\u003cMyFoo\u003e();\n    // Check that returned type is not None before using it\n}\n```",
      "parentUuid": "ff5e540d_808d0b6e",
      "range": {
        "startLine": 902,
        "startChar": 32,
        "endLine": 902,
        "endChar": 44
      },
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "91b5d7e2_1b9c0968",
        "filename": "libs/binder/rust/src/binder.rs",
        "patchSetId": 14
      },
      "lineNbr": 902,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-03T01:31:19Z",
      "side": 1,
      "message": "I want to confirm, Rust is confirming the type, right? Or is the client making the assumption that any local instance of MyFoo is BnFoo?",
      "parentUuid": "fc7ec79a_091c61d2",
      "range": {
        "startLine": 902,
        "startChar": 32,
        "endLine": 902,
        "endChar": 44
      },
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "291f0189_5545ef60",
        "filename": "libs/binder/rust/src/binder.rs",
        "patchSetId": 14
      },
      "lineNbr": 902,
      "author": {
        "id": 1942645
      },
      "writtenOn": "2023-11-03T16:11:16Z",
      "side": 1,
      "message": "I am not sure I fully follow the question. While the user of the API assumes (hopes?) that it is possible to cast a local instance of `BnFoo` into `MyFoo` (the other direction is not implemented because `downcast_binder` is part of `BnFoo`), you get back an `Option`, so if the type stored inside the `BnFoo` was not really a `MyFoo`, Rust will check that and return a `None`.\nBecause `MyFoo` implements `Interface`, its users will have now the option to call `as_any().downcast_ref::\u003cXXXXX\u003e()` on it, but if `XXXXX` is not `MyFoo` the cast will fail. Please let me know if this is not the info you were looking for.",
      "parentUuid": "91b5d7e2_1b9c0968",
      "range": {
        "startLine": 902,
        "startChar": 32,
        "endLine": 902,
        "endChar": 44
      },
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ce879418_8a229e4a",
        "filename": "libs/binder/rust/src/binder.rs",
        "patchSetId": 14
      },
      "lineNbr": 902,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-11-03T16:35:38Z",
      "side": 1,
      "message": "In the email thread we discussed this before, I was also talking about how you could compare binder pointers (of AIBinder_Class) to make sure the underlying types were the same. However, this appears to be implementing dynamic casting purely in Rust, which is also okay, and honestly might be simpler.",
      "parentUuid": "291f0189_5545ef60",
      "range": {
        "startLine": 902,
        "startChar": 32,
        "endLine": 902,
        "endChar": 44
      },
      "revId": "324b532e8a1514974718ce9c24f68175701ec12a",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}