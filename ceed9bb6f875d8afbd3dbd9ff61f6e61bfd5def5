{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "2baad4bb_1d282843",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 10,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-12-17T01:17:12Z",
      "side": 1,
      "message": "I noticed this, since in another CL, without this change, the device didn\u0027t boot:\nhttps://android-review.googlesource.com/c/platform/frameworks/native/+/1495200/24..25/libs/binder/Parcel.cpp#2565\n\nI\u0027m not sure if this was the particular reason for the failure, or it could be something else, but this level of initialization of the reply Parcel seems wise, even if it means some extra memory sets (assuming there is no opposition to that).",
      "range": {
        "startLine": 9,
        "startChar": 0,
        "endLine": 10,
        "endChar": 68
      },
      "revId": "ceed9bb6f875d8afbd3dbd9ff61f6e61bfd5def5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "bb8f5cd3_d0fb87ed",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2020-12-17T03:26:44Z",
      "side": 1,
      "message": "I don\u0027t fully understand this code. I just wonder why we have had freeDataNoInit() from the beginning. Was it just to save a few cycles because we know that some of the fields will be overwritten immediately after?",
      "revId": "ceed9bb6f875d8afbd3dbd9ff61f6e61bfd5def5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "be0f944c_5052be63",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-12-17T18:03:21Z",
      "side": 1,
      "message": "Yes, as far as I can tell. Though, hoping maco or ctate could comment/ack? (might fix restartWrite in the same CL as well)",
      "parentUuid": "bb8f5cd3_d0fb87ed",
      "revId": "ceed9bb6f875d8afbd3dbd9ff61f6e61bfd5def5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "07311622_e1289286",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-12-18T01:56:30Z",
      "side": 1,
      "message": "yeah - restartWrite avoids doing this in case it can get a realloc instead of clearing the memory. That gets a bit more complicated to refactor w/o performance loss, so I won\u0027t change it.",
      "parentUuid": "be0f944c_5052be63",
      "revId": "ceed9bb6f875d8afbd3dbd9ff61f6e61bfd5def5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6c16cce7_a3ccb8df",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2020-12-23T08:05:16Z",
      "side": 1,
      "message": "Yeah I think this was done just to optimize this particular pattern in IPCThreadState.cpp:\n\nParcel buffer;\nbuffer.ipcSetDataReference(\n      reinterpret_cast\u003cconst uint8_t*\u003e(tr.data.ptr.buffer),\n      ...\n               \nI\u0027m not sure whether those cycles are important, but we could have the best of both worlds - introduce a Parcel constructor that takes the setDataReference params for the case above, and then use this change for the other case where the Parcel is passed in by the caller?",
      "parentUuid": "07311622_e1289286",
      "revId": "ceed9bb6f875d8afbd3dbd9ff61f6e61bfd5def5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3973eba2_15e8ba41",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2020-12-23T08:14:53Z",
      "side": 1,
      "message": "(+2 in case this is blocking your work, I do think this change is correct)",
      "revId": "ceed9bb6f875d8afbd3dbd9ff61f6e61bfd5def5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7a496825_31d277dc",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-12-23T19:18:40Z",
      "side": 1,
      "message": "Yeah, I\u0027m really focusing on the other user of this function here. There are just a lot of things with libbinder that are subtly wrong, and I\u0027m not worried about performance for this (for performance, watching out for lock-takes + heap allocations, and we have binderAllocationLimits now).\n\nThis code is way too complex - and the number of bugs - many of which are serious - which have been discovered over the years are because of sprawling copy pasta special cases which is very prematurely optimized (e.g. libbinder would rather duplicate 30 LOC than remove a heap allocation in certain places). Over time, it\u0027s only gotten worse.\n\nPart of me is hoping this will fix some flakes/subtle issues in certain types of hand-rolled Parcel code.\n\nAs part of doing socket binder, we just can\u0027t have this complexity (and this change shaves off 4-5 LOC). So merging, thanks!",
      "parentUuid": "6c16cce7_a3ccb8df",
      "revId": "ceed9bb6f875d8afbd3dbd9ff61f6e61bfd5def5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}