{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "6a15b03e_b095dd57",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1809421
      },
      "writtenOn": "2021-04-13T17:09:38Z",
      "side": 1,
      "message": "This function must be called only on a local binder and before that binder has been sent to another process. It is also not thread safe, while our Strong\u003cdyn Interface\u003e currently would be.\n\nI think we should at least only implement this on Binder\u003c\u003e (a local binder object). However, that would prevent calling this method on local Binder objects created, e.g. in the C NDK outside of Rust. Is this ok?\n\nRegardless, this method should be unsafe if we\u0027re going to expose it arbitrarily as it is not thread-safe and we want the rest of the API to be thread-safe.",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d93d0aca_ae0ceb47",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-13T17:16:57Z",
      "side": 1,
      "message": "Do you have a specific suggestion for how to expose this?\n\n\u003e with_calling_sid\n\nI must have missed this in review, but this function doesn\u0027t work without this.\n\n    /// Implementations of `check_permission` should use the given CStr\n    /// argument as context for selinux permission checks. If `None` is\n    /// given, the implementation should fall back to using the PID\n    /// instead.\n\nThese docs also need updated. It\u0027s unsafe to rely on PID because of TOCTOU problems. They should also be amended to include information about calling set_requesting_sid. Can you also update this?\n\n\nBtw - I notice we could have caught all of this if the binder rust integration tests did use internal APIs like IBinderInternal. Is there any reason we have this dependency? or something else I\u0027m missing?",
      "parentUuid": "6a15b03e_b095dd57",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "78cc9380_cd69714d",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1809421
      },
      "writtenOn": "2021-04-13T20:47:31Z",
      "side": 1,
      "message": "I don\u0027t have a great suggestion on how to expose this, which is why I hadn\u0027t done it yet. We could make it a method on the local native::Binder\u003c\u003e object, and provide a method on Strong\u003c\u003e to retrieve the local binder. But that still only handles half of this. Ideally, instead I would like to do this during object creation, which would require adding a new interface in the AIDL generated code for creating a new service with setRequestingSid set.",
      "parentUuid": "d93d0aca_ae0ceb47",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1a42a992_ab54b0ac",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-13T20:54:26Z",
      "side": 1,
      "message": "so fwiw - this will be safe if it is called later from a memory management perspective (setting a bool), but it won\u0027t be read by anything. b/166282674 is filed in order to convert this \"do nothing\" case into an abort. Perhaps we can take this CL as-is?",
      "parentUuid": "78cc9380_cd69714d",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1be2b5d7_47b4ad3f",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1809421
      },
      "writtenOn": "2021-04-13T23:09:44Z",
      "side": 1,
      "message": "We can if you really want to, but I think the right place to put this is on the native Binder struct and call it during object construction. That\u0027s still a bit of a compromise, but then you can\u0027t easily misuse the API.",
      "parentUuid": "1a42a992_ab54b0ac",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95f4936f_8e1add75",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-13T23:26:30Z",
      "side": 1,
      "message": "In C++ (and in the C++ helper libraries associated with the NDK backend), the constructors would have to be piped through multiple different classes. Though also, C++ constructors aren\u0027t very explicit (we lose the tag \u0027setRequestingSid\u0027 - it would have to be, say, a type tag, which isn\u0027t very standard). We can\u0027t use static functions since subclasses really need to delegate to the parent class constructors. I\u0027m really at a loss for how to do it in a cleaner way here, and the problem isn\u0027t big: the mistake people usually make is calling this API after registering a service with service manager instead of before - an abort would always catch this. I\u0027ve really wanted to use the clang capabilities introduced for thread safety analysis to fix this kind of issue (have compiler enforce object state, without requiring any changes to the ABI). However, I haven\u0027t had a chance :(\n\nTypefulness (constructor or builder pattern here) would certainly make the problem go away. If there is an easy way to do it in the Rust layer, maybe you can share a little more detail? what do you mean by \u0027native Binder struct\u0027? I\u0027m all for fixing things here if we can.",
      "parentUuid": "1be2b5d7_47b4ad3f",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a4053206_cb8f7538",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1809421
      },
      "writtenOn": "2021-04-13T23:42:55Z",
      "side": 1,
      "message": "I was thinking of adding a sibling to https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/rust/src/binder.rs;l\u003d733?q\u003dnew_binder i.e. new_binder_requesting_sid() that calls binder.set_requesting_sid() implemented in https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/rust/src/native.rs;l\u003d51\n\nIt still requires the client to call the right constructor, but that\u0027s no worse than calling it after construction.",
      "parentUuid": "95f4936f_8e1add75",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "10ddacfa_5394af9c",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-13T23:52:50Z",
      "side": 1,
      "message": "We\u0027d also want stuff for setExtension, setMinSchedulerPolicy, and any other feature we add in the future. For that reason, I do think a builder pattern or a structure as an argument w/ optional fields might be more flexible.\n\nWould any of these options be easy to use for AIDL users of libbinder_rs? How would they use it?",
      "parentUuid": "a4053206_cb8f7538",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "400387b0_b81b99d2",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1809421
      },
      "writtenOn": "2021-04-14T00:00:57Z",
      "side": 1,
      "message": "The new_binder() call I linked is what is exposed by AIDL. We could certainly add new constructor with a struct param for extra features that the user can pass. The code from a users perspective would be something like:\n\n    let features \u003d BinderFeatures {\n      setRequestingSid: true,\n      ..BinderFeatures::default()\n    };\n    let foo \u003d BnFoo::new_binder_with_features(..., features);\n\nWe could also add BinderFeatures::setRequestingSid() as a shortcut to construct an object containing a single feature.",
      "parentUuid": "10ddacfa_5394af9c",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fd7e840f_a41f065c",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-14T00:51:12Z",
      "side": 1,
      "message": "as long as there are never Rust prebuilts, I\u0027m happy with it",
      "parentUuid": "400387b0_b81b99d2",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "40493934_7d360ded",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 2
      },
      "lineNbr": 385,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-04-14T00:51:28Z",
      "side": 1,
      "message": "do you want to add it on top of this?",
      "parentUuid": "fd7e840f_a41f065c",
      "revId": "0893a4f3cf87ed65d9a5645029a81648669481fd",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}