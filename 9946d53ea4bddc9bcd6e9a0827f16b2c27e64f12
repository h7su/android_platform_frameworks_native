{
  "comments": [
    {
      "key": {
        "uuid": "27b61101_bda562c9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 7,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-12T09:56:34Z",
      "side": 1,
      "message": "If this is the way forward, we need similar in libbinder_ndk and also in android.os.Binder, right?",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 9
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "3b3a333b_a69f8d46",
        "filename": "/COMMIT_MSG",
        "patchSetId": 2
      },
      "lineNbr": 7,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-12T17:41:23Z",
      "side": 1,
      "message": "Yep. Although, I was going to let this get in first. See thread w/ hackbod though. There might be some changes to this.",
      "parentUuid": "27b61101_bda562c9",
      "range": {
        "startLine": 7,
        "startChar": 0,
        "endLine": 7,
        "endChar": 9
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e2eb96e0_1ca3569d",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 84,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-12T09:56:34Z",
      "side": 1,
      "message": "Do you think we need to support multiple extensions for a binder? e.g. via a tag? For example, getExtension(int tag, sp\u003cIBinder\u003e* out)\n\nThis might be needed when both an SoC vendor and an OEM that is a downstream of the SoC vendor have a need to extend the same interface.",
      "range": {
        "startLine": 84,
        "startChar": 18,
        "endLine": 84,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df7ca0cd_0b5e3d26",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 84,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-12T17:41:23Z",
      "side": 1,
      "message": "Yeah, this is similar to what hackbod is talking about (although passing descriptor instead of tag). And you had said \"I think one is enough.\" in the design doc :)\n\nI think in this case the OEM could add an extension to the SoC extension (extension of an extension). I also kind of like not having a query because I don\u0027t really want to encourage many extensions, and it\u0027s nice to always be able to get ahold of it for testing/to see what type of extension is supported.\n\nIDK. Maybe",
      "parentUuid": "e2eb96e0_1ca3569d",
      "range": {
        "startLine": 84,
        "startChar": 18,
        "endLine": 84,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9aadba6d_5693e93c",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 84,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-13T00:56:47Z",
      "side": 1,
      "message": "Yeah, sorry. My opinion changes every other day, largely due to my incomplete understanding of the problem. :)\n\nExtension of extension is possible but, if I were an OEM dev, I will be very disappointed. Many OEMs use chipsets from different SoC vendors and their source code are sometimes mixed in a single tree. What if the three companies (the OEM, SoC vendor A, and SoC vendor B) want to extend the same AOSP interface? Where should the OEM extension be extended from? Among the vendor A and B, who will win?",
      "parentUuid": "df7ca0cd_0b5e3d26",
      "range": {
        "startLine": 84,
        "startChar": 18,
        "endLine": 84,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9f775f2e_cd6e6f20",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 84,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-13T16:36:32Z",
      "side": 1,
      "message": "I am still mixed about this, partially because getExt(string, binder*) will require a bunch of extra string conversions.\n\n\u003e want to extend the same AOSP interface?\n\nThey won\u0027t extend the interface, but they will extend the implementation.\n\nFor instance, imagine we have an interface that is implemented by three different SoCs.\n\n// registering interface from vendor A\nsp\u003cMyAFoo\u003e fooA \u003d new MyAFoo;\nsp\u003cMyAFooExt\u003e fooAExt \u003d new MyAFooExt;\nfooA-\u003esetExt(fooAExt);\n\n// registering interface from vendor B\nsp\u003cMyBFoo\u003e fooB \u003d new MyBFoo;\nsp\u003cMyBFooExt\u003e fooBExt \u003d new MyBFooExt;\nfooB-\u003esetExt(fooBExt);\n\nThe client will go like this:\nsp\u003cIBinder\u003e fooBinder \u003d ...;\nsp\u003cIFoo\u003e foo \u003d interface_cast\u003cIFoo\u003e(IBinder);\n\nsp\u003cIBinder\u003e ext;\n.... foo-\u003egetExt(\u0026ext);\n\nsp\u003cIAFoo\u003e afoo \u003d interface_cast\u003cIAFoo\u003e(ext); // if non-null use this\nsp\u003cIBFoo\u003e bfoo \u003d interface_cast\u003cIBFoo\u003e(ext); // or if this is non-null us this\n\nOr, do you imagine that two different SOCs will extend the same implementation? If this is the case, I think it would be obvious which extension is which (the implementer would simply choose).\n\nIf we instead keep map\u003cstring, IBinder\u003e as a list of extensions or even vec\u003cIBinder\u003e and have to pass the String in, I think it will be expensive/a lot of infrastructure for little gain (particularly, I\u0027m worried about all of the extra utf-8/utf-16 string conversions when this API is moved to libbinder_ndk, this is what got me thinking about all of this).\n\n\nMaybe we can provide a method like getExtensions instead?\n\nstd::set\u003cIBinder\u003e getExtensions(const sp\u003cIBinder\u003e\u0026 binder) {\n    std::set\u003cIBinder\u003e binders;\n    sp\u003cIBinder\u003e curr \u003d binder;\n    while (binders.find(curr) !\u003d binders.end()) {\n        binders.insert(curr);\n        curr-\u003egetExt(\u0026curr);\n    }\n    return binders;\n}\n\nSo, the current \"linked-list\" approach seems like it is more than enough AND it has the added benefits over tag/string:\n- that it is lightweight\n- that all extension interfaces can be retrieved for testing",
      "parentUuid": "9aadba6d_5693e93c",
      "range": {
        "startLine": 84,
        "startChar": 18,
        "endLine": 84,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "676b2511_b17e8b0b",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 84,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-15T16:20:19Z",
      "side": 1,
      "message": "Hmm, that still doesn\u0027t look good to me. That seems to be burdening clients; they need to search for the extension that they are looking for.\n\nI also wonder why the tag has to be a string. Both string and integer are not free from collision, right? Furthermore, since the number of tags expected is very small (i.e. 2 or 3 at most), I don\u0027t think we will actually hit a collision. A SoC vendor can reserve a number for its downstream partners (OEMs).\n\nGiven that integer is enough, I wonder if this is considered expensive and heavy.",
      "parentUuid": "9f775f2e_cd6e6f20",
      "range": {
        "startLine": 84,
        "startChar": 18,
        "endLine": 84,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03598f2e_1da9fabe",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 84,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-15T16:55:03Z",
      "side": 1,
      "message": "In practice, w/ HIDL, we haven\u0027t seen many extensions involving multiple extensions like this.\n\nI think the tag is not so good because it forms part of the ABI and if it is changed, the correct extension will be lost. We already have a type description, and if we invent another thing to keep track of that corresponds to this description. I think it\u0027s quite fragile to ever have \u0027if (tag \u003d\u003d 1) return mFoo; if (tag \u003d\u003d 2) return mBar\u0027 etc.. Since this is not defined anywhere in the interface. Even the \u0027Inspect\u0027 functionality from OpenBinder uses strings (but implementors still have to write code that corresponds to this).\n\nFurther, a single SOC vendor should only ever really have one extension encompassing all of the functionality they are adding to an interface. If they need multiple sub interfaces, it makes sense to attach them to a manager interface, e.g.:\ninterface IExtendBase { void doFoo(); ISubInterface getSemanticSubInterface(/* params? */); }\n\nOkay, actually, maybe I will try strings. I have just realized the virtual table is not closed, so there is no need for an extra datastructure.",
      "parentUuid": "676b2511_b17e8b0b",
      "range": {
        "startLine": 84,
        "startChar": 18,
        "endLine": 84,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bc9607e3_3286e763",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 89,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-09T22:01:15Z",
      "side": 1,
      "message": "we can at least invent polymorphism, even though the virtual tables are stuck. Maybe we should do this for shellCommand as well?",
      "range": {
        "startLine": 85,
        "startChar": 0,
        "endLine": 89,
        "endChar": 5
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "56b81829_046a6d75",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-12T09:56:34Z",
      "side": 1,
      "message": "What about caching the result of this?",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 96,
        "endChar": 68
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "1ce24634_c1e621d1",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-12T17:41:23Z",
      "side": 1,
      "message": "If it is DEAD_OBJECT, transact should do that internally.\n\nIf you mean caching the extension, I wouldn\u0027t think people would call this much. Maybe we can if it comes to that?",
      "parentUuid": "56b81829_046a6d75",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 96,
        "endChar": 68
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "785371f0_83c220f1",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-13T00:56:47Z",
      "side": 1,
      "message": "Yeah, this is not a big optimization. We can revisit when it really becomes a bottleneck.",
      "parentUuid": "1ce24634_c1e621d1",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 96,
        "endChar": 68
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f3542753_79c49f76",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 96,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-13T00:57:56Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "785371f0_83c220f1",
      "range": {
        "startLine": 96,
        "startChar": 0,
        "endLine": 96,
        "endChar": 68
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "eb874d1e_ac1d5d09",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 109,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-09T22:01:15Z",
      "side": 1,
      "message": "any thoughts on putting it here VS inside of the object manager?",
      "range": {
        "startLine": 109,
        "startChar": 0,
        "endLine": 109,
        "endChar": 27
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ac37ff9_06d497f8",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-12T09:56:34Z",
      "side": 1,
      "message": "Do you intend to allow changing the extension at runtime? If so, why?\n\nWhat about returning the extension via a function in BBinder that can be overridden by clients?",
      "range": {
        "startLine": 255,
        "startChar": 0,
        "endLine": 255,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "97d547bf_010df44a",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-12T17:41:23Z",
      "side": 1,
      "message": "No, the comment on this method says to only install it when the BBinder is originally created (otherwise it isn\u0027t threadsafe).\n\n\u003e What about returning the extension via a function in BBinder that can be overridden by clients?\n\nThis would be ideal, but the virtual table of IBinder is frozen. It can\u0027t be changed.",
      "parentUuid": "4ac37ff9_06d497f8",
      "range": {
        "startLine": 255,
        "startChar": 0,
        "endLine": 255,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "e156ad8b_8a40d060",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-13T00:56:47Z",
      "side": 1,
      "message": "\u003e the virtual table of IBinder is frozen\n\nWhy? That\u0027s a news to me.",
      "parentUuid": "97d547bf_010df44a",
      "range": {
        "startLine": 255,
        "startChar": 0,
        "endLine": 255,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3443e3c5_e3c6e029",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-13T16:36:32Z",
      "side": 1,
      "message": "Because of many many many many many many prebuilts :)",
      "parentUuid": "e156ad8b_8a40d060",
      "range": {
        "startLine": 255,
        "startChar": 0,
        "endLine": 255,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a2ca2c6f_95acbd5c",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2019-08-15T16:20:19Z",
      "side": 1,
      "message": "Hmm, the same can be said for other foundation libraries: libc++, libbase, libutils, etc. We can change their ABIs and the prebuilts have to pay for the price...",
      "parentUuid": "3443e3c5_e3c6e029",
      "range": {
        "startLine": 255,
        "startChar": 0,
        "endLine": 255,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b345143d_f2fad07d",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-15T16:55:03Z",
      "side": 1,
      "message": "Oops, I had only checked that sizeof(..) these structs are frozen. I should be able to switch this to virtual inheritance.\n\nThis really makes me wonder why shellCommand was implemented in this way :(\n\n\u003e prebuilts have to pay for the price...\n\nFor a change that does change the size of IBinder/BBinder for instance, it would be impractical to coordintate 100s of prebuilt updates across many devices.",
      "parentUuid": "a2ca2c6f_95acbd5c",
      "range": {
        "startLine": 255,
        "startChar": 0,
        "endLine": 255,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fe260cf5_861fedbb",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-15T18:10:34Z",
      "side": 1,
      "message": "Ah, I am still so mixed on this. I don\u0027t want people using this mechanism as a standard way to add many different interfaces. Where possible, they should always add sub-interfaces as part of the AIDL definition.",
      "parentUuid": "b345143d_f2fad07d",
      "range": {
        "startLine": 255,
        "startChar": 0,
        "endLine": 255,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "18d2a9ca_642fd66a",
        "filename": "libs/binder/Binder.cpp",
        "patchSetId": 2
      },
      "lineNbr": 255,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2019-08-16T00:29:53Z",
      "side": 1,
      "message": "Okay, looking deeper, the virtual table is frozen when we call this method on things implemented by prebuilts because a new function will be missing from subclass vtables, so it will fail. It\u0027s fine to add one if we only call it on recompiled code, but that isn\u0027t guaranteed to be the case.\n\nI have setup an example so you can see:\nhttps://android-review.googlesource.com/c/platform/frameworks/native/+/1103997\n\n\u003e We can change their ABIs and the prebuilts have to pay for the price...\n\nSo, the price is UB. It may be crashes, potentially a security problem. It\u0027s impossible/not worth it to coordinate these updates for nearly 100 prebuilts on almost every (incl unsupported) SOC in tree. I will send email offline with a list of prebuilts containing _ZN7android7BBinderC2Ev (base class constructor) and my scripts to find this.",
      "parentUuid": "fe260cf5_861fedbb",
      "range": {
        "startLine": 255,
        "startChar": 0,
        "endLine": 255,
        "endChar": 30
      },
      "revId": "9946d53ea4bddc9bcd6e9a0827f16b2c27e64f12",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}