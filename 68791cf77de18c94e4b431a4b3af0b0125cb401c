{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "22f7baaf_a185d188",
        "filename": "libs/binder/ndk/include_ndk/android/binder_ibinder.h",
        "patchSetId": 2
      },
      "lineNbr": 714,
      "author": {
        "id": 1006497
      },
      "writtenOn": "2021-01-15T12:36:12Z",
      "side": 1,
      "message": "Sorry, but can we restore the example as well? I think explaining this part is orthogonal to explaining why we provide ordering at all.",
      "range": {
        "startLine": 710,
        "startChar": 0,
        "endLine": 714,
        "endChar": 51
      },
      "revId": "68791cf77de18c94e4b431a4b3af0b0125cb401c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1465837_f8b88e9c",
        "filename": "libs/binder/ndk/include_ndk/android/binder_ibinder.h",
        "patchSetId": 2
      },
      "lineNbr": 718,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2021-01-13T00:29:21Z",
      "side": 1,
      "message": "I think the thing that\u0027s missing is *why* the ordering of these addresses is interesting.",
      "revId": "68791cf77de18c94e4b431a4b3af0b0125cb401c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f991b04_f3297de4",
        "filename": "libs/binder/ndk/include_ndk/android/binder_ibinder.h",
        "patchSetId": 2
      },
      "lineNbr": 718,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-01-13T01:19:24Z",
      "side": 1,
      "message": "I think we agree that being able to compare objects (even if this sorting order doesn\u0027t correspond to something important) is very useful.\n\nL697-L699 starts off by saying that this is an extension of AIBinder_lt.\nHowever, this can\u0027t be a full explanation since weak binders don\u0027t have to be promotable. In other words, this function might be passed two separate binder objects which could never be passed into AIBinder_lt. So the question remains, how does this function handle this case? I attempt to answer this in L701-L718.\n\nThe answer is:\n- if they\u0027re at the same address, we declare we handle this (now honestly much too verbose by this example, since it really is a detail)\n- \"even though multiple AIBinder* instances may happen to be allocated at the same address\": otherwise it\u0027s obvious that when two AIBinder* objects are at different addresses, there is no reason they should be the same, since we handle this even when they are at the same address\n\nDo you have any specific suggestion? I can also give it another whirl.",
      "parentUuid": "e1465837_f8b88e9c",
      "revId": "68791cf77de18c94e4b431a4b3af0b0125cb401c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "453e351f_213fed73",
        "filename": "libs/binder/ndk/include_ndk/android/binder_ibinder.h",
        "patchSetId": 2
      },
      "lineNbr": 718,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2021-01-13T21:07:05Z",
      "side": 1,
      "message": "No, that actually is my question: why would I want to order these things that have no meaningful ordering? I\u0027m assuming this API isn\u0027t coming out of thin air. What\u0027s the motivation for making these sortable? Why might an NDK user want to use this API? It\u0027s not clear from the documentation what this API actually enables in an app.",
      "parentUuid": "7f991b04_f3297de4",
      "revId": "68791cf77de18c94e4b431a4b3af0b0125cb401c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c76bc864_f0e58c83",
        "filename": "libs/binder/ndk/include_ndk/android/binder_ibinder.h",
        "patchSetId": 2
      },
      "lineNbr": 718,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-01-13T21:57:30Z",
      "side": 1,
      "message": "Ordering enables certain types of algorithms/data structures. Examples:\n1. you can compute equality\n2. this enables these to be used as keys in a std::map.",
      "parentUuid": "453e351f_213fed73",
      "revId": "68791cf77de18c94e4b431a4b3af0b0125cb401c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cfe59437_50ac2e2b",
        "filename": "libs/binder/ndk/include_ndk/android/binder_ibinder.h",
        "patchSetId": 2
      },
      "lineNbr": 718,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2021-01-13T22:09:35Z",
      "side": 1,
      "message": "1 doesn\u0027t require ordering, just an equality operator.\n\nWhy use std::map instead of std::unordered_map when your keys have no meaningful ordering?",
      "parentUuid": "c76bc864_f0e58c83",
      "revId": "68791cf77de18c94e4b431a4b3af0b0125cb401c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cca0c51f_23327645",
        "filename": "libs/binder/ndk/include_ndk/android/binder_ibinder.h",
        "patchSetId": 2
      },
      "lineNbr": 718,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-01-13T22:50:18Z",
      "side": 1,
      "message": "\u003e 1 doesn\u0027t require ordering, just an equality operator.\n\nYep, but I chose a single, more generic API, which allows even more things to be done. I\u0027m sure you would agree that we don\u0027t want multiple APIs where one API can be derived from another (w/o imparting additional semantics on another, and where the performance impact is negligible), so perhaps it wasn\u0027t so relevant for me to bring the example of \u0027equality\u0027 up.\n\n\u003e Why use std::map instead of std::unordered_map when your keys have no meaningful ordering?\n\nWell - I hope this doesn\u0027t distract from the main point - std::map (red-black trees, maybe binary search trees, etc..) is just an example of a data structure which requires a total ordering existing/comparison operator (note - these are not the same things, and this is also documented in the standard for std::map). Sure, the last (\"max\") element in a sorted array of binders according to this function is not actually the meaningfully maximum element, but this function gives you the ability to deterministically compare two binder. If one binder compared beforehand in a certain way to another binder, it\u0027ll continue to. The intuition is, this determinism means that a carefully placed binder object in memory combined with this function imbues an algorithm with information based on what it had done in a previous case, which would otherwise have to be stored in a different way. This is an additional tool in the algorithm\u0027s belt, and so it isn\u0027t surprising it finds advantageous use.\n\nBut to answer your question, std::unordered_map and std::map have very different properties in terms of performance and memory use. They make different types of allocations, at different times, and no blanket statement is possible to explain why one should be used instead of the other. Sure std::map has some functionality that wouldn\u0027t make sense to use with this (again, relying on the last iterated element to be the max), but this is only one consequence of the data structure\u0027s design, and others can be useful in other situations.\n\nIronically, std::unordered_map can\u0027t be used with AIBinder_Weak using these APIs and documentation alone. Though - support for such a fringe feature, I find feasible following a feature request.",
      "parentUuid": "cfe59437_50ac2e2b",
      "revId": "68791cf77de18c94e4b431a4b3af0b0125cb401c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5b6959a9_bfb19845",
        "filename": "libs/binder/ndk/include_ndk/android/binder_ibinder.h",
        "patchSetId": 2
      },
      "lineNbr": 718,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2021-01-14T00:43:45Z",
      "side": 1,
      "message": "The docs should say things like \"this ordering is meaningless and only serves to allow storage in containers which require ordering such as binary trees\" or similar. This still seems like a really strange API to me as opposed to just an isEqual since the types have no meaningful ordering, but \"because C++ data structures are weird\" sounds plausible. I don\u0027t know the language well enough to judge that.",
      "parentUuid": "cca0c51f_23327645",
      "revId": "68791cf77de18c94e4b431a4b3af0b0125cb401c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3ef9542_043c4f3c",
        "filename": "libs/binder/ndk/include_ndk/android/binder_ibinder.h",
        "patchSetId": 2
      },
      "lineNbr": 718,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-01-15T01:48:40Z",
      "side": 1,
      "message": "I\u0027ve tried to clarify docs according to this thread \u0026 will talk offline.",
      "parentUuid": "5b6959a9_bfb19845",
      "revId": "68791cf77de18c94e4b431a4b3af0b0125cb401c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}