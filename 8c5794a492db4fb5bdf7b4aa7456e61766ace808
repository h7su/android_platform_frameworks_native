{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "17b513c7_e4c3b601",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1149384
      },
      "writtenOn": "2020-10-14T02:34:38Z",
      "side": 1,
      "message": "Hi Xiaobo,\nI have a slightly different solution for this in master. I will see if I can adapt it to R.\n\nHere\u0027s the patch:\n\nFrom f56b2692626c68df4632dacfc8834640594d437f Mon Sep 17 00:00:00 2001\nFrom: Siarhei Vishniakou \u003csvv@google.com\u003e\nDate: Tue, 08 Sep 2020 19:43:33 -0500\nSubject: [PATCH] Check for focused window before raising \u0027no focused window\u0027 ANR\n\nPreviously, we were relying on the dispatcher trying to send a focused\nevent prior to raising ANR due to no focused window.\n\nSo, the previous expected behavior was:\n1. A key comes in, and there is no focused window\n2. ANR timer starts\n3. Focused window appears\n4. We try to dispatch the key again, and realize there\u0027s a focused\nwindow\n5. We stop the ANR timer\n\nHowever, there are cases when the pending key event gets dropped. For\nexample, this could happen if the user touches another application. That\nwould lead to the following sequence of events:\n1. A key comes in, and there is no focused window\n2. ANR timer starts\n3. User touches another application, and the pending key gets dropped\n4. Focused window appears\n5. We don\u0027t try to dispatch the pending key anymore (since nothing is\npending)\n6. We raise the \"no focused window\" ANR, even though we have a focused\nwindow (and don\u0027t even have a focused event to dispatch anymore).\n\nSolution: always check for focused window presence before raising the\n\"no focused window\" ANR. This way, we will no longer rely on other events\nhappening for this ANR to be functioning correctly.\n\nBug: 164754075\nTest: atest inputflinger_tests\nChange-Id: I70162d507fa7d65132c83fcba96ad9931e373647\n---\n\ndiff --git a/services/inputflinger/dispatcher/InputDispatcher.cpp b/services/inputflinger/dispatcher/InputDispatcher.cpp\nindex efe2bb1..0f06ddf 100644\n--- a/services/inputflinger/dispatcher/InputDispatcher.cpp\n+++ b/services/inputflinger/dispatcher/InputDispatcher.cpp\n@@ -481,6 +481,33 @@\n }\n \n /**\n+ * Raise ANR if there is no focused window.\n+ * Before the ANR is raised, do a final state check:\n+ * 1. The currently focused application must be the same one we are waiting for.\n+ * 2. Ensure we still don\u0027t have a focused window.\n+ */\n+void InputDispatcher::processNoFocusedWindowAnrLocked() {\n+    // Check if the application that we are waiting for is still focused.\n+    std::shared_ptr\u003cInputApplicationHandle\u003e focusedApplication \u003d\n+            getValueByKey(mFocusedApplicationHandlesByDisplay, mAwaitedApplicationDisplayId);\n+    if (focusedApplication \u003d\u003d nullptr ||\n+        focusedApplication-\u003egetApplicationToken() !\u003d\n+                mAwaitedFocusedApplication-\u003egetApplicationToken()) {\n+        // Unexpected because we should have reset the ANR timer when focused application changed\n+        ALOGE(\"Waited for a focused window, but focused application has already changed to %s\",\n+              focusedApplication-\u003egetName().c_str());\n+        return; // The focused application has changed.\n+    }\n+\n+    const sp\u003cInputWindowHandle\u003e\u0026 focusedWindowHandle \u003d\n+            getFocusedWindowHandleLocked(mAwaitedApplicationDisplayId);\n+    if (focusedWindowHandle !\u003d nullptr) {\n+        return; // We now have a focused window. No need for ANR.\n+    }\n+    onAnrLocked(mAwaitedFocusedApplication);\n+}\n+\n+/**\n  * Check if any of the connections\u0027 wait queues have events that are too old.\n  * If we waited for events to be ack\u0027ed for more than the window timeout, raise an ANR.\n  * Return the time at which we should wake up next.\n@@ -491,8 +518,9 @@\n     // Check if we are waiting for a focused window to appear. Raise ANR if waited too long\n     if (mNoFocusedWindowTimeoutTime.has_value() \u0026\u0026 mAwaitedFocusedApplication !\u003d nullptr) {\n         if (currentTime \u003e\u003d *mNoFocusedWindowTimeoutTime) {\n-            onAnrLocked(mAwaitedFocusedApplication);\n+            processNoFocusedWindowAnrLocked();\n             mAwaitedFocusedApplication.reset();\n+            mNoFocusedWindowTimeoutTime \u003d std::nullopt;\n             return LONG_LONG_MIN;\n         } else {\n             // Keep waiting\n@@ -1494,6 +1522,7 @@\n                     DEFAULT_INPUT_DISPATCHING_TIMEOUT);\n             mNoFocusedWindowTimeoutTime \u003d currentTime + timeout.count();\n             mAwaitedFocusedApplication \u003d focusedApplicationHandle;\n+            mAwaitedApplicationDisplayId \u003d displayId;\n             ALOGW(\"Waiting because no window has focus but %s may eventually add a \"\n                   \"window when it finishes starting up. Will wait for %\" PRId64 \"ms\",\n                   mAwaitedFocusedApplication-\u003egetName().c_str(), millis(timeout));\ndiff --git a/services/inputflinger/dispatcher/InputDispatcher.h b/services/inputflinger/dispatcher/InputDispatcher.h\nindex 4fcdcc2..859a9f4 100644\n--- a/services/inputflinger/dispatcher/InputDispatcher.h\n+++ b/services/inputflinger/dispatcher/InputDispatcher.h\n@@ -390,6 +390,11 @@\n      * Used to raise an ANR when we have no focused window.\n      */\n     std::shared_ptr\u003cInputApplicationHandle\u003e mAwaitedFocusedApplication GUARDED_BY(mLock);\n+    /**\n+     * The displayId that the focused application is associated with.\n+     */\n+    int32_t mAwaitedApplicationDisplayId GUARDED_BY(mLock);\n+    void processNoFocusedWindowAnrLocked() REQUIRES(mLock);\n \n     /**\n      * This map will store the pending focus requests that cannot be currently processed. This can\ndiff --git a/services/inputflinger/tests/InputDispatcher_test.cpp b/services/inputflinger/tests/InputDispatcher_test.cpp\nindex 70f872a..766dc90 100644\n--- a/services/inputflinger/tests/InputDispatcher_test.cpp\n+++ b/services/inputflinger/tests/InputDispatcher_test.cpp\n@@ -3483,6 +3483,68 @@\n     mFocusedWindow-\u003eassertNoEvents();\n }\n \n+/**\n+ * If we have no focused window, and a key comes in, we start the ANR timer.\n+ * The focused application should add a focused window before the timer runs out to prevent ANR.\n+ *\n+ * If the user touches another application during this time, the key should be dropped.\n+ * Next, if a new focused window comes in, without toggling the focused application,\n+ * then no ANR should occur.\n+ *\n+ * Normally, we would expect the new focused window to be accompanied by \u0027setFocusedApplication\u0027,\n+ * but in some cases the policy may not update the focused application.\n+ */\n+TEST_F(InputDispatcherMultiWindowAnr, FocusedWindowWithoutSetFocusedApplication_NoAnr) {\n+    std::shared_ptr\u003cFakeApplicationHandle\u003e focusedApplication \u003d\n+            std::make_shared\u003cFakeApplicationHandle\u003e();\n+    focusedApplication-\u003esetDispatchingTimeout(60ms);\n+    mDispatcher-\u003esetFocusedApplication(ADISPLAY_ID_DEFAULT, focusedApplication);\n+    // The application that owns \u0027mFocusedWindow\u0027 and \u0027mUnfocusedWindow\u0027 is not focused.\n+    mFocusedWindow-\u003esetFocusable(false);\n+\n+    mDispatcher-\u003esetInputWindows({{ADISPLAY_ID_DEFAULT, {mFocusedWindow, mUnfocusedWindow}}});\n+    mFocusedWindow-\u003econsumeFocusEvent(false);\n+\n+    // Send a key. The ANR timer should start because there is no focused window.\n+    // \u0027focusedApplication\u0027 will get blamed if this timer completes.\n+    // Key will not be sent anywhere because we have no focused window. It will remain pending.\n+    int32_t result \u003d\n+            injectKey(mDispatcher, AKEY_EVENT_ACTION_DOWN, 0 /*repeatCount*/, ADISPLAY_ID_DEFAULT,\n+                      INPUT_EVENT_INJECTION_SYNC_NONE, 10ms /*injectionTimeout*/);\n+    ASSERT_EQ(INPUT_EVENT_INJECTION_SUCCEEDED, result);\n+\n+    // Wait until dispatcher starts the \"no focused window\" timer. If we don\u0027t wait here,\n+    // then the injected touches won\u0027t cause the focused event to get dropped.\n+    // The dispatcher only checks for whether the queue should be pruned upon queueing.\n+    // If we inject the touch right away and the ANR timer hasn\u0027t started, the touch event would\n+    // simply be added to the queue without \u0027shouldPruneInboundQueueLocked\u0027 returning \u0027true\u0027.\n+    // For this test, it means that the key would get delivered to the window once it becomes\n+    // focused.\n+    std::this_thread::sleep_for(10ms);\n+\n+    // Touch unfocused window. This should force the pending key to get dropped.\n+    NotifyMotionArgs motionArgs \u003d\n+            generateMotionArgs(AMOTION_EVENT_ACTION_DOWN, AINPUT_SOURCE_TOUCHSCREEN,\n+                               ADISPLAY_ID_DEFAULT, {UNFOCUSED_WINDOW_LOCATION});\n+    mDispatcher-\u003enotifyMotion(\u0026motionArgs);\n+\n+    // We do not consume the motion right away, because that would require dispatcher to first\n+    // process (\u003d\u003d drop) the key event, and by that time, ANR will be raised.\n+    // Set the focused window first.\n+    mFocusedWindow-\u003esetFocusable(true);\n+    mDispatcher-\u003esetInputWindows({{ADISPLAY_ID_DEFAULT, {mFocusedWindow, mUnfocusedWindow}}});\n+    setFocusedWindow(mFocusedWindow);\n+    mFocusedWindow-\u003econsumeFocusEvent(true);\n+    // We do not call \"setFocusedApplication\" here, even though the newly focused window belongs\n+    // to another application. This could be a bug / behaviour in the policy.\n+\n+    mUnfocusedWindow-\u003econsumeMotionDown();\n+\n+    ASSERT_TRUE(mDispatcher-\u003ewaitForIdle());\n+    // Should not ANR because we actually have a focused window. It was just added too slowly.\n+    ASSERT_NO_FATAL_FAILURE(mFakePolicy-\u003eassertNotifyAnrWasNotCalled());\n+}\n+\n // These tests ensure we cannot send touch events to a window that\u0027s positioned behind a window\n // that has feature NO_INPUT_CHANNEL.\n // Layout:",
      "revId": "8c5794a492db4fb5bdf7b4aa7456e61766ace808",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}