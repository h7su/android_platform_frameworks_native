{
  "comments": [
    {
      "key": {
        "uuid": "657fbf9b_7ab2b8a5",
        "filename": "libs/binder/ndk/ABinderProcess.cpp",
        "patchSetId": 29
      },
      "lineNbr": 31,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-29T18:41:29Z",
      "side": 1,
      "message": "any particular reason to hide the error return value? I guess we can\u0027t use these in the NDK?",
      "range": {
        "startLine": 31,
        "startChar": 0,
        "endLine": 31,
        "endChar": 4
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9d226a31_eee1e6a9",
        "filename": "libs/binder/ndk/ABinderProcess.cpp",
        "patchSetId": 29
      },
      "lineNbr": 31,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T01:11:45Z",
      "side": 1,
      "message": "I may completely redo this part of the API (depending on how APEX works out), so I didn\u0027t spend much time on it. This API already logs its failures. No real reason to expose the complexity for now.",
      "parentUuid": "657fbf9b_7ab2b8a5",
      "range": {
        "startLine": 31,
        "startChar": 0,
        "endLine": 31,
        "endChar": 4
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a244891a_ec848df3",
        "filename": "libs/binder/ndk/ABinderProcess.cpp",
        "patchSetId": 29
      },
      "lineNbr": 31,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T07:40:25Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "9d226a31_eee1e6a9",
      "range": {
        "startLine": 31,
        "startChar": 0,
        "endLine": 31,
        "endChar": 4
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "dc1f5fb0_64f81aa9",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 70,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-29T18:41:29Z",
      "side": 1,
      "message": "are you saying, somebody should never call associateClass() on a ABBinder? If so, maybe do this CHECK() earlier in this function? It just confused me here after the descriptor checking.",
      "range": {
        "startLine": 70,
        "startChar": 0,
        "endLine": 70,
        "endChar": 61
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2ca56d66_7a144c83",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 70,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T01:11:45Z",
      "side": 1,
      "message": "No, it\u0027s just handled above. If they call it on an ABBinder, it\u0027s guaranteed to be resolved at this point.",
      "parentUuid": "dc1f5fb0_64f81aa9",
      "range": {
        "startLine": 70,
        "startChar": 0,
        "endLine": 70,
        "endChar": 61
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9b6449d3_c764ff38",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 70,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T07:40:25Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "2ca56d66_7a144c83",
      "range": {
        "startLine": 70,
        "startChar": 0,
        "endLine": 70,
        "endChar": 61
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "aad767be_839071ee",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 75,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-29T18:41:29Z",
      "side": 1,
      "message": "how does this happen? I don\u0027t think this happens in regular libbinder; if you receive a reference to an object that is local in your process, the kernel will give a pointer to the node, which should be associated with the ABBinder - we don\u0027t wrap a proxy around it. I\u0027m pretty sure this doesn\u0027t happen in Java either (which solves a similar usecase).",
      "range": {
        "startLine": 75,
        "startChar": 11,
        "endLine": 75,
        "endChar": 49
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "df905a34_1cab89c4",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 75,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T01:11:45Z",
      "side": 1,
      "message": "This is something I\u0027ll need to find a solution for in regular binder as well (and I\u0027ll have to add another patchset to handle or disable libbinder\u003c-\u003elibbinder_ndk transactions).\n\nEssentially, I don\u0027t know if this is an ABBinder object until I can confirm that it is with the descriptor. It could be a BnInterface object (or a subclass of that), and so casting it to that type isn\u0027t valid.\n\nThis really should use something like IBinder::attachObject to confirm the situation further, but I don\u0027t want to handle that in this CL (it\u0027s already too big).",
      "parentUuid": "aad767be_839071ee",
      "range": {
        "startLine": 75,
        "startChar": 11,
        "endLine": 75,
        "endChar": 49
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b4691bbf_eaee3404",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 75,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T07:40:25Z",
      "side": 1,
      "message": "Ah understood - see comment in AServiceManager also.",
      "parentUuid": "df905a34_1cab89c4",
      "range": {
        "startLine": 75,
        "startChar": 11,
        "endLine": 75,
        "endChar": 49
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "0def0676_f5573b50",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 213,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-29T18:41:29Z",
      "side": 1,
      "message": "aren\u0027t they always the same object? I guess the only case where that isn\u0027t true is where a proxy wraps a BBinder, which is a case I hope we should be able to prevent. In that case you could also get rid of the refcount ops here.",
      "range": {
        "startLine": 212,
        "startChar": 7,
        "endLine": 213,
        "endChar": 14
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "563bb7a1_02cead87",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 213,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T01:11:45Z",
      "side": 1,
      "message": "They aren\u0027t the same in the above case when we understand that a local ABpBinder object\u0027s remote is actually an ABBinder.",
      "parentUuid": "0def0676_f5573b50",
      "range": {
        "startLine": 212,
        "startChar": 7,
        "endLine": 213,
        "endChar": 14
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1da7bcbf_d474003b",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 213,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T07:40:25Z",
      "side": 1,
      "message": "Yeah, that\u0027s what I meant. We should prevent that case (but ok to do in future PS).",
      "parentUuid": "563bb7a1_02cead87",
      "range": {
        "startLine": 212,
        "startChar": 7,
        "endLine": 213,
        "endChar": 14
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f2472e78_8f6e869a",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 231,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-29T18:41:29Z",
      "side": 1,
      "message": "nit: inconsistent with line 223 etc :)",
      "range": {
        "startLine": 231,
        "startChar": 0,
        "endLine": 231,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "de83632c_b1c23409",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 231,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T01:11:45Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "f2472e78_8f6e869a",
      "range": {
        "startLine": 231,
        "startChar": 0,
        "endLine": 231,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9b2b106d_0ddcbba6",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 256,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-29T18:41:29Z",
      "side": 1,
      "message": "do you keep the Parcel in the binder only for sanity checking?",
      "range": {
        "startLine": 256,
        "startChar": 0,
        "endLine": 256,
        "endChar": 30
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8d9f0e71_069d94c3",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 256,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T01:11:45Z",
      "side": 1,
      "message": "Yes and the reason I went to such great lengths is so that if I need to use a value from the AIBinder in finalizeTransaction, I am guaranteed that a developer didn\u0027t actually mix up binders. It\u0027s also a helpful warning to the developer as you never want to do this.",
      "parentUuid": "9b2b106d_0ddcbba6",
      "range": {
        "startLine": 256,
        "startChar": 0,
        "endLine": 256,
        "endChar": 30
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "91a12c05_3cd99747",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 256,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T07:40:25Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "8d9f0e71_069d94c3",
      "range": {
        "startLine": 256,
        "startChar": 0,
        "endLine": 256,
        "endChar": 30
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a3370abc_b5197906",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 276,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-29T18:41:29Z",
      "side": 1,
      "message": "Don\u0027t do this - it prevents us from settings flags that are introduced later, which may mean nothing to the binder NDK, but it may mean something to the kernel.",
      "range": {
        "startLine": 276,
        "startChar": 4,
        "endLine": 276,
        "endChar": 38
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cf17656f_ef2f30de",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 276,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T01:11:45Z",
      "side": 1,
      "message": "This prevents the user of the NDK binder API from setting flags. If I want to expose more to them, I\u0027ll also have to add things here.",
      "parentUuid": "a3370abc_b5197906",
      "range": {
        "startLine": 276,
        "startChar": 4,
        "endLine": 276,
        "endChar": 38
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3e8528d4_d5c77445",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 276,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T07:40:25Z",
      "side": 1,
      "message": "My concern is that this limits future use of flags against code linking against an old version of the NDK. These flags are just a pass-through and don\u0027t affect the behavior of the NDK implementation. Example: We introduce a new flag in NDK v20, which has a certain behavior on new platforms, but is a no-op on older platforms. An app builds against NDK v20 and uses the constant; now it gets deployed to devices running an older version of the NDK, which will now reject such transactions because of the check here.\n\nMaybe there are common NDK patterns to prevent this?",
      "parentUuid": "cf17656f_ef2f30de",
      "range": {
        "startLine": 276,
        "startChar": 4,
        "endLine": 276,
        "endChar": 38
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "765fa9b3_89d8e8d7",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 276,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T08:00:43Z",
      "side": 1,
      "message": "AFAIK, the mechanisms for deprecation are slightly different in the NDK. If you upgrade your target level to use new things, you\u0027re not allowed to ship on the old devices. I could be misunderstanding this.\n\nIf this is a problem though, I can remove the check. Dan/John?",
      "parentUuid": "3e8528d4_d5c77445",
      "range": {
        "startLine": 276,
        "startChar": 4,
        "endLine": 276,
        "endChar": 38
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cd6c6e58_14eb19e7",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 276,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T08:54:31Z",
      "side": 1,
      "message": "I think you\u0027re right. It does seem like a waste though - if we want to add a new flag which doesn\u0027t break older platforms, you\u0027re now forced to drop support for all older platforms, even when there was no real need to. Is APP_PLATFORM actually enforced at run-time (eg you can\u0027t download/run an app which with APP_PLATFORM set to Y on a device with MIN_SDK \u003c Y), or is it more of a we don\u0027t support this, and good luck if you screw it up?",
      "parentUuid": "765fa9b3_89d8e8d7",
      "range": {
        "startLine": 276,
        "startChar": 4,
        "endLine": 276,
        "endChar": 38
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "26980968_b4064f2e",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 276,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T08:58:21Z",
      "side": 1,
      "message": "Dan/John?",
      "parentUuid": "cd6c6e58_14eb19e7",
      "range": {
        "startLine": 276,
        "startChar": 4,
        "endLine": 276,
        "endChar": 38
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2711ca0_bb218bbf",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 276,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T09:25:16Z",
      "side": 1,
      "message": "(pinging not out of impatience but due to these other longer responses)",
      "parentUuid": "26980968_b4064f2e",
      "range": {
        "startLine": 276,
        "startChar": 4,
        "endLine": 276,
        "endChar": 38
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "93bba600_572d5fc1",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 276,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T11:49:31Z",
      "side": 1,
      "message": "(same story, Dan/John?)",
      "parentUuid": "b2711ca0_bb218bbf",
      "range": {
        "startLine": 276,
        "startChar": 4,
        "endLine": 276,
        "endChar": 38
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "9838c4b0_bb176a56",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 295,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-29T18:41:29Z",
      "side": 1,
      "message": "nit: inconsistent with *in",
      "range": {
        "startLine": 295,
        "startChar": 67,
        "endLine": 295,
        "endChar": 73
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b1dc37d3_1e10a979",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 295,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T01:11:45Z",
      "side": 1,
      "message": "the signature of transact is \u0027..., const Parcel\u0026 data, Parcel* reply\u0027. This inconsistency is because in is of type AParcel*, but out is of type AParcel**. However, they are now fixed. I think using operator-\u003e like this is gross, and may rename it to \u0027getBinderParcel\u0027 at some point, but meh.",
      "parentUuid": "9838c4b0_bb176a56",
      "range": {
        "startLine": 295,
        "startChar": 67,
        "endLine": 295,
        "endChar": 73
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3feb861b_799a8957",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 295,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T07:40:25Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "b1dc37d3_1e10a979",
      "range": {
        "startLine": 295,
        "startChar": 67,
        "endLine": 295,
        "endChar": 73
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "90968063_4f0da7c1",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-29T18:41:29Z",
      "side": 1,
      "message": "similar to checking flags, it\u0027s a nice sanity check, but I wonder if it will limit us in the future. Would LOG(WARNING) do?",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a6551eca_b7f40835",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T01:11:45Z",
      "side": 1,
      "message": "Better to error now and fix it later if we have to. This is something we can always fix (best case, here, worst case, :(, \u0027finalizePartialTransaction\u0027). Before I forget, I filed b/113542980 to check this for AIDL/HIDL as it may expose some bugs there.",
      "parentUuid": "90968063_4f0da7c1",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "1272b76b_08b7d7ac",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T07:40:25Z",
      "side": 1,
      "message": "Right, the worry here is the same as above; if we want to allow this in the future for whatever reason, we can\u0027t go back and retro-actively change the NDK on already shipped devices.",
      "parentUuid": "a6551eca_b7f40835",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "6b2d321a_f0723ba9",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T08:00:43Z",
      "side": 1,
      "message": "I think my other comment is the case. For instance, imagine I fix this problem by adding a method like \u0027AParcel_setDataPosition\u0027 (also for getting/getting data available, etc..). People wanting to not read all the data should then just set the data position to the end. However, there is no way for these people to link against this method on old devices (or use it since it doesn\u0027t exist). If we aggressively used weak symbols in our headers, we could add new APIs like this (and be expected to have forwards compatibility like you are suggesting), but we don\u0027t do this. Alternatively, we could just require app developers to read all the data on devices until this restriction was removed.\n\nEither way, I don\u0027t want to lift this specific restriction. I\u0027ll probably add setDataPosition in a follow-up CL relatively soon in this release. I think being knowledgeable about the state that you might accidentally forget (by throwing this error) is really helpful and a good for developers.",
      "parentUuid": "1272b76b_08b7d7ac",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a87c67bf_e74d1e00",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T08:54:31Z",
      "side": 1,
      "message": "I think the answer to this hinges on the answer above.\n\nBut I can also think of quite some scenarios where you don\u0027t want to bother reading the rest of the Parcel (eg error scenarios when parsing), and now you need to reset the position with your new API in all those cases. I\u0027m just not sure it\u0027ll benefit us that much, given that most parsing code will be auto-generated (and correct), and you\u0027d find out pretty quickly if you don\u0027t have data that you need. I don\u0027t think this particular thing has ever bitten us with regular binder.\n\nAlso this lib is mostly a C API around libbinder, and it feels like the wrong place to do some of this sanity checking.",
      "parentUuid": "6b2d321a_f0723ba9",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "03fa72d2_5a4b525c",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T08:58:21Z",
      "side": 1,
      "message": "wrt complicated error handling, you just call this method to clean up the parcel, and it returns an error (which you were already going to return anyway)\nwrt doing this here and not in libbinder, I\u0027m going to investigate it in libbinder, and if I am able to add it there, I\u0027ll remove it here.",
      "parentUuid": "a87c67bf_e74d1e00",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "051ad9a3_a00bd9f0",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T09:04:14Z",
      "side": 1,
      "message": "But you will print the error message here for no reason, and EX_ILLEGAL_STATE may be different from what you want to return. For the record, I still don\u0027t think we should do this anywhere, but if we do it, libbinder is probably a better place.",
      "parentUuid": "03fa72d2_5a4b525c",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "85553b7c_e1447dbc",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T09:25:16Z",
      "side": 1,
      "message": "All current usages of AIDL/HIDL that I can think of right now assume they read the whole parcel. Requiring extra work to ignore possible errors and explicitly calling out when they want to do this is okay, especially when it\u0027s a hypothetical case (do you have an example?). This is like how a compiler throws a warning when a variable is unused. Accidentally missing information like this could cause some pretty insidious errors. The exact layout of the parcel/how it works is a blackbox to most (including myself until I started working on this). Having this notification that something is going wrong is very helpful to the developer. Since that developer is going to be me for the time being, I\u0027d prefer to keep this in for now.\n\nThere is also a more abstract motivation behind this (and part of the reason why I have hesitated to add setDataPos/getDataPos/etc...). Being able to do these things means that you can make really complicated data structures. For instance, you could design algorithms where you have to jump back and forth in the parcel to read the information. This is totally unnecessary. I don\u0027t want anyone even approaching this. Binder is already unforgiving. Even with scatter gather, you still read (therefore copy) the parcel itself serially. No craziness is necessary here. I would be pleasantly surprised to find a case where this would be justified.\n\n\u003e EX_ILLEGAL_STATE may be different from what you want to return\n\nIn this hypothetical case, they should be aware of it and can return whatever code they want choose to. Perhaps I should add something like EX_REMAINING_PARCEL_DATA? I\u0027ll look into this in b/113542980.\n\n\nI\u0027ve also noted your concerns on b/113542980#comment2.",
      "parentUuid": "051ad9a3_a00bd9f0",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4a871aa9_aaed29b3",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T11:42:48Z",
      "side": 1,
      "message": "I do agree this makes sense for auto-generated code sitting on top of this, which can\u0027t know what parts of the Parcel are relevant or not, and so has to pass everything on to the receiver. And in those cases it would probably be a bug if you don\u0027t read it all, though I think such bugs would easily be discovered (as I said, I don\u0027t recall having that issue with libbinder, but perhaps others have).\n\nI\u0027m more worried about manual use in the NDK, where you can couple the data in the Parcel with local state; for example, let\u0027s say you ask another process about meta-data for something which is identified by some integer; then when you get the return Parcel, you could read that integer first, and depending on the value and your current state, you may not care about reading the rest of the Parcel. Then being forced to call a setDataPos() API to prevent an unrecoverable error here is unfortunate.\n\nIn the end how you interpret the contents of the Parcel and whether you need all of it is out-of-scope for this library, which is just concerned with reading/writing it and sending it over binder.\n\nPerhaps a flag or another way to indicate that you want this, and not enable it by default? Or, offer a dataRemaining() API for auto-gen code to use to ensure it read it all?\n\nI\u0027d also be curious to know what others think about this.",
      "parentUuid": "85553b7c_e1447dbc",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4f138a63_5ad78207",
        "filename": "libs/binder/ndk/AIBinder.cpp",
        "patchSetId": 29
      },
      "lineNbr": 321,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T11:48:53Z",
      "side": 1,
      "message": "I\u0027m going to follow this up in that separate bug.",
      "parentUuid": "4a871aa9_aaed29b3",
      "range": {
        "startLine": 321,
        "startChar": 4,
        "endLine": 321,
        "endChar": 35
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e7a3101d_23ebe9eb",
        "filename": "libs/binder/ndk/AServiceManager.cpp",
        "patchSetId": 29
      },
      "lineNbr": 44,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T07:40:25Z",
      "side": 1,
      "message": "I guess this is the place where you can wrap a ABBinder with ABpBinder. So I guess what you really want to do here is verify that this is an AIBinder; and if it is, you can check if it\u0027s remote, and then return a proxy, or otherwise just return the object. If it\u0027s not an AIBinder, I guess you can\u0027t use it (unless we find some way to deal with that...).\n\nFor now I guess you could also just assume this is an AIBinder, use isRemote() to determine if it\u0027s a proxy or not, and then forget about the wrapping case. You anyway don\u0027t deal with the fact that this could be another object in this PS, so why wrap it. But up to you.",
      "range": {
        "startLine": 44,
        "startChar": 20,
        "endLine": 44,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "a20af5a1_d3424c81",
        "filename": "libs/binder/ndk/AServiceManager.cpp",
        "patchSetId": 29
      },
      "lineNbr": 44,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T08:00:43Z",
      "side": 1,
      "message": "You\u0027re allowed to use AServiceManager_getService if you\u0027re using this library in any context that is not an app. If this library is loaded into a process that has already pulled in another service using libbinder, then calling getService on that service will give you a subclass of BpInterface. So, I can\u0027t make that assumption here.\n\nAlso, I did try using attachObject on IBinder to make this distinction in this place a couple of days ago. I got it to work (some minor problems, maybe in my attempt), but that API isn\u0027t well tested and is a bit hairy. Once I have a chance to look into this more, I\u0027ll fix interactions between this and libbinder (and also HIDL as well). This would also mean simplifying AIBinder_associateClass.",
      "parentUuid": "e7a3101d_23ebe9eb",
      "range": {
        "startLine": 44,
        "startChar": 20,
        "endLine": 44,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "b747afba_108f3476",
        "filename": "libs/binder/ndk/AServiceManager.cpp",
        "patchSetId": 29
      },
      "lineNbr": 44,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T08:54:31Z",
      "side": 1,
      "message": "I\u0027m trying to say, why not use binder-\u003eremoteBinder() to determine if this is remote or not? Wrapping a local object in a proxy is never the right thing to do, independent of how we solve the problem of binder NDK vs libbinder objects.",
      "parentUuid": "a20af5a1_d3424c81",
      "range": {
        "startLine": 44,
        "startChar": 20,
        "endLine": 44,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "f329f4ce_a5c9c3ad",
        "filename": "libs/binder/ndk/AServiceManager.cpp",
        "patchSetId": 29
      },
      "lineNbr": 44,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T08:58:21Z",
      "side": 1,
      "message": "If it is local, it may be an instance of *BnInterface (I said BpInterface before incorrectly). I can\u0027t cast a BnInterface object to an ABBinder object.",
      "parentUuid": "b747afba_108f3476",
      "range": {
        "startLine": 44,
        "startChar": 20,
        "endLine": 44,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "38d14a35_5b930b76",
        "filename": "libs/binder/ndk/AServiceManager.cpp",
        "patchSetId": 29
      },
      "lineNbr": 44,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T09:04:14Z",
      "side": 1,
      "message": "No, but could you do the descriptor checking similar to what you do in AIBinder::attachClass() here, and return nullptr if it fails? It just seems wrong to wrap this in a proxy class just to be able to do sanity checking later, and then unpack it back to a ABBinder.",
      "parentUuid": "f329f4ce_a5c9c3ad",
      "range": {
        "startLine": 44,
        "startChar": 20,
        "endLine": 44,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "d5864068_d8f9a0d8",
        "filename": "libs/binder/ndk/AServiceManager.cpp",
        "patchSetId": 29
      },
      "lineNbr": 44,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T09:25:16Z",
      "side": 1,
      "message": "You\u0027re assuming that a given AIDL interface will only ever use libbinder or only ever use libbinder_ndk (that it won\u0027t support both). That is TBD. We can do this in a completely memory safe way by tagging the base object (IBinder). That seems like the right solution to me in general, so there is no reason to even allow accidentally collisions of descriptors in the same process.",
      "parentUuid": "38d14a35_5b930b76",
      "range": {
        "startLine": 44,
        "startChar": 20,
        "endLine": 44,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "103e8b83_2244b432",
        "filename": "libs/binder/ndk/AServiceManager.cpp",
        "patchSetId": 29
      },
      "lineNbr": 44,
      "author": {
        "id": 1013030
      },
      "writtenOn": "2018-08-30T11:42:48Z",
      "side": 1,
      "message": "No, this PS is assuming that if it receives an IBinder, and its interface descriptor matches the one that you pass into AIBinder::associateClass(), then that it must be an AIBinder object. It\u0027s TBD whether that logic will suffice, and I\u0027m fine ignoring that for now. But my point is that that logic doesn\u0027t belong in the proxy class. You shouldn\u0027t have to instantiate an ABpBinder to determine if something is really an ABpBinder or in fact a ABBinder.",
      "parentUuid": "d5864068_d8f9a0d8",
      "range": {
        "startLine": 44,
        "startChar": 20,
        "endLine": 44,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "4986f7e2_bd3084c6",
        "filename": "libs/binder/ndk/AServiceManager.cpp",
        "patchSetId": 29
      },
      "lineNbr": 44,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-08-30T11:48:53Z",
      "side": 1,
      "message": "It checks pointer equality on the class object, not just descriptor equality. Like I said, I already have a plan for fixing this to avoid having to create this here, but this CL is already too big. For now, it\u0027s accurate with what it has got.\n\nhttps://android-review.googlesource.com/c/platform/frameworks/native/+/735505/29/libs/binder/ndk/AIBinder.cpp#44",
      "parentUuid": "103e8b83_2244b432",
      "range": {
        "startLine": 44,
        "startChar": 20,
        "endLine": 44,
        "endChar": 42
      },
      "revId": "3a84657c9c0a008319c7c10e21e36ced9cfc9633",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}