{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "744f64ed_3f39d9bd",
        "filename": "libs/binder/tests/binderRpcTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1493,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-06-30T00:50:08Z",
      "side": 1,
      "message": "do we need to poll? Can we directly try calling accept4? I feel we should be able to call it directly or avoid needing this much code? Is it all really needed to detect this working?",
      "range": {
        "startLine": 1493,
        "startChar": 37,
        "endLine": 1493,
        "endChar": 41
      },
      "revId": "626ad2fdf84b69c71df5be9ca45d7e50ae639b73",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "37993984_e9f65b75",
        "filename": "libs/binder/tests/binderRpcTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1493,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-06-30T01:00:26Z",
      "side": 1,
      "message": "From `man accept4`:\n```\n       If no pending connections are present on the queue, and the socket is not marked as nonblocking, accept() blocks the caller until a connection  is  present.   If the socket is marked nonblocking and no pending connections are present on the queue, accept() fails with the error EAGAIN or EWOULDBLOCK.\n```\n\nI don\u0027t think either one of those works for us. A blocking `accept4` would block indefinitely if the client is unable to connect, while a non-blocking one might race with `connect` and return `EWOULDBLOCK`. In the latter case, we could loop without polling but then we\u0027d just be calling `accept4` and `getsockopt` over and over. Is there some other way we could make it work?",
      "parentUuid": "744f64ed_3f39d9bd",
      "range": {
        "startLine": 1493,
        "startChar": 37,
        "endLine": 1493,
        "endChar": 41
      },
      "revId": "626ad2fdf84b69c71df5be9ca45d7e50ae639b73",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4cbf7067_3cffc21c",
        "filename": "libs/binder/tests/binderRpcTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1493,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-06-30T20:36:31Z",
      "side": 1,
      "message": "I was going to suggest using SOCK_DGRAM instead (just need: socket -\u003e sendto self -\u003e recvfrom self), but from a quick search, dgram support in vsock might have been added after VMADDR_CID_LOCAL support, so we might lose test coverage. Unclear to me if that matters.\n\nbtw is there an easy way to run the test in env where this returns false?",
      "parentUuid": "37993984_e9f65b75",
      "range": {
        "startLine": 1493,
        "startChar": 37,
        "endLine": 1493,
        "endChar": 41
      },
      "revId": "626ad2fdf84b69c71df5be9ca45d7e50ae639b73",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3a532c42_6575ebd3",
        "filename": "libs/binder/tests/binderRpcTest.cpp",
        "patchSetId": 6
      },
      "lineNbr": 1493,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2022-06-30T20:55:44Z",
      "side": 1,
      "message": "\u003e btw is there an easy way to run the test in env where this returns false?\n\nThe tests that were failing do exactly that: run on an Android 11 image with a 5.4 kernel. There\u0027s an acloud command you can use to replicate the setup.",
      "parentUuid": "4cbf7067_3cffc21c",
      "range": {
        "startLine": 1493,
        "startChar": 37,
        "endLine": 1493,
        "endChar": 41
      },
      "revId": "626ad2fdf84b69c71df5be9ca45d7e50ae639b73",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}