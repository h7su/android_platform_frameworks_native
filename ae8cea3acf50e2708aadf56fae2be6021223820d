{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "949fb0a5_fefc80e8",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2024-03-08T02:06:21Z",
      "side": 1,
      "message": "Armelle, is this still required after we discussed everything would be moved on system during AVF summit?",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3074cac3_842f1829",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-03-11T00:30:40Z",
      "side": 1,
      "message": "+1\n\nAlso, even for the vendor VMs, wouldn\u0027t it be better to extend libbinder_ndk to have more APIs, instead of making a copy of it (libbinder_ndk_vendor) in the vendor partition?",
      "parentUuid": "949fb0a5_fefc80e8",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ff2f028_a95b297e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1856745
      },
      "writtenOn": "2024-03-20T00:57:06Z",
      "side": 1,
      "message": "This is still needed outside of the VM case.\nA vendor client (e.g. Android HAL implementation) written in Rust, interacting with a TEE via Binder RPC, mandates the AIDL Rust backend support in the vendor image (and thus that the AIDL NDK backend be used in the vendor image).",
      "parentUuid": "3074cac3_842f1829",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5afb509_3f793e70",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2024-03-20T01:02:44Z",
      "side": 1,
      "message": "Will TEE switch to FFA first?",
      "parentUuid": "2ff2f028_a95b297e",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "522ca4f6_c6c01294",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-03-20T03:48:15Z",
      "side": 1,
      "message": "My comment (after the \"Also,\" part) was actually a question towards Steven.",
      "parentUuid": "e5afb509_3f793e70",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9833a5e1_5bd54229",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2024-03-21T19:34:30Z",
      "side": 1,
      "message": "We don\u0027t want to add APIs at the transport level into libbinder_ndk (we want high-level service management APIs only). Trusty needs to use the vendor-specific libbinder_trusty library today. So that\u0027s why a vendor copy would be needed - in order to allow vendor to plug libbinder_trusty in without exposing such low-level APIs we can\u0027t commit to.",
      "parentUuid": "522ca4f6_c6c01294",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8cd6938b_2a3a6418",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-03-22T00:43:10Z",
      "side": 1,
      "message": "Let\u0027s forget about Trusty for now. Easier example: RPC binder.\n\nThe transport is set up by libbinder_rpc_unstable. It internally uses libbinder_ndk, but libbinder as well. It\u0027s not available to the vendor partition either.\n\nMy ask is to make the library (1) available outside of the system partition, and (2) drop the dependency to libbinder.\n\nIs this feasible?",
      "parentUuid": "9833a5e1_5bd54229",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e04e2bf6_1bfd1b8d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2024-03-22T00:59:05Z",
      "side": 1,
      "message": "Trusty uses RPC binder, and the only reason to have libbinder_ndk_vendor would be to support the Trusty hardware-specific backend to RPC binder.\n\nI\u0027m not sure which library you\u0027re talking about that should be available outside of the system partition that should also drop the dependency to libbinder, but it\u0027s infeasible for both libbinder_rpc_unstable and libbinder_ndk.",
      "parentUuid": "8cd6938b_2a3a6418",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f02ff540_122c2d5b",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-03-22T01:37:01Z",
      "side": 1,
      "message": "I am talking about libbinder_rpc_unstable. To be clear, I want below, and it it\u0027s impossible want to understand why.\n\n```\ncc_library {\n    name: \"libbinder_rpc_unstable\",\n    vendor_available: true,\n    shared_libs: [\"libbinder_ndk\"], // no libbinder here\n}\n```\n\nor\n\n```\ncc_library {\n    name: \"libbinder_rpc_unstable\", // drop _unstable if possible\n    llndk: {\n        symbol_file: \"libbinder_rpc.map.txt\",\n    }\n    shared_libs: [\"libbinder_ndk\", \"libbinder\", ...], // libbinder can be here.\n }\n ```",
      "parentUuid": "e04e2bf6_1bfd1b8d",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7bae3ccb_18580837",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2024-03-22T19:16:05Z",
      "side": 1,
      "message": "The reason is because RpcServer API is intentionally not in libbinder_ndk, so it\u0027s intentionally not possible to use RPC binder from libbinder_ndk alone. I also don\u0027t want to add additional platform symbols into libbinder_ndk due to b/136506169.\n\nYou and I have talked about this a lot in various other threads actually.\n\nAnyway, I\u0027ve just kicked off the project to resolve this and standardize APIs to use RPC binder. Meeting with Alice and Devin Monday, and we should share a proposal soon so we can stabilize *high level* APIs to use RPC binder services.\n\nHowever, we still will NOT create a stable RpcTransport API. So, we still need TIPC-\u003eFFA/VSOCK/equivalent before these would work for Trusty.\n\n\u003e A vendor client (e.g. Android HAL implementation) written in Rust, interacting with a TEE via Binder RPC\n\nSo to clarify, the way we\u0027d like to support this is with FFA/VSOCK in libbinder and high-level stable APIs in libbinder_ndk to use these services. This patch should still only be required because TIPC is unstable.",
      "parentUuid": "f02ff540_122c2d5b",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0b01d6f9_9c238774",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2024-03-23T06:23:02Z",
      "side": 1,
      "message": "Your answer doesn\u0027t seem to explain why the LLNDK path (the second suggestion in my last comment) cannot be taken. Could you explain?\n\n\u003e the project to resolve this and standardize APIs to use RPC binder\n\nCool.\n\n\u003e we still will NOT create a stable RpcTransport API \n\nWhy?\n\n\u003e with FFA/VSOCK in libbinder\n\nCan that APIs be in an LLNDK library?",
      "parentUuid": "7bae3ccb_18580837",
      "revId": "ae8cea3acf50e2708aadf56fae2be6021223820d",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}