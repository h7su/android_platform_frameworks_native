{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "98015847_9feb417d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-05T20:38:58Z",
      "side": 1,
      "message": "Er, is the aim to support non-blocking sockets or not? The other thread suggested yes. If you don\u0027t need it, including features like this (especially without tests!) that may not actually work seems not great. It\u0027s also a bit more complex than this CL suggests. (See comments.)",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "615201c6_4d6fd517",
        "filename": "/COMMIT_MSG",
        "patchSetId": 3
      },
      "lineNbr": 21,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-05T21:20:16Z",
      "side": 1,
      "message": "The final state is to have non-blocking sockets. But this CL doesn\u0027t actually enable it yet. \n\nI\u0027ll turn sockets into non-blocking in the next patchset (fix b/195683291)",
      "parentUuid": "98015847_9feb417d",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "351fb65f_0501b76d",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 3
      },
      "lineNbr": 0,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-05T23:09:11Z",
      "side": 1,
      "message": "Thanks David for your thorough review!\n\nLooks like I\u0027ll have to turn to non-blocking sockets (b/195683291) before adjusting these CLs. And when we settle on non-blocking sockets, I think this CL should be squashed into CL:1745081.\n\nI\u0027ll set these CLs as WIP, and I\u0027ll let you know when these CLs are ready for review.",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d53e2ce_84a26b9d",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 198,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-05T20:38:58Z",
      "side": 1,
      "message": "This is a little subtle. WANT_WRITE and WANT_READ are not telling you what function you called, but what function the TLS library called. That is, if SSL_write was blocking on a BIO_read, it\u0027ll tell you SSL_ERROR_WANT_READ and you need to listen for POLLIN. Conversely, if SSL_read was blocking on BIO_write, it\u0027ll tell you SSL_ERROR_WANT_WRITE, and you need to listen on POLLOUT.\n\nThere are edge cases in the TLS protocol where this is possible. In practice, almost no one gets this right, so we try to avoid unusual I/O patterns where possible, largely by forbidden certain features.\n\n*IF* you call the handshake first *AND* you don\u0027t enable any interesting features like 0-RTT or TLS 1.2 renegotiation, I believe you\u0027ll never run into this. However, if you ever do enable those features, this API will need to report something more complex to capture this. (Probably worth a comment here that you\u0027re assuming this.)",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "272cb833_343c20fa",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 198,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-05T21:20:16Z",
      "side": 1,
      "message": "Thanks for the info, this is very helpful!\n\nThe easiest would be to assume I don\u0027t use these features. Let me confirm the following:\n\n\u003e *IF* you call the handshake first\n\nThat means SSL_do_handshake(), right? If so I can ensure this always happens before this code is hit.\n\n\u003e 0-RTT\n\u003e TLS 1.2 renegotiation\n\nI did set minimum TLS version 1.3. Would that enable 0-RTT by default? Or does that need to be manually configured?\n\n--------\n\nI want to get this right. I do not want to make assumptions that may be violated if another developer or I forget about them in the future.",
      "parentUuid": "4d53e2ce_84a26b9d",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7a86930_5d6953c1",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 198,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-05T21:50:59Z",
      "side": 1,
      "message": "\u003e That means SSL_do_handshake(), right?\n\nThat\u0027s right.\n\n\u003e I did set minimum TLS version 1.3. Would that enable 0-RTT by default? Or does that need to be manually configured?\n\nThat needs to be manually configured, so you\u0027re fine.",
      "parentUuid": "272cb833_343c20fa",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "983de77c_b5337291",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 249,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-05T21:20:16Z",
      "side": 1,
      "message": "https://android-review.googlesource.com/c/platform/frameworks/native/+/1745081/28/libs/binder/RpcTransportTls.cpp#179\n\nDavid, I shouldn\u0027t handle SSL_ERROR_WANT_WRITE here, right?",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ae7ca575_d7ac227c",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 249,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-05T21:50:59Z",
      "side": 1,
      "message": "This is the same story as SSL_read. Your code is currently making a technically invalid assumption that you probably can get away with. Specifically, you\u0027re assuming that TLS reads only call transport reads and TLS writes only call transport writes. (Actually this is extremely false due to alerts, but retries and alerts already don\u0027t work particularly well.)\n\nThis is a question of API contracts. Right now, your public API is that you return Error(EWOULDBLOCK) if you need a retry, and the caller determines POLLIN vs POLLOUT based on what operation they were doing.\n\nThat API *does not work* for TLS in general. It is incapable of capturing when RpcTransportTls::recv needs POLLOUT, or RpcTransportTls::send needs POLLIN. In order to capture that, you need the return value to tell you which you want. Your options are:\n\n1. Change the API so the return value captures POLLIN/POLLOUT. Handle both WANT_READ and WANT_WRITE out of every operation.\n\n2. Leave the API as-is and make this assumption. This may constrain you in the future as you try to add new features or as the protocol develops, because you will be unable to handle certain kinds of protocol flows. If you pick this option, you cannot check WANT_WRITE in RpcTransportTls::recv because there is no way to tell the caller about it.",
      "parentUuid": "983de77c_b5337291",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "43de441f_169daf18",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 249,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-05T23:09:11Z",
      "side": 1,
      "message": "Understood! I\u0027ll handle both of them.",
      "parentUuid": "ae7ca575_d7ac227c",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2c7e38e5_c649f940",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 278,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-05T20:38:58Z",
      "side": 1,
      "message": "This loop isn\u0027t right. If the socket is blocking, you\u0027ll never need to loop around. The I/O will block. If the socket is non-blocking, looping back around won\u0027t help because you have to wait for the data to come back, by integrating into the caller\u0027s poll() machinery.",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "48d4d2d3_e29fbf6f",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 278,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-05T21:20:16Z",
      "side": 1,
      "message": "As of now, caller doesn\u0027t have a poll() loop.\n\nLet me do a poll loop with some timeout here. (Steven, please ACK)",
      "parentUuid": "2c7e38e5_c649f940",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1175dc3_19afbc8b",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 278,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-05T21:50:59Z",
      "side": 1,
      "message": "Note if you do a poll loop here, that means you\u0027re doing blocking handshakes but non-blocking reads and writes. This is a little strange because it means the caller still can\u0027t use your library on an interactive thread. Is that the goal?",
      "parentUuid": "48d4d2d3_e29fbf6f",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8809c7e8_37d8a5fe",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 278,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-05T23:09:11Z",
      "side": 1,
      "message": "You are right. I\u0027ll move the poll loop to the caller.",
      "parentUuid": "c1175dc3_19afbc8b",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "edf59ba4_e1acf13b",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-05T20:38:58Z",
      "side": 1,
      "message": "These will never happen and only come up if the underlying BIO sets a BIO_RR_CONNECT or BIO_RR_ACCEPT retry reason. You all don\u0027t.\n\nWhat *will* happen is SSL_ERROR_WANT_READ and SSL_ERROR_WANT_WRITE. You can get either one out of this function, depending on whether you\u0027re blocked on reading or writing to the socket. The error code doesn\u0027t tell you the function (you presumably know that), but the underlying operation that it was blocked on.",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3b41aaf1_246b093d",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-05T21:20:16Z",
      "side": 1,
      "message": "Understood. I\u0027ll change them to READ and WRITE.",
      "parentUuid": "edf59ba4_e1acf13b",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c0ff906a_bb142ada",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 3
      },
      "lineNbr": 285,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-05T21:50:59Z",
      "side": 1,
      "message": "Note READ and WRITE mean different things. For READ, you need to tell the poll loop to listen for POLLIN and for WRITE, you need to tell the poll loop to listen for POLLOUT.\n\nThis connects to the other two comments:\n\n- Do you want to block the calling thread on handshake? If yes, your API is partially blocking. If no, you need to report WANT_READ and WANT_WRITE to the caller and define how to retry.\n\n- If you report WANT_READ and WANT_WRITE to the caller, your result type needs to be rich enough to express this. See the recv/send/peek comments.",
      "parentUuid": "3b41aaf1_246b093d",
      "revId": "f7c96424889c21538d19fed25dd7f5b4eb99dca1",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}