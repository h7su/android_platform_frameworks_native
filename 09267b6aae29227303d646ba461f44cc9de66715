{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "6f8cace8_05fa838e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-12-11T04:26:21Z",
      "side": 1,
      "message": "Algorithm LGTM!",
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0a447c45_3e560848",
        "filename": "libs/binder/RpcState.cpp",
        "patchSetId": 4
      },
      "lineNbr": 327,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-12-11T04:26:21Z",
      "side": 1,
      "message": "nit: In the current implementation, I don\u0027t think this applies any more, since you are not calling interruptableWriteFully with size, but with the full iov.",
      "range": {
        "startLine": 322,
        "startChar": 0,
        "endLine": 327,
        "endChar": 0
      },
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c7257a19_3fd82c15",
        "filename": "libs/binder/RpcTransportRaw.cpp",
        "patchSetId": 4
      },
      "lineNbr": 61,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-12-11T04:26:21Z",
      "side": 1,
      "message": "const struct iovec\u0026 ?",
      "range": {
        "startLine": 61,
        "startChar": 24,
        "endLine": 61,
        "endChar": 36
      },
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3fada229_79d43a21",
        "filename": "libs/binder/RpcTransportRaw.cpp",
        "patchSetId": 4
      },
      "lineNbr": 72,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-12-11T03:36:17Z",
      "side": 1,
      "message": "The other benefit of this change: this is also the API for sending file descriptors over UNIX sockets (the ancillary data in msg_control can contain fds).",
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a8fb1291_2be18c23",
        "filename": "libs/binder/RpcTransportRaw.cpp",
        "patchSetId": 4
      },
      "lineNbr": 83,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-12-11T04:26:21Z",
      "side": 1,
      "message": "nit: Is this necessary? havePolled will always be false when we reach here. (I know it is from L147)",
      "range": {
        "startLine": 83,
        "startChar": 21,
        "endLine": 83,
        "endChar": 32
      },
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "437a2fdd_673946f2",
        "filename": "libs/binder/RpcTransportRaw.cpp",
        "patchSetId": 4
      },
      "lineNbr": 90,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-12-11T04:26:21Z",
      "side": 1,
      "message": "nit: this will never happen in practice, but from a static-analysis point of view, iovIdx could exceed the size of the vector\n\n```\nwhile (processSize \u003e 0 \u0026\u0026 iovIdx \u003c iovCopy.size())\n```",
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1d3f4c3f_23f32582",
        "filename": "libs/binder/RpcTransportRaw.cpp",
        "patchSetId": 4
      },
      "lineNbr": 103,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-12-11T04:26:21Z",
      "side": 1,
      "message": "nit: \u003e\u003d (I know \u003e wouldn\u0027t happen in practice, but still)",
      "range": {
        "startLine": 103,
        "startChar": 27,
        "endLine": 103,
        "endChar": 29
      },
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b45976db_0bd89db0",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 4
      },
      "lineNbr": 318,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-12-11T04:26:21Z",
      "side": 1,
      "message": "nit: IMHO, the following would be a bit more readable, because you don\u0027t need the extra 3 variables.\n\n```\n    MAYBE_WAIT_IN_FLAKE_MODE;\n\n    // Before doing any I/O, check trigger once. This ensures the trigger is checked at least\n    // once. The trigger is also checked via triggerablePoll() after every SSL_write().\n    if (fdTrigger-\u003eisTriggered()) return DEAD_OBJECT;\n\n    for (const auto\u0026 e : iov) {\n        // The following can even be in its own function\n        auto buffer \u003d reinterpret_cast\u003cconst uint8_t*\u003e(e.iov_base);\n        const uint8_t* end \u003d buffer + e.iov_len;\n        while (buffer \u003c end) {\n            // existing code\n        }\n    }\n    LOG_TLS_DETAIL(\"TLS: Sent %zu bytes!\", size);\n    return OK;\n```",
      "range": {
        "startLine": 315,
        "startChar": 0,
        "endLine": 318,
        "endChar": 33
      },
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e67f921a_33bd27b5",
        "filename": "libs/binder/include/binder/RpcTransport.h",
        "patchSetId": 4
      },
      "lineNbr": 58,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-12-11T04:26:21Z",
      "side": 1,
      "message": "not needed in C++ (same everywhere)",
      "range": {
        "startLine": 58,
        "startChar": 52,
        "endLine": 58,
        "endChar": 58
      },
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "66799525_73686e49",
        "filename": "libs/binder/include/binder/RpcTransport.h",
        "patchSetId": 4
      },
      "lineNbr": 58,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-12-11T04:26:21Z",
      "side": 1,
      "message": "I assume this CL addresses performance, and the purpose is to eliminate data copy. However, every std::vector you create adds a memory allocation.\n\nSome alternatives to consider:\n\n- std::span. However, it doesn\u0027t exist yet. So maybe write a simple replacement of it, e.g.:\n```\nstruct IovecList {\n    iovec* head;\n    size_t len;\n}\nstatus_t interruptableWriteFully(FdTrigger*, IovecList iov)\n```\n\n- replace with iovec* iov, size_t len\n\nAlso, maybe keep the original interruptableWriteFully(void*, size_t) API for \"simple\" (single-buffer) writes, which happens in many places in the library. It can call the iovec overload internally but shortcut some std::vector allocations.",
      "range": {
        "startLine": 58,
        "startChar": 40,
        "endLine": 58,
        "endChar": 52
      },
      "revId": "09267b6aae29227303d646ba461f44cc9de66715",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}