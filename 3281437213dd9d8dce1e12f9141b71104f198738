{
  "comments": [
    {
      "key": {
        "uuid": "f9a14e19_709a5004",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 4
      },
      "lineNbr": 348,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-16T00:41:20Z",
      "side": 1,
      "message": "Binder/interface objects are always nullable in the C++/NDK backends, right?",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 348,
        "endChar": 58
      },
      "revId": "3281437213dd9d8dce1e12f9141b71104f198738",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7a31a095_2a96076c",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 4
      },
      "lineNbr": 348,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-09-16T04:18:42Z",
      "side": 1,
      "message": "I believe in AIDL they are always nullable, so I don\u0027t think we use this impl from the AIDL backend.\n\nThe C++ libbinder allows null binders in both the nullable and \"non-nullable\" read methods. I don\u0027t think we should carry that historical idiosyncrasy over into Rust, where SpIBinder is always non-null and the nullable binder type is Option\u003cSpIBinder\u003e (plus it doesn\u0027t match the other nullable/required interface splits). We can remove this impl entirely if you\u0027d prefer, but I\u0027m not sure there\u0027s much to gain by that.",
      "parentUuid": "f9a14e19_709a5004",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 348,
        "endChar": 58
      },
      "revId": "3281437213dd9d8dce1e12f9141b71104f198738",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f1487bf8_4aa21055",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 4
      },
      "lineNbr": 348,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-09-16T04:23:01Z",
      "side": 1,
      "message": "Correction after running this by Andrei, I was hasty. We do use the non-nullable version for IBinder, which is non-nullable by default in AIDL. The C++ AIDL backend does the check for null after calling readStrongBinder(), and this change just lets us put that check in the library, where it belongs.",
      "parentUuid": "7a31a095_2a96076c",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 348,
        "endChar": 58
      },
      "revId": "3281437213dd9d8dce1e12f9141b71104f198738",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8906aaa3_a1a9e621",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 4
      },
      "lineNbr": 348,
      "author": {
        "id": 1638873
      },
      "writtenOn": "2020-09-16T04:38:38Z",
      "side": 1,
      "message": "Expanding on the previous comment: in C++ sp\u003c\u003e is implicitly nullable, but the parcel code provides both readStrongBinder (which checks for null and returns UNEXPECTED_NULL like here) and readNullableStrongBinder, and the AIDL compiler uses both depending on whether the AIDL IBinder is nullable or not.",
      "parentUuid": "f1487bf8_4aa21055",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 348,
        "endChar": 58
      },
      "revId": "3281437213dd9d8dce1e12f9141b71104f198738",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a618c9db_989e66f9",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 4
      },
      "lineNbr": 348,
      "author": {
        "id": 1638873
      },
      "writtenOn": "2020-09-16T04:54:32Z",
      "side": 1,
      "message": "Expanding a bit more: there\u0027s a test for this exact case in the C++ tests:\n```\nTEST_F(AidlTest, nullBinder) {\n  auto status \u003d service-\u003eTakesAnIBinder(nullptr);\n  ASSERT_THAT(status.exceptionCode(), Eq(android::binder::Status::EX_NULL_POINTER));\n}\n```",
      "parentUuid": "8906aaa3_a1a9e621",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 348,
        "endChar": 58
      },
      "revId": "3281437213dd9d8dce1e12f9141b71104f198738",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "38313b00_e5a18c50",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 4
      },
      "lineNbr": 348,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-16T23:52:54Z",
      "side": 1,
      "message": "Ah but do notice nullInterface case as well. So, the behavior is that IBinder respects @nullable, but interface doesn\u0027t. I have confirmed that C++ behavior is the same in the NDK backend: https://android-review.googlesource.com/c/platform/cts/+/1428810\n\n\u003e I don\u0027t think we should carry that historical idiosyncrasy over into Rust\n\nI think we\u0027re good in this case, but in general, it would mean that you have to modify the interface in order to start using it in Rust. Ideally, we can avoid having that requirement.",
      "parentUuid": "a618c9db_989e66f9",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 348,
        "endChar": 58
      },
      "revId": "3281437213dd9d8dce1e12f9141b71104f198738",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "72d37366_1aa0b2ca",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 4
      },
      "lineNbr": 348,
      "author": {
        "id": 1638873
      },
      "writtenOn": "2020-09-17T00:59:33Z",
      "side": 1,
      "message": "In that case, I think we have 2 options:\n1) make the AIDL compiler emit Option\u003cSpIBinder\u003e even for non-nullable IBinder, or\n2) change the internals of SpIBinder in libbinder_rs so that it\u0027s always nullable.\n\nThe first option is simpler to implement, but might make it difficult to preserve the behavior of the test above: return UNEXPECTED_NULL for uninitialized non-nullable IBinders.",
      "parentUuid": "38313b00_e5a18c50",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 348,
        "endChar": 58
      },
      "revId": "3281437213dd9d8dce1e12f9141b71104f198738",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2afe34f6_3e0e27df",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 4
      },
      "lineNbr": 348,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-17T01:14:50Z",
      "side": 1,
      "message": "Wait - IBinder respects @nullable, yeah. Is the problem that rust interface parceling use this same method to write binders?",
      "parentUuid": "72d37366_1aa0b2ca",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 348,
        "endChar": 58
      },
      "revId": "3281437213dd9d8dce1e12f9141b71104f198738",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e8c4054b_6fe26396",
        "filename": "libs/binder/rust/src/proxy.rs",
        "patchSetId": 4
      },
      "lineNbr": 348,
      "author": {
        "id": 1638873
      },
      "writtenOn": "2020-09-17T02:54:46Z",
      "side": 1,
      "message": "\u003e  Is the problem that rust interface parceling use this same method to write binders?\n\nIf I understand your question correctly, the answer is no, but something similar. We use Parcel::read() and Parcel::write() for all parceling operations in the AIDL compiler, which are generic functions over the type of the parcelable value, and we rely on Rust\u0027s type system to pick the right implementation depending on the type parameter.\n\nWe currently distinguish between SpIBinder and Option\u003cSpIBinder\u003e and provide different parceling functions for the two types. By changing the AIDL compiler to emit Option\u003cSpIBinder\u003e for non-nullable IBinder, both non-nullable and nullable IBinder reads would call the same function and we wouldn\u0027t be able to distinguish between the two kinds.",
      "parentUuid": "2afe34f6_3e0e27df",
      "range": {
        "startLine": 348,
        "startChar": 0,
        "endLine": 348,
        "endChar": 58
      },
      "revId": "3281437213dd9d8dce1e12f9141b71104f198738",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}