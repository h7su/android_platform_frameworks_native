{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c180c7f4_ac6dd003",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1470474
      },
      "writtenOn": "2021-11-02T15:16:00Z",
      "side": 1,
      "message": "i think we probably want to understand what fence error was resulting as well",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 14,
        "endChar": 34
      },
      "revId": "fce89c09631ee13b1356d7bb302998fcb7bb4548",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2b0525d7_0b76c719",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1902884
      },
      "writtenOn": "2021-11-03T05:31:03Z",
      "side": 1,
      "message": "Fence error results in Fence::getSignalTime returning SIGNAL_TIME_PENDING and consequently BufferLayer::latchBuffer not being able to proceed because SIGNAL_TIME_PENDING is regarded as fence not having been signaled. I think fence with an error should be treated as signaled because kernel defines this way. Please refer to dma-fence.h::dma_fence_get_status_locked. Fence::getSignalTime() connects with dma_fence_get_status_locked through libsync.\n\n * Returns 0 if the fence has not yet been signaled, 1 if the fence has\n * been signaled without an error condition, or a negative error code\n * if the fence has been completed in err.\n \nThe consequence of this is that once fence error happens (e.g., out of a GPU hang) on a particular layer, it will never have chance to be latched (unless the error is cleared) even though the whole pipeline has been restored and ready to render the subsequent frames. Since the clear of the fence error tends not to happen once the fence is signaled, it always result in the layer freezing at the last frame before the error. \n\nP.S.: Setting \"debug.sf.latch_unsignaled\" to 1 eliminates the issue but seems not a formal solution.",
      "parentUuid": "c180c7f4_ac6dd003",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 14,
        "endChar": 34
      },
      "revId": "fce89c09631ee13b1356d7bb302998fcb7bb4548",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2f37d843_4e4efce6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1470474
      },
      "writtenOn": "2021-11-10T19:32:16Z",
      "side": 1,
      "message": "I guess I meant why was the GPU emitting a fence error? I might expect a GPU hang could mean the fence is never signaled until the GPU recovers, and signal the fence with a valid timestamp afterwards",
      "parentUuid": "2b0525d7_0b76c719",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 14,
        "endChar": 34
      },
      "revId": "fce89c09631ee13b1356d7bb302998fcb7bb4548",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "f7e2490a_3bd0bb42",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 14,
      "author": {
        "id": 1902884
      },
      "writtenOn": "2021-11-12T02:42:23Z",
      "side": 1,
      "message": "Yes, the graphics driver could choose not to signal the fence in case of error e.g., GPU hang and rely upon GPU recovery completing the fence without an error. But chances are the fence will keep getting error in some cases (e.g., user commands intentionally or unintentionally cause GPU hang) and never get completed w/o an error. This might not be what we want. So another option for the GFX driver would be to skip the commands that causes the GPU hang and mark the fence as complete with an error. So essentially, the user space got a signaled fence w/ an error attached. This is exactly what we are talking about here. When Android sees a fence with an error, should it proceed with buffer latching with keeping in mind it\u0027s an error fence, or just waiting for an error being cleared which probably will never happen. \nAnd as far as I know, there is no prevention from the kernel (drm) perspective that a fence be signaled w/ an error. It sees inevitable that Android needs to tackle a fence signaled w/ an error.",
      "parentUuid": "2f37d843_4e4efce6",
      "range": {
        "startLine": 14,
        "startChar": 0,
        "endLine": 14,
        "endChar": 34
      },
      "revId": "fce89c09631ee13b1356d7bb302998fcb7bb4548",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0771b131_5edcd010",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1470474
      },
      "writtenOn": "2021-11-02T15:16:00Z",
      "side": 1,
      "message": "there should be a bug filed + tests describing how this change was tested\n\nalso this Tracked-On clause is empty so it\u0027s not meaningful",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 11
      },
      "revId": "fce89c09631ee13b1356d7bb302998fcb7bb4548",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "3c71163c_f55150ca",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 25,
      "author": {
        "id": 1902884
      },
      "writtenOn": "2021-11-03T05:31:03Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "0771b131_5edcd010",
      "range": {
        "startLine": 25,
        "startChar": 0,
        "endLine": 25,
        "endChar": 11
      },
      "revId": "fce89c09631ee13b1356d7bb302998fcb7bb4548",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}