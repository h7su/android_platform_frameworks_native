{
  "comments": [
    {
      "key": {
        "uuid": "7f6a8491_083efb01",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-04T03:45:01Z",
      "side": 1,
      "message": "I\u0027ll probably be repeating this pattern for arrays + vectors. If someone has a better suggestion, let me know.",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a1c7ca9a_227a63f4",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2018-10-04T16:36:45Z",
      "side": 1,
      "message": "The need for \u0027data\u0027 makes me uncomfortable. It looks like it is designed with std::string in mind. Also, you will be directly writing into the internal data array of std::string, which is actually breaking abstraction.\n\nIf I were you, I would like to design the API as follows:\n\nAParcel_readString(AParcel*, void (*callback)(const char*, size_t))\n\nThe callback can just point to the data on parcel without copying. The clients can then choose to use it in-place (e.g. printf) or copy it to somewhere (e.g. std::string)",
      "parentUuid": "7f6a8491_083efb01",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "2d59fd61_f1728d72",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-04T16:57:48Z",
      "side": 1,
      "message": "I\u0027ll change this to that. I like it better. Thanks!",
      "parentUuid": "a1c7ca9a_227a63f4",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "f7ec137a_9515e62a",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-04T17:19:39Z",
      "side": 1,
      "message": "Actually, I started doing this, and then I remembered why I did this convoluted way.\n\nThe NDK library needs the buffer to do the utf16_to_utf8 transformation onto. Doing it your way would require an extra copy (even though it is a cleaner API).\n\nI justify breaking into the std::string since the internal data array is guaranteed to be contiguous w/ C++11.\n\nI think I\u0027ll use your method for other data types which will never need transformations like this.\n\nAlso, with your method, I would still need a void* data. I would want something like \"AParcel_readString(AParcel*, void(*callback)(void* data, const char*, size_t), void*)\" so that the client can also pass the data structure they want to fill out to the allocator without having to deal with some global variable.\n\nAlso, it\u0027s possible to use the current API without std::string. For instance (but you can also imagine String8, std::vector, etc..):\nstatic inline char* AParcel_char_star_allocator(void* data, int32_t length) {\n    char** str \u003d static_cast\u003cchar**\u003e(data);\n    *str \u003d malloc(length * sizeof(char));\n    return *str;\n}",
      "parentUuid": "2d59fd61_f1728d72",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d16bdee7_8b2cd681",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2018-10-04T21:09:23Z",
      "side": 1,
      "message": "\u003e The NDK library needs the buffer to do the utf16_to_utf8 transformation onto.\n\nIt\u0027s a little weird to me that we aren\u0027t exposing this as a char16_t API. It might be better to perform that minimum task and handle char* and std::string conversions elsewhere. We\u0027d be able to do so with a cleaner interface anyway since the char16_t API could just report the size that it read rather than requiring that user to pass in an allocator (that is sometimes a reallocator, but might not be).",
      "parentUuid": "f7ec137a_9515e62a",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4ed1475d_5f422416",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-04T21:32:30Z",
      "side": 1,
      "message": "I\u0027ve added you guys to the original discussion in the design doc about this. The reason is that most APIs in C/C++ already work with utf8. Using utf16 will require making a copy of the string in 99% of cases, and APIs to do this aren\u0027t overly easy to use.",
      "parentUuid": "d16bdee7_8b2cd681",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "63e4901f_96907713",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2018-10-04T23:57:10Z",
      "side": 1,
      "message": "The implementation here already uses readString16InPlace and copies the result to a char* buffer. I\u0027m suggesting that make that two APIs rather than one. The actual ABI from the system would be `binder_status_t AParcel_readString16(const AParcel* parcel, char16_t** str, size_t* len)`. `str` is an out param that is allocated by the API, and len is also an out param. I was thinking we\u0027d also provide a std:;string and char* variant, they would just be implemented in terms of that rather than relying on the odd reallocator interface (the fact that the user can\u0027t just pass malloc/realloc makes me feel like we\u0027re exposing not quite the right API there).\n\n... but then I discovered that POSIX is a jerk and provides wcsrtombs, but not c16srtombs, only c16rtomb, so that would get messy fast for the C variant. The C++ variant is ugly but at least it\u0027s only a handful of lines.",
      "parentUuid": "4ed1475d_5f422416",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a27996ef_469fe962",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-05T00:11:44Z",
      "side": 1,
      "message": "readString16InPlace doesn\u0027t make a copy but gives a pointer to the kernel-owned buffer which will be invalidated when the transaction is over. Assuming I also created a nice C++ wrapper to convert utf16-\u003eutf8, readString16 would require two copies (one to copy from the binder buffer and one to convert to utf8). If I did make it AParcel_readString16, I would also need to make an AParcel_deleteString or similar API to allow the client to clean up the string when it is done. This isn\u0027t always amenable to all situations. See my reply to jreck to see my consideration of AString which would help embed the need to use this delete into the API, but that applies here as well.\n\nI agree it would be nicer that you could pass malloc/realloc directly into the API, but the primary idea is to allow the client to control the structure that the data is put into. If there is a need for it, I would be happy to add malloc/new etc.. wrapppers.",
      "parentUuid": "63e4901f_96907713",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "d7cef48f_292ce28f",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2018-10-05T17:41:52Z",
      "side": 1,
      "message": "\u003e readString16InPlace doesn\u0027t make a copy but gives a pointer to the kernel-owned buffer which will be invalidated when the transaction is over\n\nThen I\u0027m confused about the implementation here. I don\u0027t see any part of readString that signals that the transaction is over and that the buffer can be discarded. Is that a different API that you have to call after performing more reads/writes?",
      "parentUuid": "a27996ef_469fe962",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "4faa9bdd_0c54b454",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 102,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-05T18:05:19Z",
      "side": 1,
      "message": "The parcels are alive when AIBinder_Class_onTransact is called. If I give out a handle to data on the binder buffer, it will be invalidated after that method returns.",
      "parentUuid": "d7cef48f_292ce28f",
      "range": {
        "startLine": 102,
        "startChar": 0,
        "endLine": 102,
        "endChar": 70
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "12552acd_b3beb0ff",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2018-10-04T23:57:10Z",
      "side": 1,
      "message": "Regardless of how it\u0027s implemented, I\u0027m worried that the differences in naming between the NDK API and the platform API might confuse people. This reads a UTF-16 string and coverts it for you. For the platform APIs, readT reads a T and performs no conversion. It looks like there\u0027s a Parcel::readUtf8FromUtf16 that performs the operation similar to this one?",
      "range": {
        "startLine": 109,
        "startChar": 16,
        "endLine": 109,
        "endChar": 34
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5418fd7c_9df2460e",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-05T00:11:44Z",
      "side": 1,
      "message": "I\u0027m writing it to coincide with the SDK API:\nhttps://developer.android.com/reference/android/os/Parcel.html#writeString(java.lang.String)\n\nI\u0027m happy to change the name if you want, but I didn\u0027t want the client to know or care that they are writing a utf16 string. As far as I\u0027m concerned, that is an implementation detail of libbinder.",
      "parentUuid": "12552acd_b3beb0ff",
      "range": {
        "startLine": 109,
        "startChar": 16,
        "endLine": 109,
        "endChar": 34
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fdc16fbd_d15187f5",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1043845
      },
      "writtenOn": "2018-10-05T17:41:52Z",
      "side": 1,
      "message": "\u003e As far as I\u0027m concerned, that is an implementation detail of libbinder.\n\nIs it? Based on the platform\u0027s Parcel API it looks like it supports multiple types of strings, so the choice to read a UTF-16 string here is important. I\u0027m not at all familiar with these APIs though, so I could be wrong.\n\nIf I\u0027m the only one worried about this, ignore me. The other people on this review have a lot more experience with this stuff than I do.",
      "parentUuid": "5418fd7c_9df2460e",
      "range": {
        "startLine": 109,
        "startChar": 16,
        "endLine": 109,
        "endChar": 34
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "5f5c55e9_a4e3b036",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 109,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-05T18:05:19Z",
      "side": 1,
      "message": "The libbinder Parcel API allows all kinds of things to be written to it, yes, but the Parcel SDK API in Java only has \u0027read/writeString\u0027:\n\nhttps://developer.android.com/reference/android/os/Parcel\n\nFor AIDL, the exact layout of the wire protocol isn\u0027t important. For instance, I could change readString in the SDK to write a utf8 string to the wire protocol and have the NDK read it w/o conversion. I could also add a header or change the type of the header without breaking anything.\n\nUsers should never use libbinder Parcel calls directly to read things that AIDL parcels. AIDL always creates read/writes in pairs. They have flexibility in their API to write whatever to the parcels in order to support custom services and parceling of high complexity. For the NDK case, I explicitly don\u0027t want to support that in the short term. At a later date, it would be possible to add \u0027writeUtf8String\u0027 or \u0027writeUtf16String\u0027 but these would have matching read functions and they wouldn\u0027t be intended to interoperate with AIDL/Java/the read/writeString methods.",
      "parentUuid": "fdc16fbd_d15187f5",
      "range": {
        "startLine": 109,
        "startChar": 16,
        "endLine": 109,
        "endChar": 34
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "8c53b0f2_c8313d9c",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel_utils.h",
        "patchSetId": 1
      },
      "lineNbr": 24,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-04T03:59:14Z",
      "side": 1,
      "message": "also, at the api council, is there a preference for something like this to be in a namespace? In the CL after this, I\u0027m putting them in an \u0027::android\u0027 namespace",
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "bb3bff2e_69eb1fe9",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel_utils.h",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2018-10-04T16:36:45Z",
      "side": 1,
      "message": "I don\u0027t like this...",
      "range": {
        "startLine": 28,
        "startChar": 11,
        "endLine": 28,
        "endChar": 21
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "cb6c53e8_98ab30b3",
        "filename": "libs/binder/ndk/parcel.cpp",
        "patchSetId": 1
      },
      "lineNbr": 115,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2018-10-04T03:45:01Z",
      "side": 1,
      "message": "I\u0027m a little bit sad that utf16_to_utf8_length and other methods return -1 in this degenerate case. I\u0027m tempted to fix them, but it would have to be a follow-up.",
      "range": {
        "startLine": 115,
        "startChar": 8,
        "endLine": 115,
        "endChar": 17
      },
      "revId": "d636636be8a4688a337be6f882095e07f0ef04d4",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}