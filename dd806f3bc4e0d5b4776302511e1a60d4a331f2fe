{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "f9720e72_8cec9bce",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 44,
      "author": {
        "id": 1019036
      },
      "writtenOn": "2021-08-04T19:00:54Z",
      "side": 1,
      "message": "This is plausible, but odd. Generally either SIGPIPE is ignored if the application wishes, or not. It\u0027s odd for a library to squash SIGPIPE itself and override the application\u0027s wish.",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8342d190_43d50d8f",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 44,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-04T20:49:17Z",
      "side": 1,
      "message": "Here\u0027s some context:\n\nb/183141167\n\nI\u0027ll leave this to Steven to comment about why we want to intentionally ignore SIGPIPE in the library, but not at the application level.",
      "parentUuid": "f9720e72_8cec9bce",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c1a8a2b4_d685c8f5",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 44,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-04T21:03:05Z",
      "side": 1,
      "message": "I don\u0027t think ignoring SIGPIPE at the application level is an option in general for Android because of the amount of code or processes we might be intertwined with (some users of this may want it). I want this code to be non-global and self-contained, and I don\u0027t want it to be interacting w/ random other things that are using SIGPIPE.\n\n\u003e It\u0027s odd for a library to squash SIGPIPE itself and override the application\u0027s wish.\n\n:) couldn\u0027t disagree more, but I also expect I am probably missing something here. What is so great about this global signal? :)",
      "parentUuid": "8342d190_43d50d8f",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d7d54297_17de475f",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-04T19:50:48Z",
      "side": 1,
      "message": "Are you going to be doing any non-blocking I/O? If so, you need to manage retry flags (BIO_clear_retry_flags and BIO_set_retry_read/BIO_set_retry_write on check errno) on EAGAIN and probably also EINTR.\n\nDitto for send. Though, yeah, I\u0027d probably have just suppressed SIGPIPE in the application. SIGPIPE is kinda terrible and any complex application on UNIX probably wants to disable it. (It\u0027s mostly a workaround for shell utilities that forget to check the return value of write.)",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "411c09ff_5e0a65cd",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-04T20:49:17Z",
      "side": 1,
      "message": "Ooops. I\u0027ll add TEMP_FAILURE_RETRY here. Thanks for pointing this out!",
      "parentUuid": "d7d54297_17de475f",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "bbdd90ff_2d0498eb",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-04T21:03:05Z",
      "side": 1,
      "message": "All of this stuff should be non-blocking in order to hook into the polling w/ the shutdown trigger one level up.\n\n\u003e SIGPIPE is kinda terrible and any complex application on UNIX probably wants to disable it.\n\nSo, specifically, I don\u0027t want to be concerned if some utility or application is already using SIGPIPE, I don\u0027t want to have to rewrite that utility in order to make it work with this library.",
      "parentUuid": "411c09ff_5e0a65cd",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "68186345_90d433f6",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-04T21:10:18Z",
      "side": 1,
      "message": "SIGPIPE\u0027s only purpose in life is to kill the process if any writes ever fail, on the assumption that the caller forgot to check the result. It\u0027s so a buggy implementation of cat in:\n\n    cat very_large_file | head\n\nwill eventually exit when head closes the pipe. It\u0027s basically a workaround for early UNIX programs failing to check write() errors. Had cat checked write() errors, it would have worked just fine. Now it\u0027s just some ridiculous thing we have to turn off in every complex UNIX program, just like exiting \"real mode\" in an x86 processor.\n\n(There isn\u0027t even a standard way in POSIX to suppress it on an individual fd. MSG_NOSIGNAL is Linux-only, meanwhile macOS has some option you set on the fd, if I recall.)",
      "parentUuid": "bbdd90ff_2d0498eb",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ab773869_da1cad53",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1019036
      },
      "writtenOn": "2021-08-04T21:14:31Z",
      "side": 1,
      "message": "\u003e meanwhile macOS has some option you set on the fd, if I recall.\n\nSO_NOSIGPIPE, which of course isn\u0027t supported on Linux.",
      "parentUuid": "68186345_90d433f6",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "1bd3679d_5d8bfd47",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-04T22:34:04Z",
      "side": 1,
      "message": "To David\u0027s original comment:\n\n\u003e Are you going to be doing any non-blocking I/O?\n\nYes.\n\nI double checked that TEMP_FAILURE_RETRY only handles EINTR, while for non-blocking I/O, EAGAIN / EWOULDBLOCK is used instead.\n\nIn our design, EAGAIN / EWOULDBLOCK would be handled by the caller, not here. This is intended to replace\n\n```\nTEMP_FAILURE_RETRY(::send())\n```\n\nlike RpcTransportRaw::send(): https://android-review.googlesource.com/c/platform/frameworks/native/+/1751000/18/libs/binder/RpcTransportRaw.cpp#36\n\nSo it is intentional to only handle EINTR but not EAGAIN here.\n\nIn practice, we always poll the socket until the FD is available for read / write before actually calling RpcTransportTls::send() / recv(), so we shouldn\u0027t hit EAGAIN / EWOULDBLOCK. See:\n\nhttps://android-review.googlesource.com/c/platform/frameworks/native/+/1747934/29/libs/binder/RpcSession.cpp#277\n\nAm I understanding correctly?\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\nPut it in another way, could the following happen?\n\n1. The application poll()s on the raw FD and see data is available\n2. It calls SSL_read(), which does some handshakes\n3. The handshakes consumes all the available data\n4. When libssl tries to read actual data, nothing is available, so it would \n  - block on a blocking socket; or\n  - return EAGAIN / EWOULDBLOCK on a non-blocking socket (assuming BIO_set_retry_read is not used).\n  \nIf so, is there an equivalent of poll() in libssl to notify an FD when actual data is available?",
      "parentUuid": "ab773869_da1cad53",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "103e67db_66d5b2ce",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1031048
      },
      "writtenOn": "2021-08-04T22:43:22Z",
      "side": 1,
      "message": "If you\u0027re doing non-blocking IO, the API contract in BIO is that you need to manage the BIO\u0027s retry flags in read and write.\n\nlibssl consumes those flags and converts them into SSL_ERROR_WANT_WRITE and SSL_ERROR_WANT_READ as appropriate. See documentation:\n\nhttps://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#SSL_read\nhttps://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#SSL_get_error\nhttps://commondatastorage.googleapis.com/chromium-boringssl-docs/ssl.h.html#SSL_ERROR_WANT_READ\n\nThis CL isn\u0027t honoring the BIO API contract, which means the APIs in libssl won\u0027t work right. If you make your own BIO, you need to fix that. If you just silence SIGPIPE, then you can use the normal socket BIO and have that handled for you.\n\n(Alas, this API is needlessly fussy. It\u0027s from OpenSSL and we\u0027ve preserved the behavior that it was.)\n\n\u003e If so, is there an equivalent of poll() in libssl to notify an FD when actual data is available?\n\nThe way this works is libssl tells you what it was blocked on, and you manage the call to poll() to retry the operation when it\u0027s ready. select/poll loops tend to be pretty global (you want to incorporate everything else your application is waiting on), so the OpenSSL/BoringSSL API expects you do that and only gives you the tools to integrate with your application\u0027s existing non-blocking I/O story.",
      "parentUuid": "1bd3679d_5d8bfd47",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "cde4e3e0_8f933fba",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-04T23:11:53Z",
      "side": 1,
      "message": "\u003e libssl consumes those flags and converts them into SSL_ERROR_WANT_WRITE and SSL_ERROR_WANT_READ as appropriate.\n\n\u003e This CL isn\u0027t honoring the BIO API contract, which means the APIs in libssl won\u0027t work right. If you make your own BIO, you need to fix that.\n\nSo IIUC:\n\nlibssl\u0027s default BIO calls BIO_set_retry_read() when EAGAIN is returned from recv() / read(). So, when I implement my own BIO, I\u0027ll need to propagate the EAGAIN to libssl\u0027s retry flag.\n\nIs this correct? So I would just do:\n\n```\nint ret \u003d TEMP_FAILURE_RETRY(recv(...)); // retries on EINTR\nif (ret \u003d\u003d -1) {\n  if (errno \u003d\u003d EAGAIN || errno \u003d\u003d EWOULDBLOCK) BIO_set_retry_read();\n  else BIO_clear_retry_flags();\n}\n```\n\nThen, I should get SSL_ERROR_WANT_READ when I call SSL_read(). Right?\n\n\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\u003d\n\n\u003e The way this works is libssl tells you what it was blocked on, and you manage the call to poll() to retry the operation when it\u0027s ready. \n\nI am not sure if I understand. IIUC, poll()ing on the raw socket fd is the closest way to wait for real data. It may still wake up spuriously, because raw data available doesn\u0027t mean real data being available. Right?\n\nIn pseudocode, for a raw socket, I may have:\n\n```\nwhile (poll()) {\n  if (POLLIN is set for fd) {\n    int ret \u003d TEMP_FAILURE_RETRY(read(fd));\n    if (ret \u003c\u003d 0) abort(); // because it should never happen!\n  }\n}\n```\n\nbut with libssl, I\u0027ll need to be resilient to SSL_ERROR_WANT_READ:\n\n```\nwhile (poll()) {\n  if (POLLIN is set for fd) {\n    int ret \u003d TEMP_FAILURE_RETRY(SSL_read());\n    if (ret \u003c\u003d 0) {\n      if (SSL_get_error() \u003d\u003d SSL_ERROR_WANT_READ) continue; // poll again\n      abort(); // this should never happen!\n  }\n}\n  \n```",
      "parentUuid": "103e67db_66d5b2ce",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e646ae4_8b639711",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1019036
      },
      "writtenOn": "2021-08-04T23:31:16Z",
      "side": 1,
      "message": "Just noting one point from the above:\n\n\u003e In pseudocode, for a raw socket, I may have:\n\u003e \n\u003e while (poll()) {\n\u003e   if (POLLIN is set for fd) {\n\u003e   int ret \u003d TEMP_FAILURE_RETRY(read(fd));\n\u003e   if (ret \u003c\u003d 0) abort(); // because it should never happen!\n\u003e }\n\nFirstly, read() can fail after poll() says that it\u0027s readable, in general. So you should be kind to the kernel and loop again.\n\nBut, more importantly, writing a poll() loop inside the BIO just makes a blocking socket from a non-blocking socket again! In order to take advantage of a non-blocking socket there has to be an application-level poll loop somewhere that will service other sockets while a given TLS socket is waiting for data.\n\nYou are both writing a library (and thus shouldn\u0027t deal with application-wide issues) and doing non-blocking I/O (which has to be application-wide to work). The usual answers are either to have a standard poll loop that all the libraries can use (e.g. glib[1] for many Linux apps) or else expose callbacks from your library that the application has to wire up. Perhaps Android has a standard poll system, but I don\u0027t know much about Android internals.\n\n[1] https://gitlab.gnome.org/GNOME/glib",
      "parentUuid": "cde4e3e0_8f933fba",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "218e9cab_803892df",
        "filename": "libs/binder/RpcTransportTls.cpp",
        "patchSetId": 24
      },
      "lineNbr": 57,
      "author": {
        "id": 1121838
      },
      "writtenOn": "2021-08-04T23:34:48Z",
      "side": 1,
      "message": "\u003e writing a poll() loop inside the BIO\n\nOh, the pseudocode is just an example. I am not polling inside the BIO, but just giving a simplified version of:\n\nhttps://android-review.googlesource.com/c/platform/frameworks/native/+/1747934/27/libs/binder/RpcSession.cpp#277\n\n... which uses this RpcTransport API that I am implementing.",
      "parentUuid": "4e646ae4_8b639711",
      "revId": "dd806f3bc4e0d5b4776302511e1a60d4a331f2fe",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}