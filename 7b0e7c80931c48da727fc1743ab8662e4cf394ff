{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "dd27ac8e_2e01956e",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1060831
      },
      "writtenOn": "2021-09-24T10:35:22Z",
      "side": 1,
      "message": "First attempt at a higher-level API.\n\nIt\u0027s arguable this could be entirely separate from the binder code, layered on top of the raw function. But it does seem a much nicer and more Rust-like way to do it.",
      "revId": "7b0e7c80931c48da727fc1743ab8662e4cf394ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2b6f0e07_6df6df1f",
        "filename": "libs/binder/rust/src/lazy_service.rs",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1380243
      },
      "writtenOn": "2021-09-24T10:51:10Z",
      "side": 1,
      "message": "Nit: I\u0027d be inclined to put a blank line between the crate docs and these use statements, as they are not related.",
      "revId": "7b0e7c80931c48da727fc1743ab8662e4cf394ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6d134fb3_05a04d23",
        "filename": "libs/binder/rust/src/lazy_service.rs",
        "patchSetId": 1
      },
      "lineNbr": 19,
      "author": {
        "id": 1060831
      },
      "writtenOn": "2021-09-24T12:51:00Z",
      "side": 1,
      "message": "So would I, but rustfmt keeps removing it. I haven\u0027t worked out why.",
      "parentUuid": "2b6f0e07_6df6df1f",
      "revId": "7b0e7c80931c48da727fc1743ab8662e4cf394ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "70f61fca_19a4d09f",
        "filename": "libs/binder/rust/src/lazy_service.rs",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1380243
      },
      "writtenOn": "2021-09-24T10:51:10Z",
      "side": 1,
      "message": "This makes it possible for anyone to construct a LazyServiceGuard without calling new, which would lead to incorrect behaviour. I think the usual pattern to prevent that is to do something like:\n\n```\npub struct LazyServiceGuard {\n  // Prevent construction outside of this module.\n  _private: (),\n}\n```",
      "revId": "7b0e7c80931c48da727fc1743ab8662e4cf394ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "89a2d343_d4b7fb5a",
        "filename": "libs/binder/rust/src/lazy_service.rs",
        "patchSetId": 1
      },
      "lineNbr": 28,
      "author": {
        "id": 1060831
      },
      "writtenOn": "2021-09-24T12:51:00Z",
      "side": 1,
      "message": "Oh, interesting. Thanks!",
      "parentUuid": "70f61fca_19a4d09f",
      "revId": "7b0e7c80931c48da727fc1743ab8662e4cf394ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "63298d44_0acd03b4",
        "filename": "libs/binder/rust/src/lazy_service.rs",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1380243
      },
      "writtenOn": "2021-09-24T10:51:10Z",
      "side": 1,
      "message": "Can you use an AtomicU64 instead? It should be slightly more efficient.",
      "revId": "7b0e7c80931c48da727fc1743ab8662e4cf394ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "0187bdd1_a51283fc",
        "filename": "libs/binder/rust/src/lazy_service.rs",
        "patchSetId": 1
      },
      "lineNbr": 32,
      "author": {
        "id": 1060831
      },
      "writtenOn": "2021-09-24T12:51:00Z",
      "side": 1,
      "message": "That was my first implementation, but it isn\u0027t safe:\nSupposed thread 1 has a LazyServiceGuard and drops it.\nAnd thread 2 at around the same time creates a new one.\n\nThen we will get calls to force_persist(false) and force_persist(true), but it\u0027s important that they happen in that order and not the reverse.\n\nMaking the call from inside the mutex was the only way I could see to ensure they were properly sequenced.",
      "parentUuid": "63298d44_0acd03b4",
      "revId": "7b0e7c80931c48da727fc1743ab8662e4cf394ff",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}