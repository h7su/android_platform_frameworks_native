{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "4c117b1e_547c19e8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-02-27T19:19:34Z",
      "side": 1,
      "message": "btw - these should still be being processed asynchronously. Did you identify what the strong cycle was from?",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b81ca249_9857da4c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-02-27T19:20:45Z",
      "side": 1,
      "message": "async - as oneway calls are happening, though it won\u0027t process all of them. We do want to make sure this case works (e.g. clients shouldn\u0027t have to worry about it to avoid leaks, so it would be nice to know where the issue is here)\n\nWere you able to repro the failure?",
      "parentUuid": "4c117b1e_547c19e8",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5f188b29_c9b6b461",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-02-27T23:01:57Z",
      "side": 1,
      "message": "\u003e Did you identify what the strong cycle was from?\n\nThe leak happened because binderRpcTest did not have an incoming thread to handle the decrefs coming back from oneway requests (2 of them). At the end of the test, `rootIface` still has a `timesSent` counter equal to 2. I haven\u0027t looked specifically, but I bet `sentRef` is still live at that point, which would cause the cycle.\n\n\u003e Were you able to repro the failure?\n\nYes, I repro\u0027ed the failure for OnewayCallQueuingWithFds pretty consistently, and this CL fixed it.",
      "parentUuid": "b81ca249_9857da4c",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d2ab7a28_71ea1c3d",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2023-03-01T21:26:58Z",
      "side": 1,
      "message": "This solution doesn\u0027t seem like something we\u0027d expect a normal user of binder to do though, right?",
      "parentUuid": "5f188b29_c9b6b461",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "539f5ffa_640e89c7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-03-01T21:34:23Z",
      "side": 1,
      "message": "Right, but normal users aren\u0027t checking that there are no leaks immediately. It\u0027s the strict check that needs this. Normally, the refcounts will get cleaned up asynchronously.\n\nWe can also add RpcSession::flushCommands and implement something equivalent to IPCThreadState::flushIfNeeded if it becomes an issue for anyway.",
      "parentUuid": "d2ab7a28_71ea1c3d",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c817788_4620c757",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2023-03-01T21:40:27Z",
      "side": 1,
      "message": "OK, so this is just a race condition in the test cleanup. The test teardown wants to check for leaks, but we don\u0027t have any sync point to make sure the async work is finished.\n\nWhat I don\u0027t get is, why is this only an issue after https://r.android.com/2402157? Without that CL, shouldn\u0027t we be leaking more, not less?",
      "parentUuid": "539f5ffa_640e89c7",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "499f56ca_a4eb0e95",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-03-02T00:57:16Z",
      "side": 1,
      "message": "Without that CL, the test passes because it does 2 async transactions followed by 2 sync ones, and every sync transaction also ends with a `flushExcessBinderRefs`.\n\nWithout the CL: there is no flush after any async transaction, so the first sync transaction at the end will send a `DecStrong` with `amount \u003d\u003d 3` (for the two binders for the async transactions, plus one for the current one), which works fine because the client drains all pending commands before processing the sync reply.\n\nWith the CL: there is a flush after every async transactions, so there are 3 `DecStrong`s with `amount \u003d\u003d 1` each one. Two of them get dropped because there is no client-side thread to handle them, so the object leaks.",
      "parentUuid": "6c817788_4620c757",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f649b1ec_f31c6c5c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-03-02T01:08:58Z",
      "side": 1,
      "message": "It\u0027s not a sync point, but it\u0027s the amortized behavior. We lived with this in binder for a long time, but I should probably fix it here as well.",
      "parentUuid": "499f56ca_a4eb0e95",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9763657d_5fcf8bf8",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-03-02T01:09:23Z",
      "side": 1,
      "message": "filed b/271345726 to fix this",
      "parentUuid": "f649b1ec_f31c6c5c",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c5c83e6c_1bdb6ecb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2023-03-02T01:31:18Z",
      "side": 1,
      "message": "Thanks that\u0027s helpful. I think that description of the behavior is a bit inaccurate because the async transactions in this test are forced to be concurrent with the sync ones.\n\n1. 1st `blockingSendFdOneway` transaction blocks on a channel server side\n2. 2nd `blockingSendFdOneway` transaction gets queued up\n3. 1st `blockingRecvFd` unblocks the 1st `blockingSendFdOneway` and calls `flushExcessBinderRefs` on its way out\n4. the handler for the 1st `blockingSendFdOneway` doesn\u0027t call `flushExcessBinderRefs`, it immediately tries to process the 2nd `blockingSendFdOneway` (which then blocks on a channel)\n5. 2nd `blockingRecvFd` unblocks the 2nd `blockingSendFdOneway`\n6. both try to `flushExcessBinderRefs` in a non-deterministic order\n\nAt least that was my intention when I wrote this. If that is right, then I could see how there is a race after the other CL, but I\u0027d also expect there to be a race before it. Maybe we just got lucky because there was less mutex contention?",
      "parentUuid": "499f56ca_a4eb0e95",
      "range": {
        "startLine": 8,
        "startChar": 0,
        "endLine": 12,
        "endChar": 0
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f40d55f3_13b5135d",
        "filename": "libs/binder/tests/binderRpcTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 536,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-02-27T23:15:46Z",
      "side": 1,
      "message": "can you use this method to flush it instead, if that\u0027s the case?",
      "range": {
        "startLine": 536,
        "startChar": 0,
        "endLine": 536,
        "endChar": 58
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "9f487c4e_7d4de68c",
        "filename": "libs/binder/tests/binderRpcTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 536,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2023-03-01T01:38:59Z",
      "side": 1,
      "message": "Yeah seems like that works too, and it\u0027s simpler.",
      "parentUuid": "f40d55f3_13b5135d",
      "range": {
        "startLine": 536,
        "startChar": 0,
        "endLine": 536,
        "endChar": 58
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "1921b9be_46e0c8a3",
        "filename": "libs/binder/tests/binderRpcTest.cpp",
        "patchSetId": 1
      },
      "lineNbr": 536,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-03-01T01:40:10Z",
      "side": 1,
      "message": "The main thing is, if there is another type of unexpected failure, the test would fail, and we would still learn about it.",
      "parentUuid": "9f487c4e_7d4de68c",
      "range": {
        "startLine": 536,
        "startChar": 0,
        "endLine": 536,
        "endChar": 58
      },
      "revId": "ead5929208229f0ad0bb7ae38e235e42eb5f6088",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}