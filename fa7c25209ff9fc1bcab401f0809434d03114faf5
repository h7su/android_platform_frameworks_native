{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c2078a86_b34bc6a3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010050
      },
      "writtenOn": "2021-08-26T00:37:56Z",
      "side": 1,
      "message": "This needs a bit more elaboration - we don\u0027t have raw access to Parcel\u0027s guts in the SDK, and I\u0027m very skeptical we should have it in the NDK either, given that it\u0027s not guaranteed to be any sort of stable.  So I don\u0027t see how applications can safely use this.\n\nCan you elaborate on why you need Parcels here to begin with if you\u0027re creating your own IPC paths?",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4acd1caf_31b0f3b5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2021-08-26T00:47:34Z",
      "side": 1,
      "message": "We need to pass parcelable that might exceed binder memory limitation across binder interface. For such parcelable, we add a library and check whether the marshalled data would exceed memory limitation, if so, we write the marshalled data in a shared memory file and pass the fileDescriptor to that shared memory file instead. On the other end, the receiver would do the opposite operation and turn the data back to a regular parcelable.\nWe are passing data between android system and Vehicle HAL using AIDL interface, so we have to use Parcelable (Parcel).\nThe detailed design is at go/auto-bigger-payload.",
      "parentUuid": "c2078a86_b34bc6a3",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7626d551_755a69e0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010050
      },
      "writtenOn": "2021-08-26T00:58:23Z",
      "side": 1,
      "message": "There\u0027s already a read/write FD in the NDK, so you can ferry the file descriptor across just fine.  Why do you need to access the guts of Parcelable?",
      "parentUuid": "4acd1caf_31b0f3b5",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfa45ba3_2037ea5b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2021-08-26T01:12:33Z",
      "side": 1,
      "message": "We need raw data of parcelable to be written/read from the shared memory file so that we could use the same marshal/unmarshal logic to deal with parcelable that are small enough which we could directly send or large enough so they need be sent over shared memory file.\n\nIf we use a different serialization/deserialization mechanism, we have to use two different mechanism to send the data based on whether it exceeds binder limitation or not.",
      "parentUuid": "7626d551_755a69e0",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d848c7ff_121f7007",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T01:46:06Z",
      "side": 1,
      "message": "btw - Eddy, android.os.Parcel#marshall is this same public API, right?\n\nThis is about reusing the parceling code. I don\u0027t necessarily love it (I wish we could remove this constraint from binder), but there are real constraints in binder, and we discussed some type-level checks in a library the automotive team would add to use this, so it\u0027s safe (up to developer mistakes, as per usual).",
      "parentUuid": "dfa45ba3_2037ea5b",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d76b49c4_2d1309e4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010050
      },
      "writtenOn": "2021-08-26T14:26:58Z",
      "side": 1,
      "message": "Fair enough, these do exist in the SDK, just as marshall/unmarshall.\n\nAny reason not to use the same names here?",
      "parentUuid": "d848c7ff_121f7007",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b2bec28_b5643b52",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-08-26T15:14:49Z",
      "side": 1,
      "message": "\u003e Any reason not to use the same names here?\n\n(and even if there is a good reason to use different names, for searchability it\u0027s worth referencing the Java equivalents by name in the doc comments...)",
      "parentUuid": "d76b49c4_2d1309e4",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e399f6ef_5b81a5e2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2021-08-26T15:30:04Z",
      "side": 1,
      "message": "While I don\u0027t object to the NDK having feature parity with SDK, I think these methods in particular are a mistake. Particularly because they don\u0027t actually _work_. You can\u0027t do what the bug is trying to do. If these parcels contain other binders or FDs, then marshelling them onto ashmem doesn\u0027t work. Which many common framework classes will automatically do (bitmap, ParceledListSlice, etc...)\n\nAnd this isn\u0027t implemented correctly as it\u0027s not catching \u0026 error\u0027ing in that case, which at least the SDK method does: https://source.corp.google.com/android/frameworks/base/core/jni/android_os_Parcel.cpp;rcl\u003d412dcea284cd5b894a93bf8c4b6004ccc05b8082;l\u003d546",
      "parentUuid": "7b2bec28_b5643b52",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1953953_bebb0b6c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T16:30:57Z",
      "side": 1,
      "message": "I was thinking they would need to add methods like \"hasFd\" or \"hasBinder\" or \"hasObject\" for this to work later. The current plan doesn\u0027t need to marshall these.\n\nAnyway - I\u0027m very mixed on this, and I started an android-binder@ thread. While I do think it\u0027s technically correct and there is an argument for it, it could be errorprone, and it\u0027s basically rebuilding a binder mechanism to pass certain data beyond binder\u0027s limit, and I\u0027d rather see this limit fixed in binder. Like John mentioned, some of the workarounds fwk uses for this, we\u0027ve gotten away w/o this kind of thing for a long time.",
      "parentUuid": "e399f6ef_5b81a5e2",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30748137_38169d60",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-26T19:16:03Z",
      "side": 1,
      "message": "We need to document things that will not work.\nFor low level operation like this, it should be the responsibility of client to make sure to pass what is relevant. We cannot prevent all mis-usages from API itself.\n\nWrite flow 1:\n1. serialize to Parcel\n2. copy\nCaller can check if there is objects written and fail it.\nBut this is hard to prevent as client\u0027s intent for copy is not clear.\n\nWrite flow 2:\n1. get big enough shared memory\n2. setData\n3. serialize\nWe can potentially return error in serialization phase. But again client\u0027s intent is not clear.\n\nRead flow:\n1. get data through shared memory\n2. setData\n3. deserialize\n\nRead flow will fail as there is no objects stored.",
      "parentUuid": "e1953953_bebb0b6c",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddc167bf_7d373e4b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2021-08-26T19:27:14Z",
      "side": 1,
      "message": "\u003e We cannot prevent all mis-usages from API itself.\n\nSure but I\u0027m arguing the API itself is inherently wrong. As in, there are no correct usages of it in the first place, so _all_ usages are mis-usages. The usage outlined in the bug itself is, for example, a mis-usage. This isn\u0027t a documentation problem, it\u0027s a architecture design problem.\n\nWhat you want instead is to serialize \u0026 deserialize directly to/from ashmem or have a way to just raise the binder limit. Either of those are OK designs IMO. This isn\u0027t, it\u0027s taking a slow path and making it even slower \u0026 have it use even more RAM, all while mysteriously failing in common scenarios.",
      "parentUuid": "30748137_38169d60",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19d7477a_85df235a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T00:29:02Z",
      "side": 1,
      "message": "(note, all the adds are from adding \u0027android-ndk-api-council\u0027 to the CL)",
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7517eb14_337eaa35",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1010050
      },
      "writtenOn": "2021-08-26T14:26:58Z",
      "side": 1,
      "message": "I\u0027m curious why fmq wasn\u0027t considered for this, since it seems rather similar to the proposed system\n\n",
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2953d788_a8f68edf",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1170,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T00:29:02Z",
      "side": 1,
      "message": "nice! I see this is the description from android.os.Parcel.marshall. perfect.",
      "range": {
        "startLine": 1170,
        "startChar": 3,
        "endLine": 1170,
        "endChar": 6
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44923894_72d0a872",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1171,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T00:29:02Z",
      "side": 1,
      "message": "nit: this file uses single spaces",
      "range": {
        "startLine": 1171,
        "startChar": 27,
        "endLine": 1171,
        "endChar": 28
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7429496a_4706b848",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1184,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-26T01:03:41Z",
      "side": 1,
      "message": "The raw data may include already serialized data and the parcel can be used to de-serialize it. Plz note that the serialized data should include only stable data like vintf stable AIDL to cross the boundary between vendor and system without breaking compatibility.",
      "range": {
        "startLine": 1184,
        "startChar": 0,
        "endLine": 1184,
        "endChar": 2
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}