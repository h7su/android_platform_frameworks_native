{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "c2078a86_b34bc6a3",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010050
      },
      "writtenOn": "2021-08-26T00:37:56Z",
      "side": 1,
      "message": "This needs a bit more elaboration - we don\u0027t have raw access to Parcel\u0027s guts in the SDK, and I\u0027m very skeptical we should have it in the NDK either, given that it\u0027s not guaranteed to be any sort of stable.  So I don\u0027t see how applications can safely use this.\n\nCan you elaborate on why you need Parcels here to begin with if you\u0027re creating your own IPC paths?",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4acd1caf_31b0f3b5",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2021-08-26T00:47:34Z",
      "side": 1,
      "message": "We need to pass parcelable that might exceed binder memory limitation across binder interface. For such parcelable, we add a library and check whether the marshalled data would exceed memory limitation, if so, we write the marshalled data in a shared memory file and pass the fileDescriptor to that shared memory file instead. On the other end, the receiver would do the opposite operation and turn the data back to a regular parcelable.\nWe are passing data between android system and Vehicle HAL using AIDL interface, so we have to use Parcelable (Parcel).\nThe detailed design is at go/auto-bigger-payload.",
      "parentUuid": "c2078a86_b34bc6a3",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7626d551_755a69e0",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010050
      },
      "writtenOn": "2021-08-26T00:58:23Z",
      "side": 1,
      "message": "There\u0027s already a read/write FD in the NDK, so you can ferry the file descriptor across just fine.  Why do you need to access the guts of Parcelable?",
      "parentUuid": "4acd1caf_31b0f3b5",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dfa45ba3_2037ea5b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2021-08-26T01:12:33Z",
      "side": 1,
      "message": "We need raw data of parcelable to be written/read from the shared memory file so that we could use the same marshal/unmarshal logic to deal with parcelable that are small enough which we could directly send or large enough so they need be sent over shared memory file.\n\nIf we use a different serialization/deserialization mechanism, we have to use two different mechanism to send the data based on whether it exceeds binder limitation or not.",
      "parentUuid": "7626d551_755a69e0",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d848c7ff_121f7007",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T01:46:06Z",
      "side": 1,
      "message": "btw - Eddy, android.os.Parcel#marshall is this same public API, right?\n\nThis is about reusing the parceling code. I don\u0027t necessarily love it (I wish we could remove this constraint from binder), but there are real constraints in binder, and we discussed some type-level checks in a library the automotive team would add to use this, so it\u0027s safe (up to developer mistakes, as per usual).",
      "parentUuid": "dfa45ba3_2037ea5b",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d76b49c4_2d1309e4",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010050
      },
      "writtenOn": "2021-08-26T14:26:58Z",
      "side": 1,
      "message": "Fair enough, these do exist in the SDK, just as marshall/unmarshall.\n\nAny reason not to use the same names here?",
      "parentUuid": "d848c7ff_121f7007",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7b2bec28_b5643b52",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1003224
      },
      "writtenOn": "2021-08-26T15:14:49Z",
      "side": 1,
      "message": "\u003e Any reason not to use the same names here?\n\n(and even if there is a good reason to use different names, for searchability it\u0027s worth referencing the Java equivalents by name in the doc comments...)",
      "parentUuid": "d76b49c4_2d1309e4",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e399f6ef_5b81a5e2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2021-08-26T15:30:04Z",
      "side": 1,
      "message": "While I don\u0027t object to the NDK having feature parity with SDK, I think these methods in particular are a mistake. Particularly because they don\u0027t actually _work_. You can\u0027t do what the bug is trying to do. If these parcels contain other binders or FDs, then marshelling them onto ashmem doesn\u0027t work. Which many common framework classes will automatically do (bitmap, ParceledListSlice, etc...)\n\nAnd this isn\u0027t implemented correctly as it\u0027s not catching \u0026 error\u0027ing in that case, which at least the SDK method does: https://source.corp.google.com/android/frameworks/base/core/jni/android_os_Parcel.cpp;rcl\u003d412dcea284cd5b894a93bf8c4b6004ccc05b8082;l\u003d546",
      "parentUuid": "7b2bec28_b5643b52",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e1953953_bebb0b6c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T16:30:57Z",
      "side": 1,
      "message": "I was thinking they would need to add methods like \"hasFd\" or \"hasBinder\" or \"hasObject\" for this to work later. The current plan doesn\u0027t need to marshall these.\n\nAnyway - I\u0027m very mixed on this, and I started an android-binder@ thread. While I do think it\u0027s technically correct and there is an argument for it, it could be errorprone, and it\u0027s basically rebuilding a binder mechanism to pass certain data beyond binder\u0027s limit, and I\u0027d rather see this limit fixed in binder. Like John mentioned, some of the workarounds fwk uses for this, we\u0027ve gotten away w/o this kind of thing for a long time.",
      "parentUuid": "e399f6ef_5b81a5e2",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "30748137_38169d60",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-26T19:16:03Z",
      "side": 1,
      "message": "We need to document things that will not work.\nFor low level operation like this, it should be the responsibility of client to make sure to pass what is relevant. We cannot prevent all mis-usages from API itself.\n\nWrite flow 1:\n1. serialize to Parcel\n2. copy\nCaller can check if there is objects written and fail it.\nBut this is hard to prevent as client\u0027s intent for copy is not clear.\n\nWrite flow 2:\n1. get big enough shared memory\n2. setData\n3. serialize\nWe can potentially return error in serialization phase. But again client\u0027s intent is not clear.\n\nRead flow:\n1. get data through shared memory\n2. setData\n3. deserialize\n\nRead flow will fail as there is no objects stored.",
      "parentUuid": "e1953953_bebb0b6c",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ddc167bf_7d373e4b",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2021-08-26T19:27:14Z",
      "side": 1,
      "message": "\u003e We cannot prevent all mis-usages from API itself.\n\nSure but I\u0027m arguing the API itself is inherently wrong. As in, there are no correct usages of it in the first place, so _all_ usages are mis-usages. The usage outlined in the bug itself is, for example, a mis-usage. This isn\u0027t a documentation problem, it\u0027s a architecture design problem.\n\nWhat you want instead is to serialize \u0026 deserialize directly to/from ashmem or have a way to just raise the binder limit. Either of those are OK designs IMO. This isn\u0027t, it\u0027s taking a slow path and making it even slower \u0026 have it use even more RAM, all while mysteriously failing in common scenarios.",
      "parentUuid": "30748137_38169d60",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4a10c25c_9c716bf1",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-26T19:34:49Z",
      "side": 1,
      "message": "Directly serializing to ashmem requires building whole set of things especially in code generation path. Write flow2 above shows example of doing it for working cases without sacrificing performance. Read flow showed above already avoids additional copy and is very efficient. So performance is not an issue here.\n\nThe user of API should know the caveats and limitations for using this low level API. What low level NDK API do we have which completely prevents client\u0027s mis-usage?",
      "parentUuid": "ddc167bf_7d373e4b",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "76fc7576_d65c1de9",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1219061
      },
      "writtenOn": "2021-08-26T19:37:29Z",
      "side": 1,
      "message": "I do agree that we need to add the checks for binders to be compatible with SDK. If we add the checks for objectsCount, we could prevent accidental misuse or the marshal function.",
      "parentUuid": "4a10c25c_9c716bf1",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "92cb19f6_efda839c",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010103
      },
      "writtenOn": "2021-08-26T20:43:53Z",
      "side": 1,
      "message": "\u003e Directly serializing to ashmem requires building whole set of things especially in code generation path. \n\nI\u0027m talking the Parcel internally supporting allocating its mData on ashmem/memfd instead. So all your code generation targeting Parcel would be unchanged, _and_ it would still work with binder \u0026 FD objects.\n\n\u003e Write flow2 above shows example of doing it for working cases without sacrificing performance. [...]Read flow showed above already avoids additional copy and is very efficient\n\nsetData does a memcpy to Parcel\u0027s internal buffer: https://cs.android.com/android/platform/superproject/+/master:frameworks/native/libs/binder/Parcel.cpp;drc\u003d16a4106cb7bc18d473a428d9f19c7561a21e3f06;l\u003d421\n\nSo the write flow 2 doesn\u0027t work, the data doesn\u0027t end up on ashmem, and the read flow starts by doing a deep copy of the ashmem buffer.",
      "parentUuid": "76fc7576_d65c1de9",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ac756e9_6236dbb7",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-26T20:57:51Z",
      "side": 1,
      "message": "I see. So additional copy for writing is not avoidable. But it should be compared against the case where binder call itself fails because of memory limit. We can also remove that additional copy if we can handle memory size limit for Parcel but that will be for future.\nFor passing fd, you can check other email thread on why is it not working without updating auto-generation code. We can make it work in the end but not now without having other things updated.\n\nHow about exposing all necessary information to the client so that client can decide if the operation is safe or not? We need at least to expose object count so that client copying it to shared memory can tell if it is ok or not. Read will fail anyway so main issue will be to detect error in write side.",
      "parentUuid": "92cb19f6_efda839c",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "93788f24_ed3067d6",
        "filename": "/COMMIT_MSG",
        "patchSetId": 1
      },
      "lineNbr": 12,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T20:58:02Z",
      "side": 1,
      "message": "\u003e the read flow starts by doing a deep copy of the ashmem buffer.\n\nIt\u0027s pretty critical that this would happen though. It is not safe to unparcel from shared memory that is owned by another process. This is a central security principle - in kernel binder, it\u0027s guaranteed by the kernel owning the memory that is being unparceled from. ipcSetDataReference must *not* be used here.",
      "parentUuid": "92cb19f6_efda839c",
      "range": {
        "startLine": 11,
        "startChar": 26,
        "endLine": 12,
        "endChar": 12
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "19d7477a_85df235a",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T00:29:02Z",
      "side": 1,
      "message": "(note, all the adds are from adding \u0027android-ndk-api-council\u0027 to the CL)",
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "7517eb14_337eaa35",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1010050
      },
      "writtenOn": "2021-08-26T14:26:58Z",
      "side": 1,
      "message": "I\u0027m curious why fmq wasn\u0027t considered for this, since it seems rather similar to the proposed system\n\n",
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2953d788_a8f68edf",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1170,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T00:29:02Z",
      "side": 1,
      "message": "nice! I see this is the description from android.os.Parcel.marshall. perfect.",
      "range": {
        "startLine": 1170,
        "startChar": 3,
        "endLine": 1170,
        "endChar": 6
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "44923894_72d0a872",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1171,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-08-26T00:29:02Z",
      "side": 1,
      "message": "nit: this file uses single spaces",
      "range": {
        "startLine": 1171,
        "startChar": 27,
        "endLine": 1171,
        "endChar": 28
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7429496a_4706b848",
        "filename": "libs/binder/ndk/include_ndk/android/binder_parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1184,
      "author": {
        "id": 1010465
      },
      "writtenOn": "2021-08-26T01:03:41Z",
      "side": 1,
      "message": "The raw data may include already serialized data and the parcel can be used to de-serialize it. Plz note that the serialized data should include only stable data like vintf stable AIDL to cross the boundary between vendor and system without breaking compatibility.",
      "range": {
        "startLine": 1184,
        "startChar": 0,
        "endLine": 1184,
        "endChar": 2
      },
      "revId": "fa7c25209ff9fc1bcab401f0809434d03114faf5",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}