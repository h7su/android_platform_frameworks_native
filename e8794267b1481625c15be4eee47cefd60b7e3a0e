{
  "comments": [
    {
      "key": {
        "uuid": "7a624c12_6e103602",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T00:35:32Z",
      "side": 1,
      "message": "Test added for NDK \u003c-\u003e Rust in the process.",
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9abce66a_109c7ad5",
        "filename": "libs/binder/rust/tests/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-01T21:24:39Z",
      "side": 1,
      "message": "Prefer Ndk, everywhere",
      "range": {
        "startLine": 35,
        "startChar": 21,
        "endLine": 35,
        "endChar": 24
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c4b1f55d_c7c0c49c",
        "filename": "libs/binder/rust/tests/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T22:55:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9abce66a_109c7ad5",
      "range": {
        "startLine": 35,
        "startChar": 21,
        "endLine": 35,
        "endChar": 24
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9fb5c74e_e201cbfa",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-01T21:24:39Z",
      "side": 1,
      "message": "this doesn\u0027t try to associate the NdkServer type with this type.\n\nAm I correct to understand:\n- this is already associated with the rust type\n- associating the NdkServer type would fail\n\nIf so, we\u0027ll need a similar fix in the NDK backend.",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 54
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "50b3be26_fbed89d0",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T22:55:12Z",
      "side": 1,
      "message": "That\u0027s correct. We can\u0027t call the AIDL-generated fromBinder() on this binder object, as the association will fail. This will need to get fixed in the NDK AIDL backend. However, we may need to take a different approach, see my comment on integration.rs.",
      "parentUuid": "9fb5c74e_e201cbfa",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 54
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "fa26394b_7e56e26e",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 64,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-01T21:24:39Z",
      "side": 1,
      "message": "check result code",
      "range": {
        "startLine": 64,
        "startChar": 4,
        "endLine": 64,
        "endChar": 30
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95f8b544_7bf8f71a",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 64,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T22:55:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fa26394b_7e56e26e",
      "range": {
        "startLine": 64,
        "startChar": 4,
        "endLine": 64,
        "endChar": 30
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "13050d53_5aa2e773",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-01T21:24:39Z",
      "side": 1,
      "message": "do we have a test that this fails if it is in fact a different type?",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "c812268d_d97fa926",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T22:55:12Z",
      "side": 1,
      "message": "This will never fail if the service is the wrong type. Instead, any method call _should_ fail when the interface class is checked on the service side.\n\nHowever, I just realized an issue. I was forgetting who controls the interface token for the parcel. AIBinder_prepareTransaction writes the interface token to the parcel based on the currently associated class (which is NOT the class we were trying to use it as). What we really want is for the NDK to create us a new ABpBinder with the new, desired class if it differs from the currently associated class for an ABBinder.",
      "parentUuid": "13050d53_5aa2e773",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e23fc66_45bc3eab",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-05T20:52:15Z",
      "side": 1,
      "message": "Yeah, but the thing is that the class will be guaranteed to have the exact same interface descriptor (otherwise, it won\u0027t associate).\n\nIt would be a problem if libbinder_ndk used other functionality from the AIBinder_Class object when dealing with BpBinders, but it only uses the interface descriptor.\n\nI\u0027m thinking about making these assumptions more explicit (either by documenting things or only holding onto the class object). Maybe the real solution to this could be allowing multiple classes to be associated under the hood (all of which need to have the same interface descriptor).",
      "parentUuid": "c812268d_d97fa926",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "95738149_793d4072",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-06T01:11:04Z",
      "side": 1,
      "message": "Sure, but we can\u0027t associate with anything but the original class pointer, so association is always going to fail regardless of whether the interface descriptor string matches. What I wanted to do (and what this CL currently does) was ignore the association failure and treat the object as a remote proxy in that case. However, I can\u0027t do that since the the object will continue to transact with the original interface descriptor, not the one we tried to associate it with.\n\nI think splitting an AIBinder into a new ABpBinder object when trying to associate with a different class pointer than expected would do what we need here, and fix both the Rust and C NDK versions. We can check the interface descriptor string at that point (if desired). This would still prevent incompatible implementations of a service from getting conflated, while still allowing transactions across these implementations via parceling, as if they were remote.\n\nI saw you have some logic to de-duplicate ABpBinder objects so that there is only one object per IBinder. What is the purpose of this? We would need to get rid of this de-duplication for the object splitting to work.",
      "parentUuid": "7e23fc66_45bc3eab",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}