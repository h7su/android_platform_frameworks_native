{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "7a624c12_6e103602",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 2
      },
      "lineNbr": 0,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T00:35:32Z",
      "side": 1,
      "message": "Test added for NDK \u003c-\u003e Rust in the process.",
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9abce66a_109c7ad5",
        "filename": "libs/binder/rust/tests/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-01T21:24:39Z",
      "side": 1,
      "message": "Prefer Ndk, everywhere",
      "range": {
        "startLine": 35,
        "startChar": 21,
        "endLine": 35,
        "endChar": 24
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "c4b1f55d_c7c0c49c",
        "filename": "libs/binder/rust/tests/Android.bp",
        "patchSetId": 2
      },
      "lineNbr": 35,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T22:55:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9abce66a_109c7ad5",
      "range": {
        "startLine": 35,
        "startChar": 21,
        "endLine": 35,
        "endChar": 24
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9fb5c74e_e201cbfa",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-01T21:24:39Z",
      "side": 1,
      "message": "this doesn\u0027t try to associate the NdkServer type with this type.\n\nAm I correct to understand:\n- this is already associated with the rust type\n- associating the NdkServer type would fail\n\nIf so, we\u0027ll need a similar fix in the NDK backend.",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 54
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "50b3be26_fbed89d0",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T22:55:12Z",
      "side": 1,
      "message": "That\u0027s correct. We can\u0027t call the AIDL-generated fromBinder() on this binder object, as the association will fail. This will need to get fixed in the NDK AIDL backend. However, we may need to take a different approach, see my comment on integration.rs.",
      "parentUuid": "9fb5c74e_e201cbfa",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 54
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "201e39c0_651d5b8d",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-11-19T19:08:10Z",
      "side": 1,
      "message": "Do we have a bug on fixing the NDK AIDL backend to associate with local Rust services, i.e. the inverse direction from this CL?",
      "parentUuid": "50b3be26_fbed89d0",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 54
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "585ec4c3_2ee0bb39",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 53,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-11-23T18:43:15Z",
      "side": 1,
      "message": "Yeah, b/167723746 is on me for this. I can look at it.",
      "parentUuid": "201e39c0_651d5b8d",
      "range": {
        "startLine": 53,
        "startChar": 0,
        "endLine": 53,
        "endChar": 54
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fa26394b_7e56e26e",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 64,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-01T21:24:39Z",
      "side": 1,
      "message": "check result code",
      "range": {
        "startLine": 64,
        "startChar": 4,
        "endLine": 64,
        "endChar": 30
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "95f8b544_7bf8f71a",
        "filename": "libs/binder/rust/tests/binderRustNDKInteropTest.cpp",
        "patchSetId": 2
      },
      "lineNbr": 64,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T22:55:12Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "fa26394b_7e56e26e",
      "range": {
        "startLine": 64,
        "startChar": 4,
        "endLine": 64,
        "endChar": 30
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "13050d53_5aa2e773",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-01T21:24:39Z",
      "side": 1,
      "message": "do we have a test that this fails if it is in fact a different type?",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c812268d_d97fa926",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-01T22:55:12Z",
      "side": 1,
      "message": "This will never fail if the service is the wrong type. Instead, any method call _should_ fail when the interface class is checked on the service side.\n\nHowever, I just realized an issue. I was forgetting who controls the interface token for the parcel. AIBinder_prepareTransaction writes the interface token to the parcel based on the currently associated class (which is NOT the class we were trying to use it as). What we really want is for the NDK to create us a new ABpBinder with the new, desired class if it differs from the currently associated class for an ABBinder.",
      "parentUuid": "13050d53_5aa2e773",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7e23fc66_45bc3eab",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-05T20:52:15Z",
      "side": 1,
      "message": "Yeah, but the thing is that the class will be guaranteed to have the exact same interface descriptor (otherwise, it won\u0027t associate).\n\nIt would be a problem if libbinder_ndk used other functionality from the AIBinder_Class object when dealing with BpBinders, but it only uses the interface descriptor.\n\nI\u0027m thinking about making these assumptions more explicit (either by documenting things or only holding onto the class object). Maybe the real solution to this could be allowing multiple classes to be associated under the hood (all of which need to have the same interface descriptor).",
      "parentUuid": "c812268d_d97fa926",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95738149_793d4072",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-06T01:11:04Z",
      "side": 1,
      "message": "Sure, but we can\u0027t associate with anything but the original class pointer, so association is always going to fail regardless of whether the interface descriptor string matches. What I wanted to do (and what this CL currently does) was ignore the association failure and treat the object as a remote proxy in that case. However, I can\u0027t do that since the the object will continue to transact with the original interface descriptor, not the one we tried to associate it with.\n\nI think splitting an AIBinder into a new ABpBinder object when trying to associate with a different class pointer than expected would do what we need here, and fix both the Rust and C NDK versions. We can check the interface descriptor string at that point (if desired). This would still prevent incompatible implementations of a service from getting conflated, while still allowing transactions across these implementations via parceling, as if they were remote.\n\nI saw you have some logic to de-duplicate ABpBinder objects so that there is only one object per IBinder. What is the purpose of this? We would need to get rid of this de-duplication for the object splitting to work.",
      "parentUuid": "7e23fc66_45bc3eab",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c764e47c_4e4a3e88",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-06T20:27:28Z",
      "side": 1,
      "message": "\u003e I can\u0027t do that since the the object will continue to transact with the original interface descriptor, not the one we tried to associate it with.\n\nWhy is the Rust interface descriptor different than the descriptor in the NDK backend? They should be the same, because these interfaces are designed to interoperate.\n\n\u003e What is the purpose of this? We would need to get rid of this de-duplication for the object splitting to work.\n\nIt\u0027s to make AIBinder objects pointer-comparable, mirroring the behavior of BpBinder.",
      "parentUuid": "95738149_793d4072",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f949a491_ec1a50fd",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-06T20:46:23Z",
      "side": 1,
      "message": "\u003e Why is the Rust interface descriptor different than the descriptor in the NDK backend? They should be the same, because these interfaces are designed to interoperate.\n\nIf used properly they are the same, however, a user can request the binder object be treated as any interface. In the case that the interface descriptor is wrong we need to either fail to create the remote interface (fail to associate), or fail when transacting. The NDK currently fails to associate if the pointer mismatches, regardless of the interface descriptor string. This is correct and necessary because the callee may be in a different language or APEX and therefore the service implementor can\u0027t be used directly. There\u0027s currently no way to just check if the interface descriptor string matches, so we don\u0027t know ahead of time of it matched or not, just that the class pointer didn\u0027t match.\n\nThe options I can see are adding an API to check the interface descriptor string and put the responsibility for checking that on the user (i.e AIDL-generated code) or adding/modifying the class association to create a new BpBinder without userdata when the class pointer doesn\u0027t match. It sounds like the former would be less invasive?\n\n\u003e It\u0027s to make AIBinder objects pointer-comparable, mirroring the behavior of BpBinder.\n\nAh, I re-read this code and it makes more sense now. We could create a new BpBinder and it would get its own distinct AIBinder, right?",
      "parentUuid": "c764e47c_4e4a3e88",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "95ed614f_1548c6ec",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-10-06T23:29:35Z",
      "side": 1,
      "message": "\u003e however, a user can request the binder object be treated as any interface\n\nIs this additional functionality opened up in the rust backend? Since AIDL doesn\u0027t/shouldn\u0027t use it, we could curb that back.\n\n\u003e There\u0027s currently no way to just check if the interface descriptor string matches, so we don\u0027t know ahead of time of it matched or not,\n\nLet\u0027s add AIBinder_Class_getDescriptor\n\n\u003e We could create a new BpBinder and it would get its own distinct AIBinder, right?\n\nThere\u0027s no way to create a new BpBinder though (and this would break pointer-equality of these objects).",
      "parentUuid": "f949a491_ec1a50fd",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ba1727b3_ead88b26",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-10-23T00:02:40Z",
      "side": 1,
      "message": "\u003e Is this additional functionality opened up in the rust backend? Since AIDL doesn\u0027t/shouldn\u0027t use it, we could curb that back.\nGone now, a local binder can now only be used from the correct interface due to the new descriptor string check.\n\nI\u0027ve added the AIBinder_Class_getDescriptor API, and use it from Rust now.\n\nStill need to add another CL to the NDK AIDL backend to make fromBinder check the descriptor string if the pointer doesn\u0027t match.",
      "parentUuid": "95ed614f_1548c6ec",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "d3b2c19d_1c1f0664",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-11-19T19:08:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ba1727b3_ead88b26",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "2eecf205_8efc46e2",
        "filename": "libs/binder/rust/tests/integration.rs",
        "patchSetId": 2
      },
      "lineNbr": 451,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-11-19T19:08:10Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ba1727b3_ead88b26",
      "range": {
        "startLine": 451,
        "startChar": 54,
        "endLine": 451,
        "endChar": 62
      },
      "revId": "e8794267b1481625c15be4eee47cefd60b7e3a0e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}