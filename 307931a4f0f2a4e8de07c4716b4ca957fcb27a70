{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "9c5d9f87_c4f8b2b0",
        "filename": "cmds/atrace/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 40,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-10-07T20:38:06Z",
      "side": 1,
      "message": "`bpfmt -w Android.bp`\n\nYou may not be running pre-upload hooks.",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 40,
        "endChar": 1
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "4e4a78a6_8f0869fb",
        "filename": "cmds/atrace/Android.bp",
        "patchSetId": 1
      },
      "lineNbr": 40,
      "author": {
        "id": 1896186
      },
      "writtenOn": "2022-10-10T09:15:50Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9c5d9f87_c4f8b2b0",
      "range": {
        "startLine": 40,
        "startChar": 0,
        "endLine": 40,
        "endChar": 1
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d1ecddef_028a6933",
        "filename": "cmds/atrace/atrace.cpp",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-10-07T20:38:06Z",
      "side": 1,
      "message": "Is this a binary format? Do we have guidance for vendors to implement it? How do we make sure we continue to support it in the future?",
      "range": {
        "startLine": 78,
        "startChar": 74,
        "endLine": 78,
        "endChar": 76
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ac18a652_52d75454",
        "filename": "cmds/atrace/atrace.cpp",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1896186
      },
      "writtenOn": "2022-10-10T09:15:50Z",
      "side": 1,
      "message": "\u003e Is this a binary format?\n\nYes, and it\u0027s just protobuf message, defined at https://cs.android.com/android/platform/superproject/+/master:external/perfetto/protos/perfetto/android_vendor/atrace_categories.proto;drc\u003d2e6c1069b5e0c8328a14a105dbfa203033afec1f\n\nIt has been introduced in r.android.com/2216569\n\n\u003e Do we have guidance for vendors to implement it?\n\nag/19966971 is an example (internal only for now) on how to implement this.\n\nThe default atrace HAL in https://cs.android.com/android/platform/superproject/+/master:hardware/interfaces/atrace/1.0/default/ will be migrated to this format as well.\n\nDo we need to add documentation anywhere else?\n\n\u003e How do we make sure we continue to support it in the future?\n\nProtobuf messages can be updated in a backwards compatible fashion. Is this not enough? Did you have something else in mind?\n\nThanks!",
      "parentUuid": "d1ecddef_028a6933",
      "range": {
        "startLine": 78,
        "startChar": 74,
        "endLine": 78,
        "endChar": 76
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "6c9a5a4d_216d0081",
        "filename": "cmds/atrace/atrace.cpp",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-10-12T00:56:45Z",
      "side": 1,
      "message": "We generally require infrastructure in place to automatically warn if backwards compatible changes are made.\n\nCan we use a human-readable format on disk?",
      "parentUuid": "ac18a652_52d75454",
      "range": {
        "startLine": 78,
        "startChar": 74,
        "endLine": 78,
        "endChar": 76
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2d97b6ca_0ceb7f83",
        "filename": "cmds/atrace/atrace.cpp",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1896186
      },
      "writtenOn": "2022-10-14T08:53:38Z",
      "side": 1,
      "message": "\u003e We generally require infrastructure in place to automatically warn if backwards compatible changes are made.\n\nCurrently, if I made a backward incompatible change to the .proto schema, the .textproto in hardware/google/pixel (I\u0027ll add one to hardware/interfaces as well) would fail to compile.\n\nIsn\u0027t that the same that would happen with types.hal? Is there something more in that case?\n\n\u003e  Can we use a human-readable format on disk?\n\nThat was my first instinct, but I decided against it ultimately, because:\n\n* The format is not as trivial. We have:\n\n```\ncategories {\n  name\n  description\n  events [\n    event\n    event\n  ]\n}\n```\n\nI don\u0027t have a very natural way to flatten that (e.g. to csv)\n\n* Backwards compatiblity would be much harder to maintain. With the protobuf binary format, there are a lot of checks at compilation time (when the textproto is converted to binary proto). I have some potential future extension in mind that require good backwards compatibility (right now we only support \"group/event\", in the future we might want to support \"group/*\")\n\nThat said, I\u0027m not particularly attached to protobuf, if you have ideas for a better format, I\u0027m open.\n\nThanks!",
      "parentUuid": "6c9a5a4d_216d0081",
      "range": {
        "startLine": 78,
        "startChar": 74,
        "endLine": 78,
        "endChar": 76
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "feacf6d9_cdf1aec5",
        "filename": "cmds/atrace/atrace.cpp",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-10-18T23:24:55Z",
      "side": 1,
      "message": "I mean - Android supported xml + xsd schema for this, but it\u0027s a bit heavy weight. That used to be the requirement, but I would be okay with any text format. JSON - like APEX manifests are now? Being able to read this stuff on disk and use any editor to edit it makes everything a lot simpler.",
      "parentUuid": "2d97b6ca_0ceb7f83",
      "range": {
        "startLine": 78,
        "startChar": 74,
        "endLine": 78,
        "endChar": 76
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "aa12813f_f847b18a",
        "filename": "cmds/atrace/atrace.cpp",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1896186
      },
      "writtenOn": "2022-10-21T09:35:40Z",
      "side": 1,
      "message": "Funny you mention APEX manifests: APEX manifests used to be JSON directly on disk, but on R+ they became binary proto (I think for good reasons). The fact that the format on disk was JSON actually caused problems (https://cs.android.com/android/platform/superproject/+/master:build/soong/apex/builder.go;l\u003d251;drc\u003df648d531547cf51585e183bede1f074ea4fb3190). I think this pretty much excludes using JSON as an on disk format.\n\n1. I could use JSON as source, but then I would need an explicit python build script to generate the binary, instead of reusing protoc, like I do today. Using JSON as source and pb as on disk, matches APEX manifests.\n\n2. I could parse an ad-hoc csv-like text format, but it would not be very simple (I showed that the format can benefit from some nesting) and maintaining backwards compatibility would be hard.\n\n3. I could go for xml + xsd, given that there\u0027s precedent. Downsides are implementation complexity (I have no experience with libraries in android to parse that) and the fact that our sideloaded perfetto build would not support reading the files, but that\u0027s no big deal, I suppose.\n\nI still think the current approach is the best, but I\u0027m open to the solutions 1, 2, 3 above, or any other reasonable proposal.",
      "parentUuid": "feacf6d9_cdf1aec5",
      "range": {
        "startLine": 78,
        "startChar": 74,
        "endLine": 78,
        "endChar": 76
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0ae893bf_bafc7f48",
        "filename": "cmds/atrace/atrace.cpp",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-10-24T21:35:26Z",
      "side": 1,
      "message": "Reading the bug (b/143654022) - the problem with this was a bad JSON file schema, an overly strict parser rejecting certain properties. I think they should have fixed this and tested it instead of switching to a new format: it\u0027s not a problem intrinsic to JSON. If not for any other reason, this is an interface for people to use/implement, not an internal Android fwk interface. This has to be easy for anyone to add their trace formats to.\n\nThe issue with binary formats historically, why this is the UNIX design philosophy, etc... is because anyone can edit a human-readable file, but not anyone can build protobuf anyway. Sure, it works. Sure, it\u0027s debuggable (if you know the right incantations), but you can\u0027t debug it with nano over uart at 3am in the dark etc... We want the format to be human readable so anyone can use it automatically, not have to learn how to use protobuf. Sure you say \"they can learn protobuf\" - in practice - it means some people will choose not to use custom categories. I want to be able to edit the file on disk of a running device, see what happens - not rebuild protobuf.\n\nBtw - do we have Protobuf JSON parsers in Android? You might be able to keep everything the same except the binary format on disk. Otherwise, I like 1 then 3 honestly (not 2 b/c backwards compatibility difficulties).\n\nWDYT?",
      "parentUuid": "aa12813f_f847b18a",
      "range": {
        "startLine": 78,
        "startChar": 74,
        "endLine": 78,
        "endChar": 76
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "45e9a95f_c8b7ada9",
        "filename": "cmds/atrace/atrace.cpp",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-10-26T21:47:49Z",
      "side": 1,
      "message": "or .textproto - I saw this was a thing yesterday",
      "parentUuid": "0ae893bf_bafc7f48",
      "range": {
        "startLine": 78,
        "startChar": 74,
        "endLine": 78,
        "endChar": 76
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d641c50e_41eb0709",
        "filename": "cmds/atrace/atrace.cpp",
        "patchSetId": 1
      },
      "lineNbr": 78,
      "author": {
        "id": 1896186
      },
      "writtenOn": "2022-12-12T19:12:42Z",
      "side": 1,
      "message": "As discussed offline, I switched to a text file.\n\nPTAL, thanks!",
      "parentUuid": "45e9a95f_c8b7ada9",
      "range": {
        "startLine": 78,
        "startChar": 74,
        "endLine": 78,
        "endChar": 76
      },
      "revId": "307931a4f0f2a4e8de07c4716b4ca957fcb27a70",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}