//! This crate lets you use the Tokio `spawn_blocking` pool with AIDL in async
//! Rust code.
//!
//! This crate works by defining a type [`Tokio`], which you can use as the
//! generic parameter in the async version of the trait generated by the AIDL
//! compiler.
//! ```text
//! use binder_tokio::Tokio;
//!
//! binder::get_interface::<dyn SomeAsyncInterface<Tokio>>("...").
//! ```
//!
//! [`Tokio`]: crate::Tokio

use binder::public_api::{BinderAsyncPool, BoxFuture, Result};
use binder::StatusCode;
use std::future::Future;

mod sync_wrapper;
use self::sync_wrapper::SyncWrapper;

/// Use the Tokio `spawn_blocking` pool with AIDL.
pub enum Tokio {}

impl BinderAsyncPool for Tokio {
    fn spawn<'a, F1, F2, Fut, A, B>(spawn_me: F1, after_spawn: F2) -> BoxFuture<'a, Result<B>>
    where
        F1: FnOnce() -> A,
        F2: FnOnce(A) -> Fut,
        Fut: Future<Output = Result<B>>,
        F1: Send + 'static,
        F2: Send + 'a,
        Fut: Send + 'a,
        A: Send + 'static,
        B: Send + 'a
    {
        let handle = tokio::task::spawn_blocking(spawn_me);
        Box::pin(SyncWrapper::new(async move {
            // The `is_panic` branch is not actually reachable in Android as we compile
            // with `panic = abort`.
            match handle.await {
                Ok(res) => after_spawn(res).await,
                Err(e) if e.is_panic() => std::panic::resume_unwind(e.into_panic()),
                Err(e) if e.is_cancelled() => Err(StatusCode::FAILED_TRANSACTION.into()),
                Err(_) => Err(StatusCode::UNKNOWN_ERROR.into()),
            }
        }))
    }
}


