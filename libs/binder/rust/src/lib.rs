/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! Safe Rust interface to Android `libbinder`.
//!
//! This crate is primarily designed as an target for a Rust AIDL compiler
//! backend, and should generally not be used directly by users. It is built on
//! top of the binder NDK library to be usable by APEX modules, and therefore
//! only exposes functionality available in the NDK interface.
//!
//! # Example
//!
//! The following example illustrates how the AIDL backend will use this crate.
//!
//! ```
//! use binder::{binder_fn_get_class, Binder, IBinder, Remotable, Parcel, SpIBinder};
//!
//! // Generated by AIDL compiler
//! pub trait ITest {
//!     // DESCRIPTOR is required for Binder Interfaces
//!     const DESCRIPTOR: &'static str = "android.os.ITest";
//!
//!     fn test(&self) -> binder::Result<String>;
//! }
//!
//! // Local implementation of the ITest remotable interface.
//! struct TestService;
//!
//! // Generated by AIDL compiler
//! impl Remotable for TestService {
//!     const DESCRIPTOR: &'static str = <Self as ITest>::DESCRIPTOR;
//!
//!     fn on_transact(
//!         &self,
//!         _code: TransactionCode,
//!         _data: &Parcel,
//!         reply: &mut Parcel,
//!         _flags: TransactionFlags,
//!     ) -> binder::Result<()> {
//!         reply.write(&self.test()?)?;
//!         Ok(())
//!     }
//!
//!     binder_fn_get_class!(Binder<Self>);
//! }
//!
//! // User provided
//! impl ITest for TestService {
//!     fn test(&self) -> binder::Result<String> {
//!        Ok("testing service".to_string())
//!     }
//! }
//!
//! // Creates a new proxy, BpTest, that will wrap a remote object
//! // implementing ITest over binder.
//! // Generated by AIDL compiler
//! declare_binder_proxy!(BpTest{}: ITest);
//!
//! // Generated by AIDL compiler
//! impl ITest for BpTest {
//!     fn test(&self) -> binder::Result<String> {
//!        let reply = self
//!            .binder
//!            .transact(SpIBinder::FIRST_CALL_TRANSACTION, 0, |_| Ok(()))?;
//!        reply.read()
//!     }
//! }
//! ```

#[macro_use]
mod proxy;

mod binder;
mod error;
mod native;
mod state;
mod sys;

pub mod interfaces;
pub mod parcel;

pub use binder::{
    IBinder, Interface, InterfaceClass, Remotable, TransactionCode, TransactionFlags,
};
pub use error::{status_t, Result, Status, StatusCode};
pub use native::add_service;
pub use native::Binder;
pub use parcel::Parcel;
pub use proxy::{get_interface, get_service};
pub use proxy::{DeathRecipient, SpIBinder, WpIBinder};
pub use state::{ProcessState, ThreadState};

/// Re-exports of core structures with potentially conflicting identifiers
/// prefixed with `Binder`.
///
/// This module renames binder exports so they be glob-imported without
/// conflicting with standard structures. Import the prelude with:
/// ```rust
/// use binder::prelude::*;
/// ```
pub mod prelude {
    pub use super::Interface as BinderInterface;
    pub use super::InterfaceClass as BinderInterfaceClass;
    pub use super::Parcel as BinderParcel;
    pub use super::Remotable as BinderRemotable;
    pub use super::Result as BinderResult;
    pub use super::Status as BinderStatus;
    pub use super::StatusCode as BinderStatusCode;
    pub use super::TransactionCode as BinderTransactionCode;
    pub use super::{Binder, IBinder, SpIBinder, WpIBinder};
}
