/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! Manually implemented IServiceManager AIDL interface.
// This interface will be automatically generated by the AIDL compiler when its
// Rust backend is finished. This manual implementation is an example of what
// the auto-generated code should look like.

use crate::proxy::SpIBinder;
use crate::{IBinder, Status, StatusCode};

#[repr(i32)]
#[non_exhaustive]
pub enum DumpFlags {
    // Must match values in IServiceManager.aidl
    /// Allows services to dump sections according to priorities.
    PriorityCritical = 1,
    PriorityHigh = 2,
    PriorityNormal = 4,
    /// Services are by default registered with a Default dump priority. Default
    /// priority has the same priority as Normal priority but the services are
    /// not called with dump priority arguments.
    PriorityDefault = 8,
    PriorityAll = 15,
    Proto = 16,
}

declare_binder_proxy!(BpServiceManager {}: IServiceManager);

/// Binder interface for finding and publishing system services.
pub trait IServiceManager {
    const DESCRIPTOR: &'static str = "android.os.IServiceManager";

    /// Retrieve an existing service called `name` from the service manager.
    ///
    /// This is the same as checkService (returns immediately) but exists for
    /// legacy purposes.
    ///
    /// Returns null if the service does not exist.
    fn get_service(&mut self, name: &str) -> Result<SpIBinder, Status>;

    /// Retrieve an existing service called `name` from the service
    /// manager. Non-blocking. Returns null if the service does not exist.
    fn check_service(&mut self, name: &str) -> Result<SpIBinder, Status>;

    /// Place a new service called `name` into the service manager.
    fn add_service(
        &mut self,
        name: &str,
        service: &SpIBinder,
        allow_isolated: bool,
        dumpsys_flags: DumpFlags,
    ) -> Result<(), Status>;

    /// Return a list of all currently running services.
    fn list_services(&mut self, dump_priority: DumpFlags) -> Result<Vec<String>, Status>;

    /// Returns whether a given interface is declared on the device, even if it
    /// is not started yet. For instance, this could be a service declared in
    /// the VINTF manifest.
    fn is_declared(&mut self, name: &str) -> Result<bool, Status>;
}

impl IServiceManager for BpServiceManager {
    fn get_service(&mut self, name: &str) -> Result<SpIBinder, Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 0, // getService
            0,
            |data| data.write(name),
        )?;
        let status: Status = reply.read()?;
        if !status.is_ok() {
            return Err(status);
        }
        let service: Option<SpIBinder> = reply.read()?;
        service.ok_or(StatusCode::UNEXPECTED_NULL.into())
    }

    fn check_service(&mut self, name: &str) -> Result<SpIBinder, Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 1, // checkService
            0,
            |data| data.write(name),
        )?;
        let status: Status = reply.read()?;
        if !status.is_ok() {
            return Err(status);
        }
        let service: Option<SpIBinder> = reply.read()?;
        service.ok_or(StatusCode::UNEXPECTED_NULL.into())
    }

    fn add_service(
        &mut self,
        name: &str,
        service: &SpIBinder,
        allow_isolated: bool,
        dump_priority: DumpFlags,
    ) -> Result<(), Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 2, // addService
            0,
            |data| {
                data.write(name)?;
                data.write(service)?;
                data.write(&allow_isolated)?;
                data.write(&(dump_priority as i32))
            },
        )?;
        let status: Status = reply.read()?;
        status.into()
    }

    fn list_services(&mut self, dump_priority: DumpFlags) -> Result<Vec<String>, Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 3, // listServices
            0,
            |data| data.write(&(dump_priority as i32)),
        )?;
        let status: Status = reply.read()?;
        if !status.is_ok() {
            return Err(status);
        }

        reply.read().map_err(|e| e.into())
    }

    fn is_declared(&mut self, name: &str) -> Result<bool, Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 6, // isDeclared
            0,
            |data| data.write(name),
        )?;
        let status: Status = reply.read()?;
        if !status.is_ok() {
            return Err(status);
        }
        reply.read().map_err(|e| e.into())
    }
}

#[test]
fn test_get_service() {
    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");
    let mut sm = sm
        .get_service("manager")
        .expect("Did not get manager binder service via IServiceManager interface");
    assert!(sm.is_binder_alive());
    assert!(sm.ping_binder().is_ok());
}

#[test]
fn test_check_service() {
    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");
    let mut sm = sm
        .check_service("manager")
        .expect("Did not get manager binder service via IServiceManager interface");
    assert!(sm.is_binder_alive());
    assert!(sm.ping_binder().is_ok());
}

#[test]
fn test_add_service() {
    use crate::{binder_fn_get_class, Binder, Parcel, Remotable, TransactionCode};

    struct TestService;

    impl Remotable for TestService {
        const DESCRIPTOR: &'static str = "TestService";

        fn on_transact(
            &self,
            _code: TransactionCode,
            _data: &Parcel,
            reply: &mut Parcel,
        ) -> Result<(), StatusCode> {
            reply.write("testing service")?;
            Ok(())
        }

        binder_fn_get_class!(Binder<Self>);
    }

    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");

    let binder_native = Binder::new(TestService);
    assert!(sm
        .add_service(
            "testing",
            &binder_native.as_binder(),
            false,
            DumpFlags::PriorityDefault
        )
        .is_ok());
}

#[test]
fn test_is_declared() {
    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");
    // TODO: Figure out how to test a true result from is_declared. AFAICT this
    // requires a VINTF interface?
    assert!(!sm.is_declared("bogus_service").unwrap());
}

#[test]
fn test_list_services() {
    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");
    let service_list = sm.list_services(DumpFlags::PriorityDefault).unwrap();
    assert!(service_list.len() > 0);
}
