/*
 * Copyright (C) 2020 The Android Open Source Project
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//! Manually implemented IServiceManager AIDL interface.
// This interface will be automatically generated by the AIDL compiler when its
// Rust backend is finished. This manual implementation is an example of what
// the auto-generated code should look like.

use crate::proxy::SpIBinder;
use crate::{declare_binder_interface, IBinder, Parcel, Status, StatusCode, TransactionCode};

#[repr(i32)]
#[non_exhaustive]
pub enum DumpFlags {
    // Must match values in IServiceManager.aidl
    /// Allows services to dump sections according to priorities.
    PriorityCritical = 1,
    PriorityHigh = 2,
    PriorityNormal = 4,
    /// Services are by default registered with a Default dump priority. Default
    /// priority has the same priority as Normal priority but the services are
    /// not called with dump priority arguments.
    PriorityDefault = 8,
    PriorityAll = 15,
    Proto = 16,
}

declare_binder_interface! {
    IServiceManager["android.os.IServiceManager"] {
        native: UnimplementedLocalServiceManager(unimplemented_on_transact),
        proxy: BpServiceManager,
    }
}

fn unimplemented_on_transact(
    _service: &dyn IServiceManager,
    _code: TransactionCode,
    _data: &Parcel,
    _reply: &mut Parcel,
) -> Result<(), StatusCode> {
    unimplemented!("ServiceManager is not implemented locally in Rust");
}

/// Binder interface for finding and publishing system services.
pub trait IServiceManager {
    /// Retrieve an existing service called `name` from the service manager.
    ///
    /// This is the same as checkService (returns immediately) but exists for
    /// legacy purposes.
    ///
    /// Returns null if the service does not exist.
    fn get_service(&mut self, name: &str) -> Result<SpIBinder, Status>;

    /// Retrieve an existing service called `name` from the service
    /// manager. Non-blocking. Returns null if the service does not exist.
    fn check_service(&mut self, name: &str) -> Result<SpIBinder, Status>;

    /// Place a new service called `name` into the service manager.
    fn add_service(
        &mut self,
        name: &str,
        service: &SpIBinder,
        allow_isolated: bool,
        dumpsys_flags: DumpFlags,
    ) -> Result<(), Status>;

    /// Return a list of all currently running services.
    fn list_services(&mut self, dump_priority: DumpFlags) -> Result<Vec<String>, Status>;

    /// Returns whether a given interface is declared on the device, even if it
    /// is not started yet. For instance, this could be a service declared in
    /// the VINTF manifest.
    fn is_declared(&mut self, name: &str) -> Result<bool, Status>;
}

impl IServiceManager for BpServiceManager {
    fn get_service(&mut self, name: &str) -> Result<SpIBinder, Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 0, // getService
            0,
            |data| data.write(name),
        )?;
        let status: Status = reply.read()?;
        if !status.is_ok() {
            return Err(status);
        }
        let service: Option<SpIBinder> = reply.read()?;
        service.ok_or(StatusCode::UNEXPECTED_NULL.into())
    }

    fn check_service(&mut self, name: &str) -> Result<SpIBinder, Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 1, // checkService
            0,
            |data| data.write(name),
        )?;
        let status: Status = reply.read()?;
        if !status.is_ok() {
            return Err(status);
        }
        let service: Option<SpIBinder> = reply.read()?;
        service.ok_or(StatusCode::UNEXPECTED_NULL.into())
    }

    fn add_service(
        &mut self,
        name: &str,
        service: &SpIBinder,
        allow_isolated: bool,
        dump_priority: DumpFlags,
    ) -> Result<(), Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 2, // addService
            0,
            |data| {
                data.write(name)?;
                data.write(service)?;
                data.write(&allow_isolated)?;
                data.write(&(dump_priority as i32))
            },
        )?;
        let status: Status = reply.read()?;
        status.into()
    }

    fn list_services(&mut self, dump_priority: DumpFlags) -> Result<Vec<String>, Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 3, // listServices
            0,
            |data| data.write(&(dump_priority as i32)),
        )?;
        let status: Status = reply.read()?;
        if !status.is_ok() {
            return Err(status);
        }

        reply.read().map_err(|e| e.into())
    }

    fn is_declared(&mut self, name: &str) -> Result<bool, Status> {
        let reply = self.binder.transact(
            SpIBinder::FIRST_CALL_TRANSACTION + 6, // isDeclared
            0,
            |data| data.write(name),
        )?;
        let status: Status = reply.read()?;
        if !status.is_ok() {
            return Err(status);
        }
        reply.read().map_err(|e| e.into())
    }
}

#[test]
fn test_get_service() {
    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");
    let mut sm = sm
        .get_service("manager")
        .expect("Did not get manager binder service via IServiceManager interface");
    assert!(sm.is_binder_alive());
    assert!(sm.ping_binder().is_ok());
}

#[test]
fn test_check_service() {
    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");
    let mut sm = sm
        .check_service("manager")
        .expect("Did not get manager binder service via IServiceManager interface");
    assert!(sm.is_binder_alive());
    assert!(sm.ping_binder().is_ok());
}

#[test]
fn test_add_service() {
    use crate::{Binder, Parcel, Remotable, TransactionCode};
    use std::sync::Arc;

    trait ITest {}

    #[derive(Copy, Clone)]
    struct TestService;

    impl Remotable for TestService {
        type Interface = dyn ITest;

        fn get_descriptor() -> &'static str {
            "TestService"
        }

        fn on_transact(
            &self,
            _code: TransactionCode,
            _data: &Parcel,
            reply: &mut Parcel,
        ) -> Result<(), StatusCode> {
            reply.write("testing service")?;
            Ok(())
        }

        fn as_interface(&self) -> Arc<Self::Interface> {
            Arc::new(*self)
        }

        binder_fn_get_class!(Binder<Self>);
    }

    impl ITest for TestService {}

    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");

    let binder_native = Binder::new(TestService);
    assert!(sm
        .add_service(
            "testing",
            &binder_native.as_binder(),
            false,
            DumpFlags::PriorityDefault
        )
        .is_ok());
}

#[test]
fn test_is_declared() {
    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");
    // TODO: Figure out how to test a true result from is_declared. AFAICT this
    // requires a VINTF interface?
    assert!(!sm.is_declared("bogus_service").unwrap());
}

#[test]
fn test_list_services() {
    let mut sm: BpServiceManager =
        crate::get_interface("manager").expect("Did not get manager binder service");
    let service_list = sm.list_services(DumpFlags::PriorityDefault).unwrap();
    assert!(service_list.len() > 0);
}
