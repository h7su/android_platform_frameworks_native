{
  "comments": [
    {
      "key": {
        "uuid": "5a4f777e_f9bed1a4",
        "filename": "opengl/tools/glgen/stubs/egl/EGL14cHeader.cpp",
        "patchSetId": 2
      },
      "lineNbr": 17,
      "author": {
        "id": 1010056
      },
      "writtenOn": "2014-11-11T23:55:12Z",
      "side": 1,
      "message": "Where are these generated from? Any changes in this CL seem like they are going to get wiped out if/when we refresh.",
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a4f777e_b97859ef",
        "filename": "opengl/tools/glgen/stubs/egl/EGL14cHeader.cpp",
        "patchSetId": 2
      },
      "lineNbr": 17,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-11-12T00:20:00Z",
      "side": 1,
      "message": "Nope. This is the source for the auto-generated files in frameworks/base/core/jni. This is copied verbatim into the target files...",
      "parentUuid": "5a4f777e_f9bed1a4",
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7ac51b23_97aeaef6",
        "filename": "opengl/tools/glgen/stubs/gles11/glDrawArraysIndirect.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-11-11T08:34:00Z",
      "side": 1,
      "message": "I don\u0027t understand the comment above and am open for opinions. Maybe this should just be static_cast\u003cjlong\u003e(UINT32_MAX)...",
      "range": {
        "startLine": 6,
        "startChar": 53,
        "endLine": 6,
        "endChar": 84
      },
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7ac51b23_224a1674",
        "filename": "opengl/tools/glgen/stubs/gles11/glDrawArraysIndirect.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 1010672
      },
      "writtenOn": "2014-11-11T14:44:55Z",
      "side": 1,
      "message": "The code is trying to check whether \u0027indirect\u0027, a signed 64-bit value, is larger than the maximum 32-bit pointer value. If not, the cast in the call to glDrawArraysIndirect will modify the bits, and the call won\u0027t do what the app intended.\n\nWhat warning are you getting here? Does the warning only happen in 64-bit builds (or only in 32-bit)?",
      "parentUuid": "7ac51b23_97aeaef6",
      "range": {
        "startLine": 6,
        "startChar": 53,
        "endLine": 6,
        "endChar": 84
      },
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a4f777e_e74ab11f",
        "filename": "opengl/tools/glgen/stubs/gles11/glDrawArraysIndirect.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-11-11T17:14:47Z",
      "side": 1,
      "message": "The warning is a signed-compare warning on 64b, as there UINTPTR_MAX is 64b unsigned.\n\nFrom your description, the right thing here will be UINT32_MAX. Would you agree?",
      "parentUuid": "7ac51b23_224a1674",
      "range": {
        "startLine": 6,
        "startChar": 53,
        "endLine": 6,
        "endChar": 84
      },
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "5a4f777e_19640dbe",
        "filename": "opengl/tools/glgen/stubs/gles11/glDrawArraysIndirect.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 1010056
      },
      "writtenOn": "2014-11-11T23:55:12Z",
      "side": 1,
      "message": "I think UINT32_MAX is a better value to use here. It is doing exactly that (making sure that you don\u0027t have a value that won\u0027t fit in 32-bits, but only on 32-bit compiles).",
      "parentUuid": "5a4f777e_e74ab11f",
      "range": {
        "startLine": 6,
        "startChar": 53,
        "endLine": 6,
        "endChar": 84
      },
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9ab9efac_07ab766c",
        "filename": "opengl/tools/glgen/stubs/gles11/glDrawArraysIndirect.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 1010672
      },
      "writtenOn": "2014-11-12T00:31:46Z",
      "side": 1,
      "message": "(I thought I added this comment, but apparently not. Anyway, it\u0027s not worth arguing about. Feel free to switch to UINT32_MAX).\n\nI don\u0027t get it: we cast UINTPTR_MAX to jlong, which is the same type as \u0027indirect\u0027. The types in that comparison should always match, because the code forces them to.\n\nWe want to compare against the maximum pointer value, if pointer is different size than the Java \u0027indirect\u0027 value. Using UINT32_MAX would work but it doesn\u0027t express the intent as well. Not a big deal to change it, but (as I said above) I don\u0027t understand why we need to.",
      "parentUuid": "5a4f777e_e74ab11f",
      "range": {
        "startLine": 6,
        "startChar": 53,
        "endLine": 6,
        "endChar": 84
      },
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "7aaefb66_2f68c964",
        "filename": "opengl/tools/glgen/stubs/gles11/glDrawArraysIndirect.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 1010056
      },
      "writtenOn": "2014-11-12T00:39:40Z",
      "side": 1,
      "message": "For 64-bit compiles, nothing can be \u003e UINTPTR_MAX, so that it provably false. I think that is the warning that must be firing for Andreas. It is more correct to switch to UINT32_MAX, because that is the only case that you are comparing it for actually.",
      "parentUuid": "9ab9efac_07ab766c",
      "range": {
        "startLine": 6,
        "startChar": 53,
        "endLine": 6,
        "endChar": 84
      },
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3aa8035b_474ad0a6",
        "filename": "opengl/tools/glgen/stubs/gles11/glDrawArraysIndirect.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 1041833
      },
      "writtenOn": "2014-11-12T04:09:55Z",
      "side": 1,
      "message": "The warning is that indirect is a jlong, which is basically int64_t, whereas UINTPTR_MAX is uint64_t. So you have a signed value on the left and an unsigned value on the right.\n\nI added the cast to ensure the same types. But that cast will have the value -1 on 64bit system, which is not what\u0027s expected, at least from what I understand from your explanation.\n\nI am not sure what a \"32bit pointer value\" is. What is meant by that on a 64bit system?\n\nReplacing UINTPTR_MAX with UINT32_MAX will basically ask whether indirect \u003e 4G (\u003e32bit). I\u0027ll wait with the submission until tomorrow in case that is not what is needed here.",
      "parentUuid": "7aaefb66_2f68c964",
      "range": {
        "startLine": 6,
        "startChar": 53,
        "endLine": 6,
        "endChar": 84
      },
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "3aa8035b_4a7897ee",
        "filename": "opengl/tools/glgen/stubs/gles11/glDrawArraysIndirect.cpp",
        "patchSetId": 2
      },
      "lineNbr": 6,
      "author": {
        "id": 1010672
      },
      "writtenOn": "2014-11-12T16:09:53Z",
      "side": 1,
      "message": "Let\u0027s just use UINT32_MAX. Like I said, it\u0027s not worth spending time on.\n\nI\u0027m just being pedantic. As written, the code is correct (I believe) regardless of the sizes of pointer and jlong. It\u0027s just checking that, if they have different sizes, a jlong value can be cast to void* losslessly. That\u0027s why it uses UINTPTR_MAX, because that\u0027s the max value of a pointer, which is what it\u0027s going to cast to. At that point in the expression we\u0027ve already established that pointers and jlongs have different size, so it doesn\u0027t matter what happens to UINTPTR_MAX when it overflows jlong. Using UINT32_MAX bakes in the assumption that if the size is different, then pointers are 32 bits; using UINTPTR_MAX does not make that assumption about pointer size.\n\nBut in practice that assumption is always true, and is going to be true for the foreseeable lifetime of this code. So whatever.",
      "parentUuid": "3aa8035b_474ad0a6",
      "range": {
        "startLine": 6,
        "startChar": 53,
        "endLine": 6,
        "endChar": 84
      },
      "revId": "00018b3c5254a335340c645a658af6ba3423c72e",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    }
  ]
}