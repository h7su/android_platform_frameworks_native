{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "da4f3c0c_78d61dfc",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-01-09T23:34:53Z",
      "side": 1,
      "message": "is this done in order to use xor in the check or for another reason? It\u0027s only one additional instruction, but I\u0027m not sure what we get from doing this as opposed to storing the sum and then checking it.",
      "range": {
        "startLine": 52,
        "startChar": 44,
        "endLine": 54,
        "endChar": 15
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "919023b8_d34d3304",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-10T00:56:34Z",
      "side": 1,
      "message": "It _had_ been part of a brief effort to allow for the checksum calculation on the read path to run over the whole chunk and result in zero, because the data included the checksum.",
      "parentUuid": "da4f3c0c_78d61dfc",
      "range": {
        "startLine": 52,
        "startChar": 44,
        "endLine": 54,
        "endChar": 15
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "857b01b4_31196883",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-01-10T21:44:57Z",
      "side": 1,
      "message": "Here\u0027s a fun one for you: if a xor-based checksum is done, by setting itself to 0, then setting the checksum ensures that the xor-based checksum becomes 0. Maybe that\u0027s too fun though.",
      "parentUuid": "919023b8_d34d3304",
      "range": {
        "startLine": 52,
        "startChar": 44,
        "endLine": 54,
        "endChar": 15
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5ef4d25c_bcbca375",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-11T21:09:57Z",
      "side": 1,
      "message": "Yep. I passed through that in my journey to the first patchset.",
      "parentUuid": "857b01b4_31196883",
      "range": {
        "startLine": 52,
        "startChar": 44,
        "endLine": 54,
        "endChar": 15
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "a0b3128d_670dc423",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 54,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-12T16:23:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "5ef4d25c_bcbca375",
      "range": {
        "startLine": 52,
        "startChar": 44,
        "endLine": 54,
        "endChar": 15
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "f70a597a_2461d882",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-01-09T23:34:53Z",
      "side": 1,
      "message": "nit: I guess paddingSize should be 0-3 - we could make the entire descriptor 64-bits if we wanted (16 bits for reserved, 14 for type, 2 for padding). Though it\u0027s probably overkill.",
      "range": {
        "startLine": 61,
        "startChar": 6,
        "endLine": 62,
        "endChar": 28
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "dffee8cb_39cb64e4",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-10T00:56:34Z",
      "side": 1,
      "message": "Padding could be as high as 7. But could still have 8000 chunk types while keeping 16 bits in reserve.\n\nI might pack this down a bit, or consider moving the checksum here and rearrange a bit more.",
      "parentUuid": "f70a597a_2461d882",
      "range": {
        "startLine": 61,
        "startChar": 6,
        "endLine": 62,
        "endChar": 28
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "ec116565_3d676285",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-11T21:09:57Z",
      "side": 1,
      "message": "Cleaned this up. Let me know what you think.",
      "parentUuid": "dffee8cb_39cb64e4",
      "range": {
        "startLine": 61,
        "startChar": 6,
        "endLine": 62,
        "endChar": 28
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "8a35d9b1_9eff18a6",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 62,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-12T16:42:52Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "ec116565_3d676285",
      "range": {
        "startLine": 61,
        "startChar": 6,
        "endLine": 62,
        "endChar": 28
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "045e9694_2d698ffa",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-01-09T23:34:53Z",
      "side": 1,
      "message": "note: libbinder has integer sanitization on by default, so if this overflows, it would crash. 2^64/2^8 is still 2^56. However - if we used the reserved piece, 2^32/2^8 \u003d 2^24 which would theoretically be reachable.\n\nI was expecting this to be `*sum ^\u003d *p` to avoid this problem (and still fit into the size). If byte_count%4\u003d\u003d0, then `const uint32_t* limit` would be appropriate for calculating an arbitrarily scalable checksum based on this.\n\nAlso - note - checksum at the end - this is being added to the end of a chunk. Since it\u0027s outside of the frame, I\u0027m worried it may be harder to maintain if we want to move away from this in the future, since reading the chunk itself would depend on this. Seeking back to the header to write a checksum is fine (though I get it may be slow - doing the checksum before calling the write functions would also be okay - it\u0027s not friendly to the caches, but it will detect certain types of memory corruption that race with the write).\n\nxor sum or crc check may be more usual. I\u0027m happy with the sum if you like it, but I found it surprising. Curious if you have any particular thoughts on it.",
      "range": {
        "startLine": 166,
        "startChar": 0,
        "endLine": 166,
        "endChar": 23
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d927f93_147132d2",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-10T00:56:34Z",
      "side": 1,
      "message": "I arrived at this in a very path-dependent way and will happily revisit. I wasn\u0027t sure the tradeoffs we wanted to make regarding error detection and performance. Based on your feedback here, it sounds like better error detection is favorable over performance?\n\nThe only crc implementation I found available was in skia, which I don\u0027t think is available at this level? And as shown by the skia implementation, I think we\u0027re targeting hardware with sse \u003c 4.2 and can\u0027t rely on the sse intrinsics.\n\nI started down the path of a Fletcher checksum instead, and what you see here is the remains of stripping that down in favor of reducing the number of passes we take over the data. -- The sum was a concession to using more bits for better chances of detecting an error given that I was only using an 8-bit stride, which doesn\u0027t give us great chances of discovering an error with xor alone.",
      "parentUuid": "045e9694_2d698ffa",
      "range": {
        "startLine": 166,
        "startChar": 0,
        "endLine": 166,
        "endChar": 23
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "596bf873_6fe25038",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-01-10T21:44:57Z",
      "side": 1,
      "message": "crc should only be 5-6 lines of C code, but honestly, let\u0027s do whatever is simplest here. I mostly suggested this to use the extra space we had in the header, since we might as well use it. It\u0027s mostly to prevent ourselves from trying to debug something when the file itself is corrupt and giving us garbage data. It\u0027s unlikely we would really hit this - unless we start making the format more complicated.",
      "parentUuid": "0d927f93_147132d2",
      "range": {
        "startLine": 166,
        "startChar": 0,
        "endLine": 166,
        "endChar": 23
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7521f307_d8ae17de",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 166,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-11T21:09:57Z",
      "side": 1,
      "message": "crc by the bit is certainly only a few lines. Doing it by byte or larger gives a huge speedup, but is helped by building a table. If we do then care about speed, using the arm neon and sse4.2 intrinsics seems like the right thing to do. It\u0027s not too much work to get there if we think crc is worthwhile here.\n\nI think what\u0027s here is sensible now, if I got the c++ right and you don\u0027t disagree with how I\u0027m using mmap and vectors. If we want to use crc, maybe I can add that in a follow-up patch before declaring a \"version 1\"?",
      "parentUuid": "596bf873_6fe25038",
      "range": {
        "startLine": 166,
        "startChar": 0,
        "endLine": 166,
        "endChar": 23
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "3d8428cd_01931e3b",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2023-01-09T23:34:53Z",
      "side": 1,
      "message": "(and same for others) define latest possible place to limit scope",
      "range": {
        "startLine": 207,
        "startChar": 0,
        "endLine": 207,
        "endChar": 51
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d43ea5d_58d4bf5e",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-10T00:56:34Z",
      "side": 1,
      "message": "Ack",
      "parentUuid": "3d8428cd_01931e3b",
      "range": {
        "startLine": 207,
        "startChar": 0,
        "endLine": 207,
        "endChar": 51
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "6d4685ce_70f18509",
        "filename": "libs/binder/BinderRecordReplay.cpp",
        "patchSetId": 1
      },
      "lineNbr": 207,
      "author": {
        "id": 1979435
      },
      "writtenOn": "2023-01-12T16:23:13Z",
      "side": 1,
      "message": "Done",
      "parentUuid": "9d43ea5d_58d4bf5e",
      "range": {
        "startLine": 207,
        "startChar": 0,
        "endLine": 207,
        "endChar": 51
      },
      "revId": "41fc16d3244511fb05fedeeb0cfbe28af8846080",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}