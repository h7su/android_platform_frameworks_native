{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ff495912_c75baa58",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-10-14T21:19:25Z",
      "side": 1,
      "message": "I\u0027m not sure I understand this. AParcel is always allocated on the heap in libbinder_ndk. Is there ever an instance where it isn\u0027t?",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f5e6ccb_aebf0e81",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T21:28:57Z",
      "side": 1,
      "message": "Sure, but that AParcel will internally point to C++ `Parcel`s allocated on the stack, right? I\u0027m talking about buffer and reply from IPCThreadState::executeCommand (https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/IPCThreadState.cpp#1249) which get wrapped by `AParcel`s (https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/ndk/ibinder.cpp#179) and then passed to Rust. This means that Rust indirectly holds pointers to C++ objects on the stack. Am I missing something here? Both buffer/data and reply seem to be passed by reference or pointer, respectively.\n\nI think a pointer to a pointer to a C++ stack object is still not safe to send between threads.",
      "parentUuid": "ff495912_c75baa58",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09bee6f4_3b21dafb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T21:33:28Z",
      "side": 1,
      "message": "Update: even the `AParcel`s seem to live on the stack: https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/ndk/ibinder.cpp#179.",
      "parentUuid": "7f5e6ccb_aebf0e81",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e31df36_5da1d974",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-10-14T21:45:44Z",
      "side": 1,
      "message": "I see, yeah. I was thinking more about AParcel_create, AIBinder_prepareTransaction, and AIBinder_transact which have the parcels on the stack. However, yes, when we are processing a command from another process, I guess it is on the stack.\n\nCould we reflect this in the Rust API without needing to create new types? For instance, when we execute a command, we should have \u0026Parcel (we should have a borrowed value only).",
      "parentUuid": "09bee6f4_3b21dafb",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ed79928_63bcd0f2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T22:03:09Z",
      "side": 1,
      "message": "We could add Send to Parcel and avoid OwnedParcel altogether, but then we would have to dynamically enforce that a Parcel::Borrowed doesn\u0027t escape the thread it was created in. We could store a TID in Parcel::Borrowed and check it before every operation (or just from as_native and as_native_mut) but that seems really excessive.\n\nPlus that would only produce errors at run time, whereas using an approach with split types would give us useful errors during compilation (if anyone tried to pass a BorrowedCppParcel between threads).",
      "parentUuid": "9e31df36_5da1d974",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}