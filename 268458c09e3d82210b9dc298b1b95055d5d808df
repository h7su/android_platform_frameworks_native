{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ff495912_c75baa58",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-10-14T21:19:25Z",
      "side": 1,
      "message": "I\u0027m not sure I understand this. AParcel is always allocated on the heap in libbinder_ndk. Is there ever an instance where it isn\u0027t?",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f5e6ccb_aebf0e81",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T21:28:57Z",
      "side": 1,
      "message": "Sure, but that AParcel will internally point to C++ `Parcel`s allocated on the stack, right? I\u0027m talking about buffer and reply from IPCThreadState::executeCommand (https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/IPCThreadState.cpp#1249) which get wrapped by `AParcel`s (https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/ndk/ibinder.cpp#179) and then passed to Rust. This means that Rust indirectly holds pointers to C++ objects on the stack. Am I missing something here? Both buffer/data and reply seem to be passed by reference or pointer, respectively.\n\nI think a pointer to a pointer to a C++ stack object is still not safe to send between threads.",
      "parentUuid": "ff495912_c75baa58",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09bee6f4_3b21dafb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T21:33:28Z",
      "side": 1,
      "message": "Update: even the `AParcel`s seem to live on the stack: https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/ndk/ibinder.cpp#179.",
      "parentUuid": "7f5e6ccb_aebf0e81",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e31df36_5da1d974",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-10-14T21:45:44Z",
      "side": 1,
      "message": "I see, yeah. I was thinking more about AParcel_create, AIBinder_prepareTransaction, and AIBinder_transact which have the parcels on the stack. However, yes, when we are processing a command from another process, I guess it is on the stack.\n\nCould we reflect this in the Rust API without needing to create new types? For instance, when we execute a command, we should have \u0026Parcel (we should have a borrowed value only).",
      "parentUuid": "09bee6f4_3b21dafb",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ed79928_63bcd0f2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T22:03:09Z",
      "side": 1,
      "message": "We could add Send to Parcel and avoid OwnedParcel altogether, but then we would have to dynamically enforce that a Parcel::Borrowed doesn\u0027t escape the thread it was created in. We could store a TID in Parcel::Borrowed and check it before every operation (or just from as_native and as_native_mut) but that seems really excessive.\n\nPlus that would only produce errors at run time, whereas using an approach with split types would give us useful errors during compilation (if anyone tried to pass a BorrowedCppParcel between threads).",
      "parentUuid": "9e31df36_5da1d974",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "808d0a0f_8f10dc23",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T22:26:38Z",
      "side": 1,
      "message": "\u003e For instance, when we execute a command, we should have \u0026Parcel (we should have a borrowed value only).\nI think I see what you\u0027re saying here, and that\u0027s sort of what we\u0027re already doing. Only a few places use Parcel::borrowed and the most significant one is native.rs (https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/rust/src/native.rs#280). This code passes one \u0026Parcel and one \u0026mut Parcel to on_transact(). The latter could be problematic since mutable references let you move the Parcel out of the reference. We might be able to change that into a \u0026Parcel if we rewrote all Parcel methods to take \u0026self, but I\u0027m not sure how safe that is.\n\nThe other problem is that there would be no way to guarantee that someone doesn\u0027t come in later and make changes to libbinder_rs where they create a new Parcel::Borrowed and then accidentally move it between threads.",
      "parentUuid": "2ed79928_63bcd0f2",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "d9b12dbe_3717f960",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1892347
      },
      "writtenOn": "2021-10-15T05:47:25Z",
      "side": 1,
      "message": "No, I don\u0027t think you could avoid OwnedParcel altogether. There\u0027s no way to insert a check when something gets sent across a thread, so you must have a separate type to send stuff. And we do need to be able to send them across threads for the async binder implementations.\n\nI will submit a follow-up PR that entirely removes the Parcel enum in favor of separate types for owned borrowed types, also removing any issues with moving out of a \u0026mut Parcel that exist now.\n\nRegarding the comment that this is on, the reason that it isn\u0027t safe to move a borrowed Parcel is essentially that parcels are Send but not Sync, i.e. it is safe to send across threads, but you can only access them from one thread at the time. However, sending a borrowed parcel means that the thread it was on before you sent it can still have a reference to it, allowing concurrent access from two threads.",
      "parentUuid": "808d0a0f_8f10dc23",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "a6347a52_466626bf",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-15T07:31:58Z",
      "side": 1,
      "message": "\u003e However, sending a borrowed parcel means that the thread it was on before you sent it can still have a reference to it, allowing concurrent access from two threads.\n\nThere\u0027s also an additional lifetime issue, I think. On the incoming transaction code path, we\u0027re \"borrowing\" (conceptually, not in the Rust sense) some parcels that live on the stack in C++. If we send those borrowed Rust `Parcel`s to another thread and then the original thread returns from executeCommand, the borrowed objects get destroyed while live pointers to them still exist.",
      "parentUuid": "d9b12dbe_3717f960",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0bb66bd5_321b1133",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-15T17:46:56Z",
      "side": 1,
      "message": "I guess you can count destroying an object as \"accessing\" it, so we\u0027re both talking about the same thing.",
      "parentUuid": "a6347a52_466626bf",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "c919243a_9cff283f",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1892347
      },
      "writtenOn": "2021-10-16T09:10:56Z",
      "side": 1,
      "message": "Well, you are right that destroying a value is somewhat different from what I was talking about, but in Rust-land, it is covered under a different rule: Destroying or moving an object can only happen if it is not borrowed, so if a reference to it exists anywhere (on the current thread or otherwise), destroying the object is not safe. This rule is the same no matter whether the type is Send or Sync or not.\n\nIt\u0027s probably worth pointing out that Send doesn\u0027t really have anything to do with transfer of ownership. The meaning of something being Send is that it is safe to access from threads other than the thread it was created on. The meaning of Sync is that it is safe to immutably access the value from several threads in parallel.\n\nSo if a type is Send but not Sync, then you can only access it from one thread at the time, even if your access is immutable. Similarly, if a type is Sync but not Send, then it can be accessed immutably from several threads in parallel, but mutable access must happen on the thread it was created on.",
      "parentUuid": "0bb66bd5_321b1133",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}