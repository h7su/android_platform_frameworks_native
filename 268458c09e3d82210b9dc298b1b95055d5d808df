{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "ff495912_c75baa58",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-10-14T21:19:25Z",
      "side": 1,
      "message": "I\u0027m not sure I understand this. AParcel is always allocated on the heap in libbinder_ndk. Is there ever an instance where it isn\u0027t?",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "7f5e6ccb_aebf0e81",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T21:28:57Z",
      "side": 1,
      "message": "Sure, but that AParcel will internally point to C++ `Parcel`s allocated on the stack, right? I\u0027m talking about buffer and reply from IPCThreadState::executeCommand (https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/IPCThreadState.cpp#1249) which get wrapped by `AParcel`s (https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/ndk/ibinder.cpp#179) and then passed to Rust. This means that Rust indirectly holds pointers to C++ objects on the stack. Am I missing something here? Both buffer/data and reply seem to be passed by reference or pointer, respectively.\n\nI think a pointer to a pointer to a C++ stack object is still not safe to send between threads.",
      "parentUuid": "ff495912_c75baa58",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "09bee6f4_3b21dafb",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T21:33:28Z",
      "side": 1,
      "message": "Update: even the `AParcel`s seem to live on the stack: https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/ndk/ibinder.cpp#179.",
      "parentUuid": "7f5e6ccb_aebf0e81",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9e31df36_5da1d974",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-10-14T21:45:44Z",
      "side": 1,
      "message": "I see, yeah. I was thinking more about AParcel_create, AIBinder_prepareTransaction, and AIBinder_transact which have the parcels on the stack. However, yes, when we are processing a command from another process, I guess it is on the stack.\n\nCould we reflect this in the Rust API without needing to create new types? For instance, when we execute a command, we should have \u0026Parcel (we should have a borrowed value only).",
      "parentUuid": "09bee6f4_3b21dafb",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "2ed79928_63bcd0f2",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T22:03:09Z",
      "side": 1,
      "message": "We could add Send to Parcel and avoid OwnedParcel altogether, but then we would have to dynamically enforce that a Parcel::Borrowed doesn\u0027t escape the thread it was created in. We could store a TID in Parcel::Borrowed and check it before every operation (or just from as_native and as_native_mut) but that seems really excessive.\n\nPlus that would only produce errors at run time, whereas using an approach with split types would give us useful errors during compilation (if anyone tried to pass a BorrowedCppParcel between threads).",
      "parentUuid": "9e31df36_5da1d974",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "808d0a0f_8f10dc23",
        "filename": "/COMMIT_MSG",
        "patchSetId": 4
      },
      "lineNbr": 13,
      "author": {
        "id": 1809582
      },
      "writtenOn": "2021-10-14T22:26:38Z",
      "side": 1,
      "message": "\u003e For instance, when we execute a command, we should have \u0026Parcel (we should have a borrowed value only).\nI think I see what you\u0027re saying here, and that\u0027s sort of what we\u0027re already doing. Only a few places use Parcel::borrowed and the most significant one is native.rs (https://android.googlesource.com/platform/frameworks/native/+/master/libs/binder/rust/src/native.rs#280). This code passes one \u0026Parcel and one \u0026mut Parcel to on_transact(). The latter could be problematic since mutable references let you move the Parcel out of the reference. We might be able to change that into a \u0026Parcel if we rewrote all Parcel methods to take \u0026self, but I\u0027m not sure how safe that is.\n\nThe other problem is that there would be no way to guarantee that someone doesn\u0027t come in later and make changes to libbinder_rs where they create a new Parcel::Borrowed and then accidentally move it between threads.",
      "parentUuid": "2ed79928_63bcd0f2",
      "range": {
        "startLine": 11,
        "startChar": 29,
        "endLine": 13,
        "endChar": 10
      },
      "revId": "268458c09e3d82210b9dc298b1b95055d5d808df",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}