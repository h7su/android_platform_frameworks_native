{
  "comments": [
    {
      "key": {
        "uuid": "6508e5fb_281947a6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-09-04T01:00:48Z",
      "side": 1,
      "message": "Looking at the commit message for 57e43365d941fddc06fa1e00e2256e66d84eff06 in cts/ I can see why you were wanting the other behavior. We have the same issue of not being able to distinguish between local Rust and local NDK binder objects in this case.\n\nI think the other way I suggested via email, being able to retrieve the class descriptor and check it client-side or being able to provide a descriptor to the object and query if it matches, might be better here. In this case the client could check the descriptor, and treat the local object as if it were remote if the descriptor matches. The bottom line is that the client needs some way of knowing whether it\u0027s dealing with an object its module created or not, while at the same time accessing a local binder from another module as if were remote.",
      "revId": "1b49ebdeb40e8efe93779f7816f85505c1b4d64c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9736c333_a258c052",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-04T01:10:53Z",
      "side": 1,
      "message": "Oops, yeah. I should have given that test a more explicit name or documented its importance there. Glad you checked the commit.\n\nFor distinguishing between local Rust and local NDK objects, forcing the Rust and NDK backend to use the same user data class (and exposing this information there) could work.\n\nNote you don\u0027t actually need the descriptor, since you can compare AIBinder_getClass with the one you have locally. Using the descriptor or this are both weird because they have similar logic on top of and below this API surface, but I can\u0027t think of another way. The key thing is it\u0027s always okay to allow a binder to be a remote proxy.",
      "parentUuid": "6508e5fb_281947a6",
      "revId": "1b49ebdeb40e8efe93779f7816f85505c1b4d64c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b637e357_20c9128f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-09-04T18:13:53Z",
      "side": 1,
      "message": "If we use the same AIBinder_Class pointer, wouldn\u0027t we would need the userdata used by Rust and C to match? We can\u0027t do that because the service can define arbitrary userdata and Rust uses its own custom userdata (the Rust service object). This is the same problem as APEX vs non-APEX in the same process, they can be different service userdata classes.\n\nI\u0027m a bit concerned about just comparing the AIBinder_Class pointer and treating the object as \"remote\" if the existing class doesn\u0027t match the expected one, without also comparing the descriptor strings. The asInterface cast in the C++ libbinder check the descriptor string, which is why I\u0027m thinking we should do that here. However, I guess the descriptor is always checked on transaction for ABBinders, so maybe it\u0027s not as big a deal.",
      "parentUuid": "9736c333_a258c052",
      "revId": "1b49ebdeb40e8efe93779f7816f85505c1b4d64c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}