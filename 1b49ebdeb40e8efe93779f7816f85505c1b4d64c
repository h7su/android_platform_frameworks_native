{
  "comments": [
    {
      "key": {
        "uuid": "6508e5fb_281947a6",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-09-04T01:00:48Z",
      "side": 1,
      "message": "Looking at the commit message for 57e43365d941fddc06fa1e00e2256e66d84eff06 in cts/ I can see why you were wanting the other behavior. We have the same issue of not being able to distinguish between local Rust and local NDK binder objects in this case.\n\nI think the other way I suggested via email, being able to retrieve the class descriptor and check it client-side or being able to provide a descriptor to the object and query if it matches, might be better here. In this case the client could check the descriptor, and treat the local object as if it were remote if the descriptor matches. The bottom line is that the client needs some way of knowing whether it\u0027s dealing with an object its module created or not, while at the same time accessing a local binder from another module as if were remote.",
      "revId": "1b49ebdeb40e8efe93779f7816f85505c1b4d64c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": false
    },
    {
      "key": {
        "uuid": "9736c333_a258c052",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-04T01:10:53Z",
      "side": 1,
      "message": "Oops, yeah. I should have given that test a more explicit name or documented its importance there. Glad you checked the commit.\n\nFor distinguishing between local Rust and local NDK objects, forcing the Rust and NDK backend to use the same user data class (and exposing this information there) could work.\n\nNote you don\u0027t actually need the descriptor, since you can compare AIBinder_getClass with the one you have locally. Using the descriptor or this are both weird because they have similar logic on top of and below this API surface, but I can\u0027t think of another way. The key thing is it\u0027s always okay to allow a binder to be a remote proxy.",
      "parentUuid": "6508e5fb_281947a6",
      "revId": "1b49ebdeb40e8efe93779f7816f85505c1b4d64c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b637e357_20c9128f",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-09-04T18:13:53Z",
      "side": 1,
      "message": "If we use the same AIBinder_Class pointer, wouldn\u0027t we would need the userdata used by Rust and C to match? We can\u0027t do that because the service can define arbitrary userdata and Rust uses its own custom userdata (the Rust service object). This is the same problem as APEX vs non-APEX in the same process, they can be different service userdata classes.\n\nI\u0027m a bit concerned about just comparing the AIBinder_Class pointer and treating the object as \"remote\" if the existing class doesn\u0027t match the expected one, without also comparing the descriptor strings. The asInterface cast in the C++ libbinder check the descriptor string, which is why I\u0027m thinking we should do that here. However, I guess the descriptor is always checked on transaction for ABBinders, so maybe it\u0027s not as big a deal.",
      "parentUuid": "9736c333_a258c052",
      "revId": "1b49ebdeb40e8efe93779f7816f85505c1b4d64c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "a905a0c5_c9f747e7",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2020-09-08T20:53:07Z",
      "side": 1,
      "message": "I am saying we could make them match (at least the data structure). Without extra work, it wouldn\u0027t allow someone external to the C++/Rust implementation to define their own implementation of an AIDL backend, but it works for the Rust/C++ backends.\n\n\u003e without also comparing the descriptor strings\n\nOnly the NDK backend does this, and I probably need to remove that behavior soon, because it\u0027s inefficient. As you pointed out, type safety really comes from the transaction header, where BAD_TYPE will be returned when the descriptor doesn\u0027t match.\n\n\u003e asInterface cast in the C++ libbinder check the descriptor string\n\nlibbinder_ndk has this method. In libbinder, interface_cast never had this check, and I added checked_interface_cast recently for cases where you want to be extra careful or fail early, but performance is not an issue. A lot of the time, relying on the AIDL type system (and getting failures later) is okay.\n\nFWIW, I think adding AIBinder_getDescriptor would be fine, but I don\u0027t think we should use it here (especially because it would mean Rust couldn\u0027t be used in an APEX which is compiled/run on older devices w/o that API).",
      "parentUuid": "b637e357_20c9128f",
      "revId": "1b49ebdeb40e8efe93779f7816f85505c1b4d64c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "654364db_bb8ef679",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 4
      },
      "lineNbr": 0,
      "author": {
        "id": 1093255
      },
      "writtenOn": "2020-09-08T21:21:07Z",
      "side": 1,
      "message": "Currently a Rust service stores a pointer to the Rust struct that implements the service in the NDK userdata field, while if I understand correctly a C++ NDK service usually stores an ICInterfaceData pointer (and an arbitrary NDK service may put anything into the userdata, right?). Perhaps I\u0027m missing something here, but those are fundamentally not interchangeable, no matter the data structure layout? We can trust that the local object interface methods can be directly invoked iff the class pointer matches the expected pointer.\n\nSorry I was referring to the call to queryLocalInterface to check the descriptor before returning a local object.\n\nIf we don\u0027t care about the descriptor string matching for local objects, I think we should just check the class pointer in Rust. If it\u0027s non-null but doesn\u0027t match the expected Rust version, we treat the object as if it were remote without checking the descriptor string. The NDK can then do the same to distinguish local services that match vs local services that have to be treated as remote (i.e. APEX or Rust).",
      "parentUuid": "a905a0c5_c9f747e7",
      "revId": "1b49ebdeb40e8efe93779f7816f85505c1b4d64c",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889",
      "unresolved": true
    }
  ]
}