{
  "comments": [
    {
      "unresolved": true,
      "key": {
        "uuid": "d6f54523_64e65b36",
        "filename": "libs/binder/FdTrigger.cpp",
        "patchSetId": 5
      },
      "lineNbr": 56,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "`fdState` as an argument name no longer makes sense\n\nalso, the arg name in the cc and h files are out of sync",
      "range": {
        "startLine": 56,
        "startChar": 56,
        "endLine": 56,
        "endChar": 63
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "606fa217_fc8ffb14",
        "filename": "libs/binder/FdTrigger.cpp",
        "patchSetId": 5
      },
      "lineNbr": 72,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-08-08T18:14:26Z",
      "side": 1,
      "message": "did we run binderRpcBenchmark before and after this? FWIW - if you inc polling now, it should only ever be 1/2. I know Frederick suggested for forwards compat, but we could also consider aborting if the FD is also polling here and save the atomic set.\n\nDid you try aborting if it\u0027s set to 2 and see if the test ever crashes? I don\u0027t think it should now, because these are protected by the connection mutex in RpcSession.",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 72,
        "endChar": 25
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "e5d680bb_42593993",
        "filename": "libs/binder/FdTrigger.cpp",
        "patchSetId": 5
      },
      "lineNbr": 72,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:29:28Z",
      "side": 1,
      "message": "what do you mean by \"save the atomic set\"? are you thinking the overhead of the atomic incr/decr ops is too much?\n\ni think you want the atomic ops whether it is a bool or an int because the read is going to happen outside of the mutex. it will *probably* be fine without it, but, when it comes to sync, i think you should always do it right unless you have a really good reason and think hard about it. especially since the main motivation is deflaking a fuzzer\n\nfor bool vs int, i don\u0027t think there is a performance difference (assuming we pick an int with the same size)",
      "parentUuid": "606fa217_fc8ffb14",
      "range": {
        "startLine": 72,
        "startChar": 0,
        "endLine": 72,
        "endChar": 25
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "046fd8c4_a718c5fc",
        "filename": "libs/binder/FdTrigger.cpp",
        "patchSetId": 5
      },
      "lineNbr": 76,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "need to decr in the error case",
      "range": {
        "startLine": 76,
        "startChar": 0,
        "endLine": 76,
        "endChar": 22
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0592fa89_5fd02dc2",
        "filename": "libs/binder/FdTrigger.h",
        "patchSetId": 5
      },
      "lineNbr": 58,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-08-08T18:14:26Z",
      "side": 1,
      "message": "nit: const + mutable field? or no? doesn\u0027t matter if it\u0027s all internal :)))",
      "range": {
        "startLine": 58,
        "startChar": 61,
        "endLine": 58,
        "endChar": 62
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "fb52fd13_c4827d78",
        "filename": "libs/binder/RpcSession.cpp",
        "patchSetId": 5
      },
      "lineNbr": 564,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "update variable name (`socket`?)",
      "range": {
        "startLine": 564,
        "startChar": 18,
        "endLine": 564,
        "endChar": 25
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0d8f6fb8_42aecf68",
        "filename": "libs/binder/include/binder/RpcThreads.h",
        "patchSetId": 5
      },
      "lineNbr": 131,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "did you confirm this is necessary? i\u0027m surprised if they don\u0027t have atomics since those are useful even in single threaded environments\n\nan alternative idea is to move the RpcSocket definition to this file, then not have a polling counter at all for the single threaded version. in the single threaded case, it won\u0027t be possible to check the counter value when something is polling, so it isn\u0027t worth tracking. OTOH, i don\u0027t think it is worth optimizing that much, only recommending this because it might be overall simpler than implementing a fake atomic counter",
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "24971fd2_e1581d8b",
        "filename": "libs/binder/include/binder/RpcThreads.h",
        "patchSetId": 5
      },
      "lineNbr": 131,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:19:09Z",
      "side": 1,
      "message": "(this is mostly just musing/curiosity, i think the solution is fine)",
      "parentUuid": "0d8f6fb8_42aecf68",
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4e8d3856_7801f07a",
        "filename": "libs/binder/include/binder/RpcThreads.h",
        "patchSetId": 5
      },
      "lineNbr": 149,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "should return `size_t` to match `std::atomic\u003csize_t\u003e` or return `void` if we don\u0027t care to actually use it",
      "range": {
        "startLine": 141,
        "startChar": 0,
        "endLine": 149,
        "endChar": 5
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "51c2a06a_3e6a9bd5",
        "filename": "libs/binder/include/binder/RpcThreads.h",
        "patchSetId": 5
      },
      "lineNbr": 155,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "do we need these? i don\u0027t see them in `std::atomic`",
      "range": {
        "startLine": 151,
        "startChar": 0,
        "endLine": 155,
        "endChar": 63
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "503d6bc3_6fe8e994",
        "filename": "libs/binder/include/binder/RpcTransport.h",
        "patchSetId": 5
      },
      "lineNbr": 86,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "document this, maybe\n\n// Whether any threads are blocked polling the transport (for reads or writes).\n\nif that is right, it seems to suggest an issue where, e.g., one thread is polling for a read, but another thread is actively writing. i think binder rpc is always single threaded w.r.t. a specific transport, so that shouldn\u0027t actually be an issue",
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "82b07172_23c25b30",
        "filename": "libs/binder/include/binder/RpcTransport.h",
        "patchSetId": 5
      },
      "lineNbr": 138,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-08-08T18:14:26Z",
      "side": 1,
      "message": "nit: (follow-up) add a reserved field or two here just in case?",
      "range": {
        "startLine": 137,
        "startChar": 0,
        "endLine": 138,
        "endChar": 31
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "b92eefe1_21baf3bb",
        "filename": "libs/binder/include/binder/RpcTransport.h",
        "patchSetId": 5
      },
      "lineNbr": 140,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "do we need a default constructor? if so, you should be able to delegate to the `unique_fd` default constructor",
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "5993a45b_6073c371",
        "filename": "libs/binder/include/binder/RpcTransport.h",
        "patchSetId": 5
      },
      "lineNbr": 142,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "all the one argument ctors should be marked `explicit`\n\nmaybe better to omit the `int` version and force callers to convert to `unique_fd` first, but either way is probably OK as long as it is marked `explicit`",
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "8b97ea4f_8686e4bc",
        "filename": "libs/binder/include/binder/RpcTransport.h",
        "patchSetId": 5
      },
      "lineNbr": 146,
      "author": {
        "id": 1944400
      },
      "writtenOn": "2022-08-08T18:15:57Z",
      "side": 1,
      "message": "i think you can omit the `noexcept`s, exceptions are globally disabled IIUC",
      "range": {
        "startLine": 146,
        "startChar": 36,
        "endLine": 146,
        "endChar": 44
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "12a19b85_eae0a053",
        "filename": "libs/binder/tests/binderRpcTest.cpp",
        "patchSetId": 5
      },
      "lineNbr": 1945,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2022-08-08T18:14:26Z",
      "side": 1,
      "message": "also add an \u0027isWaiting\u0027 here? (even if we only check the output is false)",
      "range": {
        "startLine": 1945,
        "startChar": 7,
        "endLine": 1945,
        "endChar": 23
      },
      "revId": "afe51a62cdfd4b750125ca2859a817b4a6cba4b8",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}