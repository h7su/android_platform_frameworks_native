{
  "comments": [
    {
      "unresolved": false,
      "key": {
        "uuid": "942e1d5e_54b9b4dd",
        "filename": "/PATCHSET_LEVEL",
        "patchSetId": 1
      },
      "lineNbr": 0,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2021-02-05T19:54:55Z",
      "side": 1,
      "message": "Here\u0027s an alternative CL which uses template overloading.  I uploaded this as a different approach to https://android-review.googlesource.com/c/platform/frameworks/native/+/1564604, but probably isn\u0027t as readable.",
      "revId": "4c3324a81011481b592804f6cdcc98a775f4de17",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "60acf851_1044c556",
        "filename": "libs/binder/include/binder/Parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 797,
      "author": {
        "id": 1132673
      },
      "writtenOn": "2021-02-09T14:24:00Z",
      "side": 1,
      "message": "The same comment that I made in aosp/1564604. Enabling via the return type doesn\u0027t look good for readability.\n\ntemplate \u003ctypename T, typename std::enable_if_t\u003cstd::is_same_v\u003cT, bool\u003e, bool\u003e \u003d true\u003e\nstatus_t writeData(const T\u0026 t) {...}\n\n\nWe could even simplify this by having a macro.\n\nENABLE_IF(std::is_same_v\u003cT, bool\u003e)\nstatus_t writeData(const T\u0026 t) {...}",
      "range": {
        "startLine": 796,
        "startChar": 44,
        "endLine": 797,
        "endChar": 13
      },
      "revId": "4c3324a81011481b592804f6cdcc98a775f4de17",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "9d0b20bb_79089835",
        "filename": "libs/binder/include/binder/Parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1036,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-02-06T00:42:26Z",
      "side": 1,
      "message": "These should be able to be regular overloading, right (no templates needed, same in other places)?\n\n    status_t readData(std::string* str) const { return readUtf8FromUtf16(t); }",
      "range": {
        "startLine": 1032,
        "startChar": 0,
        "endLine": 1036,
        "endChar": 5
      },
      "revId": "4c3324a81011481b592804f6cdcc98a775f4de17",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "364e9058_6fad5a3e",
        "filename": "libs/binder/include/binder/Parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1036,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2021-02-06T01:03:59Z",
      "side": 1,
      "message": "Yes, good point, that would be shorter. But I thought it best not to mix function overloading and template specialization/overloading so we can explicitly specify the template type - that allows the following code:\n\nreadData\u003cT\u003e(t)\nreadData\u003cstd::string\u003e(str)\n\nthen all the readData methods ought to be templated.   Maybe I can use template specialization instead - that might be more compact.  Let me consider that next.",
      "parentUuid": "9d0b20bb_79089835",
      "range": {
        "startLine": 1032,
        "startChar": 0,
        "endLine": 1036,
        "endChar": 5
      },
      "revId": "4c3324a81011481b592804f6cdcc98a775f4de17",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "0773f7b7_21cbe716",
        "filename": "libs/binder/include/binder/Parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1036,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-02-06T02:41:08Z",
      "side": 1,
      "message": "Yeah - the precedence rules for which function get picked get really tricky, but I think this kind of thing should be acceptable:\n\n    void readData(int32_t* a);\n    template \u003ctypename T\u003e\n    void readData(std::vector\u003cT\u003e* a);\n\nSince it\u0027s still very clear how a call will get directed. For the pointer types, you write 3 delegation functions, to a templated implementation.\n\nThough - template specialization works just as well (since we don\u0027t support every type, I wonder if the errors here when you use the wrong function aren\u0027t as nice)",
      "parentUuid": "364e9058_6fad5a3e",
      "range": {
        "startLine": 1032,
        "startChar": 0,
        "endLine": 1036,
        "endChar": 5
      },
      "revId": "4c3324a81011481b592804f6cdcc98a775f4de17",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": false,
      "key": {
        "uuid": "fca2caaf_26ccaa3f",
        "filename": "libs/binder/include/binder/Parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1036,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2021-02-08T19:02:09Z",
      "side": 1,
      "message": "I was checking if I could make template specialization work here, but it seems maybe C++20 concepts is really what we need to have.\n\nThe reason I avoided mixing function overloading with template overloading is that if you declare\n\n  // functional overloading\n  writeData(const int\u0026 float) { ... }   // const int\u0026 and int should be optimized to the same by the compiler.\n\nyou can\u0027t write something like\n\n#1\n  writeData\u003cfloat\u003e(10);   // writes as 10.f instead of (int32_t)10.\n\n#2\n  int i \u003d 20;\n  writeData\u003cfloat\u003e(i);  // writes i as a float.\n\nyou would have to write either\n\n  writeData(10.f);\n  writeData(static_cast\u003cfloat\u003e(i)) // this is necessary for functional overloading.\n\nwhich is a bit more non-intuitive.  I think forcing the type by func\u003cType\u003e is more idiomatic, hence the preference to go to the template overload only.",
      "parentUuid": "0773f7b7_21cbe716",
      "range": {
        "startLine": 1032,
        "startChar": 0,
        "endLine": 1036,
        "endChar": 5
      },
      "revId": "4c3324a81011481b592804f6cdcc98a775f4de17",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "4d65d37f_c20220f0",
        "filename": "libs/binder/include/binder/Parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1036,
      "author": {
        "id": 1120458
      },
      "writtenOn": "2021-02-08T23:42:35Z",
      "side": 1,
      "message": "Based on how these are used (reading/writing from arguments of the desired types or from fields), is this really an issue?",
      "parentUuid": "fca2caaf_26ccaa3f",
      "range": {
        "startLine": 1032,
        "startChar": 0,
        "endLine": 1036,
        "endChar": 5
      },
      "revId": "4c3324a81011481b592804f6cdcc98a775f4de17",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    },
    {
      "unresolved": true,
      "key": {
        "uuid": "653d2373_10fa5d38",
        "filename": "libs/binder/include/binder/Parcel.h",
        "patchSetId": 1
      },
      "lineNbr": 1036,
      "author": {
        "id": 1040213
      },
      "writtenOn": "2021-02-09T00:14:45Z",
      "side": 1,
      "message": "Per discussion with Steven, will move some methods to functional overloading when possible and make the current implementation private for now.  Only the existing APIs can call into it.  Please wait for the next PS. Thanks!",
      "parentUuid": "4d65d37f_c20220f0",
      "range": {
        "startLine": 1032,
        "startChar": 0,
        "endLine": 1036,
        "endChar": 5
      },
      "revId": "4c3324a81011481b592804f6cdcc98a775f4de17",
      "serverId": "85c56323-6fa9-3386-8a01-6480fb634889"
    }
  ]
}